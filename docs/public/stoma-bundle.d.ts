// Generated by dts-bundle-generator v9.5.1

import { Context, Hono, MiddlewareHandler, Next } from 'hono';

/**
 * Zero-dependency debug logging for edge runtimes.
 *
 * Provides `debug`-style namespace-based logging without the `debug` npm
 * package (which relies on `process.env` / `localStorage` and doesn't work
 * reliably in Cloudflare Workers). Output goes to `console.debug()`, which
 * is captured by `wrangler tail` and Cloudflare Workers Logs.
 *
 * @module debug
 *
 * @example
 * ```ts
 * // In gateway config
 * createGateway({ debug: "stoma:policy:*", ... });
 *
 * // In a policy
 * const debug = getGatewayContext(c)?.debug("stoma:policy:cache");
 * debug?.("HIT", cacheKey);
 * // Output: [stoma:policy:cache] HIT GET:/api/users
 * ```
 */
/** A debug logging function — call with a message and optional structured data. */
export type DebugLogger = (message: string, ...args: unknown[]) => void;
/**
 * Policy type system — the building blocks of gateway pipelines.
 *
 * A {@link Policy} is a named Hono middleware with priority ordering.
 * Policies are composed into pipelines at the global and route level,
 * merged by name (route-level wins), and sorted by priority ascending.
 *
 * The {@link PolicyContext} provides request metadata (ID, timing, debug)
 * to policies at runtime via `getGatewayContext(c)`.
 *
 * @module policy-types
 */
/**
 * A Policy is a named Hono middleware with metadata.
 * Policies are the building blocks of gateway pipelines.
 */
export interface Policy {
	/** Unique policy name (e.g. "jwt-auth", "rate-limit") */
	name: string;
	/** The Hono middleware handler */
	handler: MiddlewareHandler;
	/** Policy priority — lower numbers execute first. Default: 100. */
	priority?: number;
}
/** Base configuration shared by all policies */
export interface PolicyConfig {
	/** Skip this policy when condition returns true */
	skip?: (c: unknown) => boolean | Promise<boolean>;
}
/** Context available to policies during execution */
export interface PolicyContext {
	/** Unique request ID for tracing */
	requestId: string;
	/** Timestamp when the request entered the gateway */
	startTime: number;
	/** Gateway name */
	gatewayName: string;
	/** Matched route path pattern */
	routePath: string;
	/** W3C Trace Context — 32-hex trace ID (propagated or generated). */
	traceId: string;
	/** W3C Trace Context — 16-hex span ID for this gateway request. */
	spanId: string;
	/**
	 * Get a debug logger for the given namespace.
	 * Returns a no-op when debug is disabled (zero overhead).
	 *
	 * @example
	 * ```ts
	 * const ctx = getGatewayContext(c);
	 * const debug = ctx?.debug("stoma:policy:cache");
	 * debug?.("HIT", cacheKey);
	 * ```
	 */
	debug: (namespace: string) => DebugLogger;
	/** Runtime adapter providing store implementations and runtime-specific capabilities. */
	adapter?: GatewayAdapter;
}
/**
 * Response caching policy with pluggable storage backends.
 *
 * @module cache
 */
/** Pluggable cache storage backend */
export interface CacheStore {
	/** Retrieve a cached response by key. Returns null on miss. */
	get(key: string): Promise<Response | null>;
	/** Store a response under key with a TTL in seconds. */
	put(key: string, response: Response, ttlSeconds: number): Promise<void>;
	/** Delete a cached entry. Returns true if something was removed. */
	delete(key: string): Promise<boolean>;
}
/** Options for the in-memory cache store. */
export interface InMemoryCacheStoreOptions {
	/** Maximum number of cached entries. When exceeded, the oldest entry is evicted (LRU). */
	maxEntries?: number;
}
export declare class InMemoryCacheStore implements CacheStore {
	private entries;
	private maxEntries;
	constructor(options?: InMemoryCacheStoreOptions);
	get(key: string): Promise<Response | null>;
	put(key: string, response: Response, ttlSeconds: number): Promise<void>;
	delete(key: string): Promise<boolean>;
	/** Remove all entries (for testing) */
	clear(): void;
	/** Current number of entries (for testing/inspection) */
	get size(): number;
}
export interface CacheConfig extends PolicyConfig {
	/** Cache TTL in seconds. Default: 300. */
	ttlSeconds?: number;
	/** HTTP methods to cache. Default: ["GET"]. Case-insensitive. */
	methods?: string[];
	/** Custom cache key builder. Supports async for body-based keys. Default: method + url (+ body hash for POST/PUT/PATCH). */
	cacheKeyFn?: (c: Context) => string | Promise<string>;
	/** Only cache responses with these status codes. When set, responses with other statuses are not cached (5xx is always excluded regardless). */
	cacheableStatuses?: number[];
	/** Vary cache key on these request headers. */
	varyHeaders?: string[];
	/** Storage backend. Default: InMemoryCacheStore. */
	store?: CacheStore;
	/** Respect upstream Cache-Control directives. Default: true. */
	respectCacheControl?: boolean;
	/** Response header name for cache status (HIT/MISS/BYPASS/SKIP). Default: `"x-cache"`. */
	cacheStatusHeader?: string;
	/** Cache-Control directives that trigger a bypass. Matched at the directive level, not substring. Default: `["no-store", "no-cache"]`. */
	bypassDirectives?: string[];
}
/**
 * Cache upstream responses to reduce latency and load.
 *
 * Sets a cache status header on **every** response:
 * - `HIT` — served from cache
 * - `MISS` — fetched from upstream, now cached
 * - `BYPASS` — upstream Cache-Control directive prevented caching
 * - `SKIP` — not eligible for caching (wrong method or server error status)
 *
 * Server error responses (5xx) are never cached. Store failures degrade
 * gracefully via {@link safeCall} — a broken cache store never crashes the
 * request.
 *
 * For methods with a request body (POST, PUT, PATCH), the default cache key
 * includes a SHA-256 hash of the body to prevent key collisions across
 * different payloads.
 *
 * @param config - Cache TTL, storage backend, and key strategy. All fields optional.
 * @returns A {@link Policy} at priority 40.
 *
 * @example
 * ```ts
 * // Simple 5-minute in-memory cache for GET requests
 * cache({ ttlSeconds: 300 });
 *
 * // Cache with Vary on Accept-Language and custom store
 * cache({
 *   ttlSeconds: 600,
 *   varyHeaders: ["accept-language"],
 *   store: new CacheApiCacheStore(caches.default),
 * });
 * ```
 */
export declare function cache(config?: CacheConfig): Policy;
/**
 * Circuit breaker policy — protect upstream services from cascading failures.
 *
 * Implements the three-state circuit breaker pattern (closed / open / half-open)
 * with pluggable state storage via {@link CircuitBreakerStore}.
 *
 * @module circuit-breaker
 */
/** The three states of the circuit breaker state machine. */
export type CircuitState = "closed" | "open" | "half-open";
/** Point-in-time snapshot of a circuit's state and counters. */
export interface CircuitBreakerSnapshot {
	/** Current circuit state. */
	state: CircuitState;
	/** Number of consecutive failures since last reset. */
	failureCount: number;
	/** Number of successful probes in half-open state. */
	successCount: number;
	/** Epoch ms of the most recent failure. `0` if no failures recorded. */
	lastFailureTime: number;
	/** Epoch ms of the most recent state transition. */
	lastStateChange: number;
}
/**
 * Pluggable storage backend for circuit breaker state.
 *
 * Implement this interface to store circuit state in Durable Objects,
 * KV, or any shared datastore for multi-instance deployments.
 */
export interface CircuitBreakerStore {
	/** Read the current snapshot for a circuit key. */
	getState(key: string): Promise<CircuitBreakerSnapshot>;
	/** Record a successful request and return the updated snapshot. */
	recordSuccess(key: string): Promise<CircuitBreakerSnapshot>;
	/** Record a failed request and return the updated snapshot. */
	recordFailure(key: string): Promise<CircuitBreakerSnapshot>;
	/** Transition the circuit to a new state and return the updated snapshot. */
	transition(key: string, to: CircuitState): Promise<CircuitBreakerSnapshot>;
	/** Fully reset a circuit, removing all state. */
	reset(key: string): Promise<void>;
}
export declare class InMemoryCircuitBreakerStore implements CircuitBreakerStore {
	private circuits;
	private getOrCreate;
	getState(key: string): Promise<CircuitBreakerSnapshot>;
	recordSuccess(key: string): Promise<CircuitBreakerSnapshot>;
	recordFailure(key: string): Promise<CircuitBreakerSnapshot>;
	transition(key: string, to: CircuitState): Promise<CircuitBreakerSnapshot>;
	reset(key: string): Promise<void>;
	/** Remove all circuits (for testing) */
	clear(): void;
}
export interface CircuitBreakerConfig extends PolicyConfig {
	/** Number of failures before opening the circuit. Default: 5. */
	failureThreshold?: number;
	/** Time in ms before transitioning from open → half-open. Default: 30000. */
	resetTimeoutMs?: number;
	/** Max concurrent probes allowed in half-open state. Default: 1. */
	halfOpenMax?: number;
	/** Status codes considered failures. Default: [500, 502, 503, 504]. */
	failureOn?: number[];
	/** Storage backend. Default: InMemoryCircuitBreakerStore. */
	store?: CircuitBreakerStore;
	/** Key extractor. Default: request URL pathname. */
	key?: (c: Context) => string;
	/** HTTP status code when the circuit is open. Default: 503. */
	openStatusCode?: number;
	/**
	 * Callback invoked on every state transition.
	 *
	 * Called via `safeCall` so errors are swallowed — a failing callback
	 * never blocks traffic. Useful for metrics, logging, or alerting.
	 *
	 * @param key - The circuit key that transitioned.
	 * @param from - The previous circuit state.
	 * @param to - The new circuit state.
	 */
	onStateChange?: (key: string, from: CircuitState, to: CircuitState) => void | Promise<void>;
}
/**
 * Protect upstream services by breaking the circuit on repeated failures.
 *
 * Implements the three-state circuit breaker pattern:
 * - **Closed** — requests flow normally; failures are counted.
 * - **Open** — requests are immediately rejected with 503; a `Retry-After` header is set.
 * - **Half-open** — a limited number of probe requests are allowed through to test recovery.
 *
 * State transitions: `closed → open` when failures reach the threshold,
 * `open → half-open` after the reset timeout, `half-open → closed` on
 * probe success or `half-open → open` on probe failure.
 *
 * @param config - Failure threshold, reset timeout, and storage backend.
 * @returns A {@link Policy} at priority 30.
 *
 * @example
 * ```ts
 * // Open after 5 failures, retry after 30s
 * circuitBreaker();
 *
 * // Tighter threshold with custom store
 * circuitBreaker({
 *   failureThreshold: 3,
 *   resetTimeoutMs: 10_000,
 *   failureOn: [500, 502, 503],
 *   store: new InMemoryCircuitBreakerStore(),
 * });
 *
 * // With state change notifications
 * circuitBreaker({
 *   failureThreshold: 5,
 *   onStateChange: (key, from, to) => {
 *     console.log(`Circuit ${key}: ${from} -> ${to}`);
 *   },
 * });
 * ```
 */
export declare function circuitBreaker(config?: CircuitBreakerConfig): Policy;
/**
 * Rate limiting policy with pluggable counter storage.
 *
 * @module rate-limit
 */
export interface RateLimitConfig extends PolicyConfig {
	/** Maximum requests per window */
	max: number;
	/** Time window in seconds. Default: 60. */
	windowSeconds?: number;
	/** Key extractor — determines the rate limit bucket. Default: client IP. */
	keyBy?: (c: Context) => string | Promise<string>;
	/** Storage backend for counters */
	store?: RateLimitStore;
	/** Response status code when limited. Default: 429. */
	statusCode?: number;
	/** Custom response body when limited */
	message?: string;
	/** Ordered list of headers to inspect for the client IP (when `keyBy` is not set). Default: `["cf-connecting-ip", "x-forwarded-for"]`. */
	ipHeaders?: string[];
}
/** Pluggable storage backend for rate limit counters */
export interface RateLimitStore {
	/** Increment the counter for a key, returning the new count and TTL */
	increment(key: string, windowSeconds: number): Promise<{
		count: number;
		resetAt: number;
	}>;
	/** Optional: cleanup resources (like intervals) used by the store */
	destroy?(): void;
}
/** Default in-memory rate limit store */
export interface InMemoryRateLimitStoreOptions {
	/** Maximum number of unique keys to prevent memory exhaustion. Default: 100000. */
	maxKeys?: number;
	/** Cleanup interval in ms for expired entries. Default: 60000. */
	cleanupIntervalMs?: number;
}
/**
 * Rate limit requests with pluggable storage backends.
 *
 * Defaults to client IP extraction via `CF-Connecting-IP` or `X-Forwarded-For`.
 * Sets standard `X-RateLimit-*` response headers on every request and
 * throws a 429 when the limit is exceeded.
 *
 * @param config - Rate limit settings. `max` is required; other fields have sensible defaults.
 * @returns A {@link Policy} at priority 20 (runs after auth).
 *
 * @example
 * ```ts
 * // 100 requests per minute per IP (in-memory)
 * rateLimit({ max: 100 });
 *
 * // Custom key + Cloudflare KV store
 * rateLimit({
 *   max: 50,
 *   windowSeconds: 300,
 *   keyBy: (c) => c.req.header("x-user-id") ?? "anonymous",
 *   store: new KVRateLimitStore(env.RATE_LIMIT_KV),
 * });
 * ```
 */
export declare function rateLimit(config: RateLimitConfig): Policy;
/** Bag of optional store implementations and runtime capabilities for a given runtime. */
export interface GatewayAdapter {
	rateLimitStore?: RateLimitStore;
	circuitBreakerStore?: CircuitBreakerStore;
	cacheStore?: CacheStore;
	/** Schedule background work that outlives the response (e.g. Cloudflare `executionCtx.waitUntil`). */
	waitUntil?: (promise: Promise<unknown>) => void;
	/** Dispatch a request to a named service binding or sidecar. */
	dispatchBinding?: (service: string, request: Request) => Promise<Response>;
}
/**
 * Pluggable metrics collection for the gateway pipeline.
 *
 * Defines the {@link MetricsCollector} interface and provides an
 * {@link InMemoryMetricsCollector} for testing and development.
 * The {@link toPrometheusText} function serializes a snapshot to
 * Prometheus text exposition format.
 *
 * @module metrics
 */
/** A single tagged metric data point. */
export interface TaggedValue {
	value: number;
	tags?: Record<string, string>;
}
/** A histogram data point with accumulated values. */
export interface HistogramEntry {
	values: number[];
	tags?: Record<string, string>;
}
/** Point-in-time snapshot of all collected metrics. */
export interface MetricsSnapshot {
	counters: Record<string, TaggedValue[]>;
	histograms: Record<string, HistogramEntry[]>;
	gauges: Record<string, TaggedValue[]>;
}
/**
 * Pluggable metrics collector interface.
 *
 * Implementations can ship metrics to Prometheus, Datadog, CloudWatch,
 * or any other backend. The gateway pipeline records request counts,
 * latencies, and error rates through this interface.
 */
export interface MetricsCollector {
	/** Increment a counter by `value` (default 1). */
	increment(name: string, value?: number, tags?: Record<string, string>): void;
	/** Record a histogram observation. */
	histogram(name: string, value: number, tags?: Record<string, string>): void;
	/** Set a gauge to an absolute value. */
	gauge(name: string, value: number, tags?: Record<string, string>): void;
	/** Return a point-in-time snapshot of all metrics. */
	snapshot(): MetricsSnapshot;
	/** Reset all metrics to zero. */
	reset(): void;
}
/**
 * In-memory metrics collector for testing, development, and admin API.
 *
 * Accumulates counters, histograms, and gauges in plain arrays/maps.
 * Not intended for high-throughput production use — prefer shipping
 * metrics to a dedicated backend for production workloads.
 */
export declare class InMemoryMetricsCollector implements MetricsCollector {
	private counters;
	private histograms;
	private gauges;
	increment(name: string, value?: number, tags?: Record<string, string>): void;
	histogram(name: string, value: number, tags?: Record<string, string>): void;
	gauge(name: string, value: number, tags?: Record<string, string>): void;
	snapshot(): MetricsSnapshot;
	reset(): void;
}
/**
 * Serialize a metrics snapshot to Prometheus text exposition format.
 *
 * Produces lines like:
 * ```
 * gateway_requests_total{method="GET",status="200"} 42
 * gateway_request_duration_ms_sum{method="GET"} 1234
 * gateway_request_duration_ms_count{method="GET"} 10
 * ```
 *
 * @param snapshot - The metrics snapshot to serialize.
 * @returns Prometheus text exposition format string.
 */
export declare function toPrometheusText(snapshot: MetricsSnapshot): string;
/**
 * Core type definitions for the stoma gateway.
 *
 * All gateway configuration is expressed through these types. The main entry
 * point is {@link GatewayConfig}, which composes {@link RouteConfig},
 * {@link PipelineConfig}, and {@link UpstreamConfig} into a fully declarative
 * gateway specification.
 *
 * @module types
 */
/** Top-level gateway configuration */
export interface GatewayConfig {
	/** Gateway name, used in logs and metrics */
	name?: string;
	/** Base path prefix for all routes (e.g. "/api") */
	basePath?: string;
	/** Route definitions */
	routes: RouteConfig[];
	/** Global policies applied to all routes */
	policies?: Policy[];
	/** Global error handler */
	onError?: (error: Error, c: unknown) => Response | Promise<Response>;
	/**
	 * Enable internal debug logging for gateway operators.
	 *
	 * - `true` — log all namespaces
	 * - `false` / `undefined` — disabled (default, zero overhead)
	 * - `string` — comma-separated glob patterns to filter namespaces
	 *
	 * Namespaces: `stoma:gateway`, `stoma:pipeline`, `stoma:upstream`,
	 * `stoma:policy:*` (e.g. `stoma:policy:cache`, `stoma:policy:jwt-auth`)
	 *
	 * Output goes to `console.debug()` which is captured by `wrangler tail`
	 * and Cloudflare Workers Logs.
	 *
	 * @example
	 * ```ts
	 * createGateway({ debug: true, ... })                         // everything
	 * createGateway({ debug: "stoma:gateway,stoma:upstream", ... }) // core only
	 * createGateway({ debug: "stoma:policy:*", ... })              // policies only
	 * ```
	 */
	debug?: boolean | string;
	/** Response header name for the request ID. Default: `"x-request-id"`. */
	requestIdHeader?: string;
	/**
	 * Default HTTP methods for routes that don't specify `methods`.
	 * Default: `["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"]`.
	 */
	defaultMethods?: HttpMethod[];
	/** Default error message for unexpected (non-GatewayError) errors. Default: `"An unexpected error occurred"`. */
	defaultErrorMessage?: string;
	/** Default priority for policies that don't specify one. Default: `100`. */
	defaultPolicyPriority?: number;
	/**
	 * Runtime adapter providing store implementations and runtime-specific capabilities
	 * (e.g. `waitUntil`, `dispatchBinding`). Created via adapter factories like
	 * `cloudflareAdapter()`, `memoryAdapter()`, etc.
	 */
	adapter?: GatewayAdapter;
	/**
	 * Admin introspection API. Exposes `___gateway/*` routes for operational visibility.
	 *
	 * - `true` — enable with defaults (no auth)
	 * - `AdminConfig` object — full customization
	 * - `false` / `undefined` — disabled (default)
	 */
	admin?: boolean | AdminConfig;
	/**
	 * Enable client-requested debug headers.
	 *
	 * When enabled, clients can send an `x-stoma-debug` request header listing
	 * the debug values they want returned as response headers. Policies contribute
	 * debug data via {@link setDebugHeader} from the SDK — only requested values
	 * are included in the response.
	 *
	 * - `true` — enable with defaults
	 * - `DebugHeadersConfig` — full customization (request header name, allowlist)
	 * - `false` / `undefined` — disabled (default, zero overhead)
	 *
	 * @example
	 * ```
	 * // Client request:
	 * GET /api/users
	 * x-stoma-debug: x-stoma-cache-key, x-stoma-cache-ttl
	 *
	 * // Response includes:
	 * x-stoma-cache-key: GET:http://example.com/api/users
	 * x-stoma-cache-ttl: 300
	 * ```
	 */
	debugHeaders?: boolean | DebugHeadersConfig;
}
/** Configuration for client-requested debug headers. */
export interface DebugHeadersConfig {
	/** Request header name clients use to request debug values. Default: `"x-stoma-debug"`. */
	requestHeader?: string;
	/** Allowlist of debug header names clients can request. When set, only these headers are emitted. Default: all. */
	allow?: string[];
}
/** Individual route configuration */
export interface RouteConfig {
	/** Route path pattern (Hono syntax, e.g. "/users/:id") */
	path: string;
	/** Allowed HTTP methods. Defaults to all. */
	methods?: HttpMethod[];
	/** Pipeline to process this route */
	pipeline: PipelineConfig;
	/** Route-level metadata for logging/observability */
	metadata?: Record<string, unknown>;
}
/** Pipeline: ordered chain of policies leading to an upstream */
export interface PipelineConfig {
	/** Policies executed in order before the upstream */
	policies?: Policy[];
	/** Upstream target configuration */
	upstream: UpstreamConfig;
}
/** Upstream target — where the request is forwarded */
export type UpstreamConfig = UrlUpstream | ServiceBindingUpstream | HandlerUpstream;
/**
 * Proxy to a remote URL. The gateway clones the request, rewrites headers,
 * and forwards it via `fetch()`. SSRF protection ensures the rewritten URL
 * stays on the same origin as the target.
 */
export interface UrlUpstream {
	type: "url";
	/** Target URL (e.g. `"https://api.example.com"`). Validated at config time. */
	target: string;
	/** Rewrite the path before forwarding. Must not change the origin. */
	rewritePath?: (path: string) => string;
	/** Headers to add/override on the forwarded request. */
	headers?: Record<string, string>;
}
/**
 * Forward to another Cloudflare Worker via a Service Binding.
 * The binding must be configured in the consumer's `wrangler.toml`.
 */
export interface ServiceBindingUpstream {
	type: "service-binding";
	/** Name of the Service Binding in `wrangler.toml` (e.g. `"AUTH_SERVICE"`). */
	service: string;
	/** Rewrite the path before forwarding to the bound service. */
	rewritePath?: (path: string) => string;
}
/**
 * Invoke a custom handler function directly. Useful for health checks,
 * mock responses, or routes that don't proxy to an upstream.
 */
export interface HandlerUpstream {
	type: "handler";
	/** Handler function receiving the Hono context and returning a Response. */
	handler: (c: Context) => Response | Promise<Response>;
}
/** HTTP methods supported by gateway route registration. */
export type HttpMethod = "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "HEAD" | "OPTIONS";
/** Configuration for the admin introspection API. */
export interface AdminConfig {
	/** Enable admin routes. Default: `false`. */
	enabled: boolean;
	/** Path prefix for admin routes. Default: `"___gateway"`. */
	prefix?: string;
	/** Optional auth check — return `false` to deny access. */
	auth?: (c: Context) => boolean | Promise<boolean>;
	/** MetricsCollector instance for the `/metrics` endpoint. */
	metrics?: MetricsCollector;
}
/** Registered route information for admin introspection. */
export interface RegisteredRoute {
	path: string;
	methods: string[];
	policyNames: string[];
	upstreamType: string;
}
/** Registered policy information for admin introspection. */
export interface RegisteredPolicy {
	name: string;
	priority: number;
}
/** Internal registry for admin introspection. */
export interface GatewayRegistry {
	routes: RegisteredRoute[];
	policies: RegisteredPolicy[];
	gatewayName: string;
}
/** The instantiated gateway — a configured Hono app */
export interface GatewayInstance {
	/** The underlying Hono app, ready to be exported as a Worker */
	app: Hono;
	/** Registered route count */
	routeCount: number;
	/** Gateway name */
	name: string;
	/** Internal registry for admin introspection */
	_registry: GatewayRegistry;
}
declare class TestAdapter implements GatewayAdapter {
	private promises;
	/**
	 * Add a promise to the background work queue.
	 */
	waitUntil: (promise: Promise<unknown>) => void;
	/**
	 * Await all pending background work collected via `waitUntil`.
	 */
	waitAll(): Promise<void>;
	/**
	 * Reset the collected promises.
	 */
	reset(): void;
}
/**
 * Named priority constants for policy ordering.
 *
 * Lower numbers execute first. These replace magic numbers throughout
 * the built-in policies and are exported for custom policy authors.
 *
 * @module priority
 */
export declare const Priority: {
	/** Observability policies (e.g. requestLog) — wraps everything */
	readonly OBSERVABILITY: 0;
	/** IP filtering — runs before all other logic */
	readonly IP_FILTER: 1;
	/** Metrics collection — just after observability */
	readonly METRICS: 1;
	/** Early pipeline (e.g. cors) — before auth */
	readonly EARLY: 5;
	/** Authentication (e.g. jwtAuth, apiKeyAuth, basicAuth) */
	readonly AUTH: 10;
	/** Rate limiting — after auth */
	readonly RATE_LIMIT: 20;
	/** Circuit breaker — protects upstream */
	readonly CIRCUIT_BREAKER: 30;
	/** Caching — before upstream */
	readonly CACHE: 40;
	/** Request header transforms — mid-pipeline */
	readonly REQUEST_TRANSFORM: 50;
	/** Timeout — wraps upstream call */
	readonly TIMEOUT: 85;
	/** Retry — wraps upstream fetch */
	readonly RETRY: 90;
	/** Response header transforms — after upstream */
	readonly RESPONSE_TRANSFORM: 92;
	/** Proxy header manipulation — just before upstream */
	readonly PROXY: 95;
	/** Default priority for unspecified policies */
	readonly DEFAULT: 100;
	/** Mock — terminal, replaces upstream */
	readonly MOCK: 999;
};
/** Union of all named priority levels. */
export type PriorityLevel = (typeof Priority)[keyof typeof Priority];
/**
 * Composable helpers for policy authors.
 *
 * Utilities that eliminate the most common boilerplate:
 * - {@link resolveConfig} — merge defaults with user config
 * - {@link policyDebug} — get a pre-namespaced debug logger
 * - {@link withSkip} — wrap a handler with `PolicyConfig.skip` logic
 * - {@link safeCall} — graceful store failure degradation
 * - {@link setDebugHeader} — contribute debug data for client-requested debug headers
 *
 * @module helpers
 */
/**
 * Merge default config values with user-provided config.
 *
 * Performs a shallow merge: `{ ...defaults, ...userConfig }`.
 * Explicit `undefined` values in userConfig override defaults.
 *
 * @param defaults - Default values for all optional config fields.
 * @param userConfig - User-provided config (may be undefined).
 * @returns Fully merged config typed as `TConfig`.
 */
export declare function resolveConfig<TConfig>(defaults: Partial<TConfig>, userConfig?: Partial<TConfig>): TConfig;
/**
 * Get a debug logger pre-namespaced to `stoma:policy:{name}`.
 *
 * Returns {@link noopDebugLogger} when there is no gateway context
 * (e.g. outside a gateway pipeline) or when debug is disabled.
 * This eliminates the repeated `getGatewayContext(c)?.debug(...)` pattern.
 *
 * @param c - Hono request context.
 * @param policyName - Policy name used in the namespace.
 * @returns A {@link DebugLogger} — always callable, never undefined.
 */
export declare function policyDebug(c: Context, policyName: string): DebugLogger;
/**
 * Wrap a middleware handler with skip logic.
 *
 * If `skipFn` is undefined, returns the original handler unchanged
 * (zero overhead). Otherwise wraps it: when `skipFn(c)` returns `true`,
 * calls `next()` without running the handler.
 *
 * This implements the `PolicyConfig.skip` feature that was defined in
 * types but never enforced at runtime.
 *
 * @param skipFn - Optional predicate from `PolicyConfig.skip`.
 * @param handler - The policy's middleware handler.
 * @returns The original handler or a skip-aware wrapper.
 */
export declare function withSkip(skipFn: ((c: unknown) => boolean | Promise<boolean>) | undefined, handler: MiddlewareHandler): MiddlewareHandler;
declare function safeCall<T>(fn: () => Promise<T>, fallback: T, debug?: DebugLogger, label?: string): Promise<T>;
/**
 * Set a debug header value for client-requested debug output.
 *
 * Policies call this to contribute debug data. The value is only stored
 * if the client requested it via the `x-stoma-debug` request header AND
 * the gateway has debug headers enabled. When neither condition is met,
 * this is a no-op (single Map lookup).
 *
 * @param c - Hono request context.
 * @param name - Header name (e.g. `"x-stoma-cache-key"`).
 * @param value - Header value. Numbers and booleans are stringified.
 *
 * @example
 * ```ts
 * setDebugHeader(c, "x-stoma-cache-key", key);
 * setDebugHeader(c, "x-stoma-cache-ttl", resolved.ttlSeconds);
 * ```
 */
export declare function setDebugHeader(c: Context, name: string, value: string | number | boolean): void;
declare function parseDebugRequest(c: Context, requestHeaderName: string, allow?: string[]): void;
declare function getCollectedDebugHeaders(c: Context): Map<string, string> | undefined;
declare function isDebugRequested(c: Context): boolean;
/**
 * Policy trace — structured per-policy trace entries for deep debugging.
 *
 * Provides a zero-overhead reporter API (`TraceReporter`) that policies
 * call to record what they did. When tracing is not active, the reporter
 * is a no-op constant — no allocations, no Map lookups.
 *
 * @module trace
 */
/** Auto-captured by the pipeline for every policy when tracing is active. */
export interface PolicyTraceBaseline {
	name: string;
	priority: number;
	durationMs: number;
	calledNext: boolean;
	error: string | null;
}
/** Policy-reported detail (cooperative opt-in via `trace()`). */
export interface PolicyTraceDetail {
	action: string;
	data?: Record<string, unknown>;
}
/** Combined baseline + optional detail for a single policy. */
export interface PolicyTraceEntry extends PolicyTraceBaseline {
	detail?: PolicyTraceDetail;
}
/** Full trace payload emitted as the `x-stoma-trace` response header. */
export interface PolicyTrace {
	requestId: string;
	traceId: string;
	route: string;
	totalMs: number;
	entries: PolicyTraceEntry[];
}
/**
 * A trace reporter function. Always callable — no-op when tracing is inactive.
 *
 * @param action - Human-readable action string (e.g. `"HIT"`, `"allowed"`).
 * @param data   - Optional structured context data.
 */
export type TraceReporter = (action: string, data?: Record<string, unknown>) => void;
declare const noopTraceReporter: TraceReporter;
/**
 * Get a trace reporter for a specific policy.
 *
 * When tracing is active (`_stomaTraceRequested` is truthy), returns a
 * function that stores the detail on the context. When inactive, returns
 * {@link noopTraceReporter} — a no-op with zero overhead.
 *
 * @param c          - Hono request context.
 * @param policyName - Policy name used as the Map key.
 * @returns A {@link TraceReporter} — always callable.
 */
export declare function policyTrace(c: Context, policyName: string): TraceReporter;
declare function isTraceRequested(c: Context): boolean;
/**
 * `definePolicy()` — full convenience wrapper for policy authors.
 *
 * Combines {@link resolveConfig}, {@link policyDebug}, and {@link withSkip}
 * into a single declarative API. Takes a {@link PolicyDefinition} and returns
 * a factory function `(config?) => Policy`.
 *
 * @module define-policy
 */
/**
 * Context injected into every `definePolicy` handler invocation.
 *
 * Provides the fully-merged config, a pre-namespaced debug logger,
 * and the gateway context (request ID, trace ID, etc.).
 */
export interface PolicyHandlerContext<TConfig> {
	/** Fully merged config (defaults + user overrides). */
	config: TConfig;
	/** Debug logger pre-namespaced to `stoma:policy:{name}`. Always callable. */
	debug: DebugLogger;
	/** Trace reporter — always callable, no-op when tracing is not active. */
	trace: TraceReporter;
	/** Gateway context, or `undefined` when running outside a gateway pipeline. */
	gateway: PolicyContext | undefined;
}
/**
 * Declarative policy definition passed to {@link definePolicy}.
 */
export interface PolicyDefinition<TConfig extends PolicyConfig = PolicyConfig> {
	/** Unique policy name (e.g. `"my-auth"`, `"custom-cache"`). */
	name: string;
	/** Execution priority. Use {@link Priority} constants. Default: `Priority.DEFAULT` (100). */
	priority?: number;
	/** Default values for optional config fields. */
	defaults?: Partial<TConfig>;
	/**
	 * Optional construction-time config validation.
	 *
	 * Called once when the factory is invoked (before any requests).
	 * Throw a {@link GatewayError} to reject invalid config eagerly
	 * rather than failing on the first request.
	 */
	validate?: (config: TConfig) => void;
	/**
	 * The policy handler. Receives the Hono context, `next`, and a
	 * {@link PolicyHandlerContext} with config, debug, and gateway context.
	 */
	handler: (c: Context, next: Next, ctx: PolicyHandlerContext<TConfig>) => Promise<void> | void;
}
/**
 * Create a policy factory from a declarative definition.
 *
 * The returned factory function accepts optional user config, merges it
 * with defaults, wires up skip logic, and injects a debug logger at
 * request time.
 *
 * @example
 * ```ts
 * import { definePolicy, Priority } from "@homegrower-club/stoma";
 *
 * const myPolicy = definePolicy<MyConfig>({
 *   name: "my-policy",
 *   priority: Priority.AUTH,
 *   defaults: { headerName: "x-custom" },
 *   handler: async (c, next, { config, debug }) => {
 *     debug("checking header");
 *     const value = c.req.header(config.headerName!);
 *     if (!value) throw new GatewayError(401, "unauthorized", "Missing header");
 *     await next();
 *   },
 * });
 *
 * // Usage: myPolicy({ headerName: "x-api-key" })
 * ```
 *
 * @param definition - Policy name, priority, defaults, and handler.
 * @returns A factory function: `(config?) => Policy`.
 */
export declare function definePolicy<TConfig extends PolicyConfig = PolicyConfig>(definition: PolicyDefinition<TConfig>): (config?: TConfig) => Policy;
export interface PolicyTestHarnessOptions {
	/**
	 * Custom upstream handler. Receives the Hono context after the policy
	 * runs. Default: returns `{ ok: true }` with status 200.
	 */
	upstream?: MiddlewareHandler;
	/** Route path pattern for the test app. Default: `"/*"`. */
	path?: string;
	/** Gateway name injected into context. Default: `"test-gateway"`. */
	gatewayName?: string;
	/** Custom adapter to use. If not provided, a {@link TestAdapter} is created. */
	adapter?: TestAdapter;
}
/**
 * Create a minimal test app with a single policy, error handling,
 * gateway context injection, and a configurable upstream.
 *
 * @example
 * ```ts
 * import { createPolicyTestHarness } from "@homegrower-club/stoma/policies";
 * import { myPolicy } from "./my-policy";
 *
 * const { request, adapter } = createPolicyTestHarness(myPolicy({ max: 10 }));
 *
 * it("should allow valid requests", async () => {
 *   const res = await request("/test");
 *   expect(res.status).toBe(200);
 *   // Await any background work (e.g. waitUntil)
 *   await adapter.waitAll();
 * });
 * ```
 *
 * @param policy - The policy instance to test.
 * @param options - Optional upstream, path, and gateway name.
 * @returns An object with `request()`, `app`, and the `adapter` used.
 */
export declare function createPolicyTestHarness(policy: Policy, options?: PolicyTestHarnessOptions): {
	/** The underlying Hono app for advanced test scenarios. */
	app: Hono<hono_types.BlankEnv, hono_types.BlankSchema, "/">;
	/** The adapter used by the harness. Call `adapter.waitAll()` to await background tasks. */
	adapter: TestAdapter;
	/** Make a test request through the policy pipeline. */
	request: (reqPath: string, init?: RequestInit) => Response | Promise<Response>;
};
/**
 * Proxy policy — per-route header manipulation and timeout control.
 *
 * @module proxy
 */
export interface ProxyPolicyConfig extends PolicyConfig {
	/** Headers to add to the proxied request */
	headers?: Record<string, string>;
	/** Headers to strip from the proxied request */
	stripHeaders?: string[];
	/** Timeout in milliseconds. Default: 30000. */
	timeout?: number;
	/**
	 * Whether to preserve the inbound Host header when proxying to URL upstreams.
	 * Default: false (Host is rewritten to the upstream target host).
	 */
	preserveHost?: boolean;
}
/**
 * Apply additional header manipulation and timeout control to the upstream call.
 *
 * Use this when you need per-route header injection, header stripping, or
 * a custom timeout that wraps the upstream dispatch. The core proxy
 * forwarding (URL, Service Binding, Handler) is handled by the gateway's
 * upstream handler — this policy layers on top of it.
 *
 * `preserveHost` applies to URL upstreams, instructing the upstream handler
 * not to rewrite the Host header to the target host.
 *
 * Handles Cloudflare Workers' immutable `Request.headers` by cloning the
 * request when header modifications are needed.
 *
 * @param config - Headers to add/strip, timeout, and host preservation. All fields optional.
 * @returns A {@link Policy} at priority 95 (runs late, just before the upstream call).
 *
 * @example
 * ```ts
 * import { proxy } from "@homegrower-club/stoma/policies";
 *
 * // Add an internal auth header and strip cookies for the upstream
 * proxy({
 *   headers: { "x-internal-key": "secret-123" },
 *   stripHeaders: ["cookie", "x-forwarded-for"],
 *   timeout: 10_000,
 * });
 *
 * // Preserve the original Host header for virtual-host routing
 * proxy({ preserveHost: true });
 * ```
 */
export declare function proxy(config?: ProxyPolicyConfig): Policy;
export interface MockConfig extends PolicyConfig {
	/** HTTP status code to return. Default: 200. */
	status?: number;
	/** Response body. Can be a string or object (will be JSON-serialized). */
	body?: string | Record<string, unknown>;
	/** Response headers. */
	headers?: Record<string, string>;
	/** Artificial delay in milliseconds. Default: 0. */
	delayMs?: number;
	/** When `true`, suppress the production usage warning. Default: `false`. */
	allowInProduction?: boolean;
}
/**
 * Return a static mock response, bypassing the upstream entirely.
 *
 * Useful for development stubs, testing, and placeholder routes. Runs at
 * priority 999 (always last) and short-circuits — `next()` is never called,
 * so no upstream request is made. Object bodies are automatically
 * JSON-serialized with `content-type: application/json`.
 *
 * @param config - Status code, response body, headers, and artificial delay. All fields optional.
 * @returns A {@link Policy} at priority 999 (replaces the upstream).
 *
 * @example
 * ```ts
 * import { createGateway } from "@homegrower-club/stoma";
 * import { mock } from "@homegrower-club/stoma/policies";
 *
 * createGateway({
 *   routes: [{
 *     path: "/api/stub",
 *     pipeline: {
 *       policies: [
 *         // Return a JSON stub with 200ms simulated latency
 *         mock({
 *           body: { message: "Hello from stub" },
 *           delayMs: 200,
 *         }),
 *       ],
 *       upstream: { type: "handler", handler: () => new Response() }, // never reached
 *     },
 *   }],
 * });
 *
 * // Simulate a 503 maintenance page
 * mock({
 *   status: 503,
 *   body: "Service temporarily unavailable",
 *   headers: { "retry-after": "300" },
 * });
 * ```
 */
export declare const mock: (config?: MockConfig | undefined) => Policy;
/** Clear the unified JWKS cache. Exported for testing. */
export declare function clearJwksCache(): void;
export interface JwtAuthConfig extends PolicyConfig {
	/** JWT secret for HMAC verification */
	secret?: string;
	/** JWKS endpoint URL (e.g. Supabase, Auth0) */
	jwksUrl?: string;
	/** Expected JWT issuer */
	issuer?: string;
	/** Expected JWT audience */
	audience?: string;
	/** Header to read the token from. Default: "Authorization" */
	headerName?: string;
	/** Token prefix. Default: "Bearer" */
	tokenPrefix?: string;
	/** Claims to inject into request headers for upstream consumption */
	forwardClaims?: Record<string, string>;
	/** JWKS cache TTL in milliseconds. Default: 300000 (5 minutes). */
	jwksCacheTtlMs?: number;
	/** JWKS fetch timeout in milliseconds. Default: 10000 (10 seconds). */
	jwksTimeoutMs?: number;
	/** Clock skew tolerance in seconds for expiry checks. Default: 0. */
	clockSkewSeconds?: number;
	/** Require the `exp` claim to be present. Default: false. */
	requireExp?: boolean;
}
/**
 * Validate JWT tokens and optionally forward claims as upstream headers.
 *
 * Supports both HMAC (shared secret) and RSA (JWKS endpoint) verification.
 * JWKS responses are cached for 5 minutes. The `none` algorithm is always
 * rejected to prevent signature bypass attacks.
 *
 * @param config - JWT authentication settings. Requires either `secret` (HMAC) or `jwksUrl` (RSA).
 * @returns A {@link Policy} at priority 10 (runs early, before rate limiting).
 *
 * @example
 * ```ts
 * // HMAC verification with a shared secret
 * createGateway({
 *   routes: [{
 *     path: "/api/*",
 *     pipeline: {
 *       policies: [jwtAuth({ secret: env.JWT_SECRET })],
 *       upstream: { type: "url", target: "https://backend.internal" },
 *     },
 *   }],
 * });
 *
 * // JWKS verification (e.g. Supabase, Auth0) with claim forwarding
 * jwtAuth({
 *   jwksUrl: "https://your-project.supabase.co/auth/v1/.well-known/jwks.json",
 *   issuer: "https://your-project.supabase.co/auth/v1",
 *   forwardClaims: { sub: "x-user-id", email: "x-user-email" },
 * });
 * ```
 */
export declare function jwtAuth(config: JwtAuthConfig): Policy;
export interface ApiKeyAuthConfig extends PolicyConfig {
	/** Header name to read the API key from. Default: "X-API-Key" */
	headerName?: string;
	/** Query parameter name as fallback. Default: undefined (disabled) */
	queryParam?: string;
	/** Validator function — return true if the key is valid */
	validate: (key: string) => boolean | Promise<boolean>;
	/**
	 * After successful validation, derive an identity string from the key
	 * and set it as a request header for upstream consumption.
	 *
	 * @example
	 * ```ts
	 * apiKeyAuth({
	 *   validate: (key) => keys.has(key),
	 *   forwardKeyIdentity: {
	 *     headerName: "x-api-client",
	 *     identityFn: (key) => keyToClientMap.get(key) ?? "unknown",
	 *   },
	 * });
	 * ```
	 */
	forwardKeyIdentity?: {
		/** Header name to set on the request. */
		headerName: string;
		/** Derive an identity string from the validated key. Can be async. */
		identityFn: (key: string) => string | Promise<string>;
	};
}
/**
 * Validate API keys from headers or query parameters.
 *
 * Checks the `X-API-Key` header by default, with an optional query parameter
 * fallback. The `validate` function can be async to support remote key lookups.
 *
 * @param config - API key settings with a required `validate` function.
 * @returns A {@link Policy} at priority 10.
 *
 * @example
 * ```ts
 * // Static key validation
 * apiKeyAuth({
 *   validate: (key) => key === env.API_KEY,
 * });
 *
 * // Async validation with query parameter fallback
 * apiKeyAuth({
 *   headerName: "Authorization",
 *   queryParam: "api_key",
 *   validate: async (key) => {
 *     const result = await kv.get(`api-key:${key}`);
 *     return result !== null;
 *   },
 * });
 * ```
 */
export declare const apiKeyAuth: (config?: ApiKeyAuthConfig | undefined) => Policy;
export interface BasicAuthConfig extends PolicyConfig {
	/** Validate username/password. Return true if valid. */
	validate: (username: string, password: string, c: Context) => boolean | Promise<boolean>;
	/** Realm for the WWW-Authenticate header. Default: "Restricted" */
	realm?: string;
}
/**
 * Basic Authentication policy — validate base64-encoded credentials.
 *
 * Sends a `WWW-Authenticate` header on failure to prompt browser credential dialogs.
 * The realm is sanitized to prevent header injection.
 *
 * @param config - Validation function and optional realm name.
 * @returns A {@link Policy} at priority 10.
 *
 * @example
 * ```ts
 * basicAuth({
 *   realm: "Admin Area",
 *   validate: async (username, password) => {
 *     return username === "admin" && password === env.ADMIN_PASSWORD;
 *   },
 * });
 * ```
 */
export declare const basicAuth: (config?: BasicAuthConfig | undefined) => Policy;
export interface OAuth2Config extends PolicyConfig {
	/** OAuth2 token introspection endpoint (RFC 7662). */
	introspectionUrl?: string;
	/** Client ID for authenticating with the introspection endpoint. */
	clientId?: string;
	/** Client secret for authenticating with the introspection endpoint. */
	clientSecret?: string;
	/** Local validation function as alternative to introspection. Takes precedence if both provided. */
	localValidate?: (token: string) => boolean | Promise<boolean>;
	/** Where to look for the token. Default: "header". */
	tokenLocation?: "header" | "query";
	/** Header name when tokenLocation is "header". Default: "authorization". */
	headerName?: string;
	/** Prefix to strip from header value. Default: "Bearer". */
	headerPrefix?: string;
	/** Query param name when tokenLocation is "query". Default: "access_token". */
	queryParam?: string;
	/** Map introspection response fields to request headers. Only applies with introspection. */
	forwardTokenInfo?: Record<string, string>;
	/** Cache introspection results for this many seconds. Default: 0 (no cache). */
	cacheTtlSeconds?: number;
	/** Required scopes — token must have ALL of these (space-separated scope string). */
	requiredScopes?: string[];
	/** Introspection endpoint fetch timeout in milliseconds. Default: 5000. */
	introspectionTimeoutMs?: number;
}
export declare const oauth2: (config?: OAuth2Config | undefined) => Policy;
export interface RbacConfig extends PolicyConfig {
	/** Header name containing the user's role(s). Default: "x-user-role". */
	roleHeader?: string;
	/** Allowed roles — pass if user has ANY of these. */
	roles?: string[];
	/** Required permissions — pass if user has ALL of these. */
	permissions?: string[];
	/** Header containing permissions. Default: "x-user-permissions". */
	permissionHeader?: string;
	/** Delimiter for permission string. Default: ",". */
	permissionDelimiter?: string;
	/** Delimiter for role string. Default: ",". */
	roleDelimiter?: string;
	/** Custom deny message. Default: "Access denied: insufficient permissions". */
	denyMessage?: string;
}
export declare const rbac: (config?: RbacConfig | undefined) => Policy;
export interface GenerateJwtConfig extends PolicyConfig {
	/** Signing algorithm */
	algorithm: "HS256" | "HS384" | "HS512" | "RS256" | "RS384" | "RS512";
	/** HMAC secret (for HS* algorithms) */
	secret?: string;
	/** RSA private key as JWK (for RS* algorithms) */
	privateKey?: JsonWebKey;
	/** Claims to include. Static record or dynamic function. */
	claims?: Record<string, unknown> | ((c: Context) => Record<string, unknown> | Promise<Record<string, unknown>>);
	/** Token lifetime in seconds. Default: 3600 (1 hour) */
	expiresIn?: number;
	/** Issuer claim */
	issuer?: string;
	/** Audience claim */
	audience?: string;
	/** Header name for the generated token. Default: "Authorization" */
	headerName?: string;
	/** Token prefix. Default: "Bearer" */
	tokenPrefix?: string;
}
/**
 * Mint JWTs and attach them to the request for upstream consumption.
 *
 * @example
 * ```ts
 * import { generateJwt } from "@homegrower-club/stoma";
 *
 * generateJwt({
 *   algorithm: "HS256",
 *   secret: env.JWT_SIGNING_SECRET,
 *   claims: (c) => ({ sub: c.req.header("x-user-id") }),
 *   issuer: "my-gateway",
 *   expiresIn: 300,
 * });
 * ```
 */
export declare const generateJwt: (config?: GenerateJwtConfig | undefined) => Policy;
export interface JwsConfig extends PolicyConfig {
	/** HMAC secret for verification */
	secret?: string;
	/** JWKS endpoint for RSA verification */
	jwksUrl?: string;
	/** Header containing the JWS. Default: "X-JWS-Signature" */
	headerName?: string;
	/** Where the payload comes from for detached JWS. Default: "embedded" */
	payloadSource?: "embedded" | "body";
	/** Whether to forward the verified payload as a header. Default: false */
	forwardPayload?: boolean;
	/** Header name for forwarded payload. Default: "X-JWS-Payload" */
	forwardHeaderName?: string;
	/** JWKS cache TTL in ms. Default: 300000 */
	jwksCacheTtlMs?: number;
	/** JWKS fetch timeout in milliseconds. Default: 10000 (10 seconds). */
	jwksTimeoutMs?: number;
}
/**
 * Verify JWS compact serialization signatures on requests.
 *
 * The `none` algorithm is always rejected to prevent signature bypass attacks.
 * Config validation (`secret` or `jwksUrl` required) is performed at construction
 * time — a missing config throws immediately, not on first request.
 *
 * @example
 * ```ts
 * import { jws } from "@homegrower-club/stoma";
 *
 * // HMAC verification with embedded payload
 * jws({ secret: env.JWS_SECRET });
 *
 * // Detached JWS — payload comes from the request body
 * jws({ secret: env.JWS_SECRET, payloadSource: "body" });
 * ```
 */
export declare const jws: (config?: JwsConfig | undefined) => Policy;
export interface GenerateHttpSignatureConfig extends PolicyConfig {
	/** Key identifier included in signature parameters. */
	keyId: string;
	/** HMAC secret for signing. */
	secret?: string;
	/** RSA private key as JWK. */
	privateKey?: JsonWebKey;
	/** Signing algorithm identifier (e.g. "hmac-sha256", "rsa-pss-sha512", "rsa-v1_5-sha256"). */
	algorithm: string;
	/** Components to include in signature. Default: ["@method", "@path", "@authority"]. */
	components?: string[];
	/** Signature header name. Default: "Signature". */
	signatureHeaderName?: string;
	/** Signature-Input header name. Default: "Signature-Input". */
	signatureInputHeaderName?: string;
	/** Signature label. Default: "sig1". */
	label?: string;
	/** Signature expiry in seconds from creation. Optional. */
	expires?: number;
	/** Include a nonce parameter. Default: false. */
	nonce?: boolean;
}
export declare const generateHttpSignature: (config?: GenerateHttpSignatureConfig | undefined) => Policy;
export interface HttpSignatureKey {
	/** HMAC secret. */
	secret?: string;
	/** RSA public key as JWK. */
	publicKey?: JsonWebKey;
	/** Algorithm identifier. */
	algorithm: string;
}
export interface VerifyHttpSignatureConfig extends PolicyConfig {
	/** Map of keyId to key material. */
	keys: Record<string, HttpSignatureKey>;
	/** Components that MUST be in the signature. Default: ["@method"]. */
	requiredComponents?: string[];
	/** Max signature age in seconds. Default: 300 (5 min). */
	maxAge?: number;
	/** Signature header name. Default: "Signature". */
	signatureHeaderName?: string;
	/** Signature-Input header name. Default: "Signature-Input". */
	signatureInputHeaderName?: string;
	/** Expected signature label. Default: "sig1". */
	label?: string;
}
export declare const verifyHttpSignature: (config?: VerifyHttpSignatureConfig | undefined) => Policy;
export interface IpFilterConfig extends PolicyConfig {
	/** IPs or CIDR ranges to allow (allowlist mode). */
	allow?: string[];
	/** IPs or CIDR ranges to deny (denylist mode). */
	deny?: string[];
	/** Filter mode. Default: "deny". */
	mode?: "allow" | "deny";
	/** Ordered list of headers to inspect for the client IP. Default: `["cf-connecting-ip", "x-forwarded-for"]`. */
	ipHeaders?: string[];
}
/**
 * Block or allow requests based on client IP address or CIDR range.
 *
 * Supports both allowlist and denylist modes. Client IP is extracted from
 * `CF-Connecting-IP` (Cloudflare) or `X-Forwarded-For`. Accepts individual
 * IPs (`192.168.1.1`) and CIDR notation (`10.0.0.0/8`).
 *
 * @param config - IP filter rules and mode selection.
 * @returns A {@link Policy} at priority 1 (runs before everything else).
 *
 * @example
 * ```ts
 * // Allow only internal IPs
 * ipFilter({ mode: "allow", allow: ["10.0.0.0/8", "172.16.0.0/12"] });
 *
 * // Block known bad actors
 * ipFilter({ deny: ["203.0.113.0/24", "198.51.100.42"] });
 * ```
 */
export declare function ipFilter(config: IpFilterConfig): Policy;
export interface GeoIpFilterConfig extends PolicyConfig {
	/** Country codes to allow (e.g. `["US", "CA", "GB"]`). Used in "allow" mode. */
	allow?: string[];
	/** Country codes to deny. Used in "deny" mode. */
	deny?: string[];
	/** Filter mode. Default: `"deny"`. */
	mode?: "allow" | "deny";
	/** Header name to read the country code from. Default: `"cf-ipcountry"`. */
	countryHeader?: string;
}
/**
 * Block or allow requests based on geographic country code.
 *
 * Reads the country from the configured header (default `cf-ipcountry`,
 * set by Cloudflare). Supports allowlist and denylist modes. Country
 * sets are pre-computed once at construction time for efficiency.
 *
 * @param config - Country filter rules and mode selection.
 * @returns A policy at priority 1 (IP_FILTER).
 *
 * @example
 * ```ts
 * // Allow only US, Canada, and UK
 * geoIpFilter({ mode: "allow", allow: ["US", "CA", "GB"] });
 *
 * // Block specific countries
 * geoIpFilter({ deny: ["CN", "RU"] });
 * ```
 */
export declare function geoIpFilter(config?: GeoIpFilterConfig): Policy;
export interface SslEnforceConfig extends PolicyConfig {
	/** Redirect HTTP to HTTPS (301). If false, block with 403. Default: true. */
	redirect?: boolean;
	/** HSTS max-age in seconds. Default: 31536000 (1 year). */
	hstsMaxAge?: number;
	/** Add includeSubDomains to HSTS header. Default: false. */
	includeSubDomains?: boolean;
	/** Add preload to HSTS header. Default: false. */
	preload?: boolean;
}
/**
 * Enforce HTTPS and append HSTS headers on secure responses.
 *
 * Detects protocol from `x-forwarded-proto` (or request URL protocol).
 * For non-HTTPS requests, either redirects to HTTPS (301) or throws 403.
 *
 * @param config - Redirect behavior and HSTS settings.
 * @returns A {@link Policy} at priority 5 (EARLY).
 */
export declare const sslEnforce: (config?: SslEnforceConfig | undefined) => Policy;
export interface RequestLimitConfig extends PolicyConfig {
	/** Maximum allowed body size in bytes (based on Content-Length). */
	maxBytes: number;
	/** Custom error message. Default: "Request body too large". */
	message?: string;
}
/**
 * Reject requests whose declared Content-Length exceeds `maxBytes`.
 *
 * This policy checks only the `Content-Length` header. If the header is
 * absent or invalid, the request passes through. Notably, requests using
 * chunked transfer encoding (`Transfer-Encoding: chunked`) do not include
 * a `Content-Length` header and will bypass this check entirely. For strict
 * body size enforcement, combine this policy with a body-reading policy
 * that enforces limits on the actual stream length.
 *
 * @param config - Maximum byte limit and optional custom message.
 * @returns A {@link Policy} at priority 5 (EARLY).
 */
export declare const requestLimit: (config?: RequestLimitConfig | undefined) => Policy;
export interface JsonThreatProtectionConfig extends PolicyConfig {
	/** Maximum nesting depth. Default: `20`. */
	maxDepth?: number;
	/** Maximum number of keys per object. Default: `100`. */
	maxKeys?: number;
	/** Maximum string value length (also applies to object keys). Default: `10000`. */
	maxStringLength?: number;
	/** Maximum array length. Default: `100`. */
	maxArraySize?: number;
	/** Maximum raw body size in bytes. Checked BEFORE parsing. Default: `1048576` (1 MB). */
	maxBodySize?: number;
	/**
	 * Content types to inspect.
	 * Requests with other content types pass through without inspection.
	 * Default: `["application/json"]`.
	 */
	contentTypes?: string[];
}
/**
 * JSON threat protection policy.
 *
 * Enforces structural limits on JSON request bodies to prevent abuse
 * from deeply nested objects, excessively large arrays, long strings,
 * or oversized payloads. Runs at EARLY priority to reject malicious
 * payloads before they reach business logic.
 *
 * @example
 * ```ts
 * import { jsonThreatProtection } from "@homegrower-club/stoma";
 *
 * // Default limits (20 depth, 100 keys, 10K string, 100 array, 1MB body)
 * jsonThreatProtection();
 *
 * // Strict limits for a public API
 * jsonThreatProtection({
 *   maxDepth: 5,
 *   maxKeys: 20,
 *   maxStringLength: 1000,
 *   maxArraySize: 50,
 *   maxBodySize: 102400, // 100KB
 * });
 * ```
 */
export declare const jsonThreatProtection: (config?: JsonThreatProtectionConfig | undefined) => Policy;
/** A single pattern rule with target areas and optional custom message. */
export interface RegexPatternRule {
	/** Regular expression pattern string. */
	regex: string;
	/** Which parts of the request to scan. */
	targets: Array<"path" | "headers" | "body" | "query">;
	/** Custom error message when this pattern matches. */
	message?: string;
}
export interface RegexThreatProtectionConfig extends PolicyConfig {
	/** Pattern rules to evaluate against request data. */
	patterns: RegexPatternRule[];
	/** Regex flags applied to all patterns. Default: `"i"` (case-insensitive). */
	flags?: string;
	/** Only inspect body for these content types. Default: `["application/json", "text/plain"]`. */
	contentTypes?: string[];
	/** Maximum body bytes to scan. Default: `65536` (64KB). */
	maxBodyScanLength?: number;
}
/**
 * Regex threat protection policy.
 *
 * Scans request path, query string, headers, and/or body against
 * configurable regex patterns. Throws a 400 GatewayError on first match.
 *
 * @security User-provided regex patterns can cause catastrophic backtracking
 * (ReDoS) if they contain nested quantifiers or overlapping alternations
 * (e.g. `(a+)+`, `(a|a)*b`). A crafted input string can cause the regex
 * engine to run in exponential time, blocking the worker thread and
 * effectively denying service. All patterns should be reviewed for
 * super-linear time complexity before deployment. Consider using atomic
 * patterns, possessive quantifiers (where supported), or testing patterns
 * with a ReDoS detection tool.
 *
 * @example
 * ```ts
 * import { regexThreatProtection } from "@homegrower-club/stoma";
 *
 * regexThreatProtection({
 *   patterns: [
 *     { regex: "(union|select|insert|delete|drop)\\s", targets: ["path", "query", "body"], message: "SQL injection detected" },
 *     { regex: "<script[^>]*>", targets: ["body", "headers"], message: "XSS detected" },
 *   ],
 * });
 * ```
 */
export declare const regexThreatProtection: (config?: RegexThreatProtectionConfig | undefined) => Policy;
export interface TrafficShadowConfig extends PolicyConfig {
	/** URL of the shadow upstream (required). */
	target: string;
	/** Percentage of traffic to mirror, 0-100. Default: `100`. */
	percentage?: number;
	/** Only mirror these HTTP methods. Default: `["GET", "POST", "PUT", "PATCH", "DELETE"]`. */
	methods?: string[];
	/** Include request body in shadow request. Default: `true`. */
	mirrorBody?: boolean;
	/** Timeout for shadow request in ms. Default: `5000`. */
	timeout?: number;
	/** Optional error handler for shadow failures. Default: silent. */
	onError?: (error: unknown) => void;
}
/**
 * Traffic shadow policy.
 *
 * Mirrors traffic to a secondary upstream after the primary response
 * is ready. The shadow request is fire-and-forget and never affects
 * the primary response.
 *
 * @example
 * ```ts
 * import { trafficShadow } from "@homegrower-club/stoma";
 *
 * trafficShadow({
 *   target: "https://shadow.internal",
 *   percentage: 10,
 *   methods: ["POST", "PUT"],
 * });
 * ```
 */
export declare const trafficShadow: (config?: TrafficShadowConfig | undefined) => Policy;
export interface InterruptConfig extends PolicyConfig {
	/** Predicate that determines whether to short-circuit. Required. */
	condition: (c: Context) => boolean | Promise<boolean>;
	/** HTTP status code for the interrupt response. Default: 200. */
	statusCode?: number;
	/** Response body. String → text/plain, object → application/json, undefined → empty. */
	body?: unknown;
	/** Additional response headers. */
	headers?: Record<string, string>;
}
/**
 * Conditionally short-circuit the pipeline and return a static response.
 *
 * Evaluates a predicate against the incoming request context. When the
 * condition returns `true`, the pipeline is interrupted — a response is
 * returned immediately and `next()` is never called (upstream is skipped).
 * When the condition returns `false`, the pipeline continues normally.
 *
 * @param config - Condition predicate, status code, body, and headers.
 * @returns A {@link Policy} at priority 100 (default — users typically set a custom priority).
 *
 * @example
 * ```ts
 * // Maintenance mode
 * interrupt({
 *   condition: (c) => c.req.header("x-maintenance") === "true",
 *   statusCode: 503,
 *   body: { maintenance: true, message: "Back soon" },
 *   headers: { "retry-after": "300" },
 * });
 *
 * // Health check short-circuit
 * interrupt({
 *   condition: (c) => c.req.path === "/healthz",
 *   body: "ok",
 * });
 * ```
 */
export declare const interrupt: (config?: InterruptConfig | undefined) => Policy;
export interface RoutingRule {
	/** Human-readable rule name for debugging. */
	name?: string;
	/** Condition that determines if this rule applies. */
	condition: (c: Context) => boolean | Promise<boolean>;
	/** Target upstream URL to route to. */
	target: string;
	/** Optional path rewrite function. */
	rewritePath?: (path: string) => string;
	/** Optional headers to add to the upstream request. */
	headers?: Record<string, string>;
}
export interface DynamicRoutingConfig extends PolicyConfig {
	/** Ordered list of routing rules. First match wins. Required. */
	rules: Array<RoutingRule>;
	/** If true and no rule matches, call next() normally. If false, throw 404. Default: true. */
	fallthrough?: boolean;
}
/**
 * Evaluate routing rules and expose the first match on request context.
 *
 * Evaluates rules in order. The first matching rule's target, rewritePath,
 * and headers are set as context variables for downstream consumption.
 *
 * @param config - Routing rules and fallthrough behavior.
 * @returns A {@link Policy} at priority 50 (REQUEST_TRANSFORM).
 *
 * @example
 * ```ts
 * dynamicRouting({
 *   rules: [
 *     {
 *       name: "v2-api",
 *       condition: (c) => c.req.header("x-api-version") === "2",
 *       target: "https://api-v2.internal",
 *       rewritePath: (path) => path.replace("/api/", "/v2/"),
 *     },
 *     {
 *       name: "default",
 *       condition: () => true,
 *       target: "https://api-v1.internal",
 *     },
 *   ],
 * });
 * ```
 */
export declare const dynamicRouting: (config?: DynamicRoutingConfig | undefined) => Policy;
export interface HttpCalloutConfig extends PolicyConfig {
	/** Target URL — static string or dynamic function. Required. */
	url: string | ((c: Context) => string | Promise<string>);
	/** HTTP method. Default: "GET". */
	method?: string;
	/** Request headers — static values or dynamic functions. */
	headers?: Record<string, string | ((c: Context) => string | Promise<string>)>;
	/** Request body — static or dynamic. JSON-serialized if object. */
	body?: unknown | ((c: Context) => unknown | Promise<unknown>);
	/** Timeout in ms. Default: 5000. */
	timeout?: number;
	/** Callback to process the callout response. Required. */
	onResponse: (response: Response, c: Context) => void | Promise<void>;
	/** Error handler. Default: throw GatewayError 502. */
	onError?: (error: unknown, c: Context) => void | Promise<void>;
	/** If true, throw on non-2xx response. Default: true. */
	abortOnFailure?: boolean;
}
/**
 * Make an external HTTP call mid-pipeline.
 *
 * Resolves URL, headers, and body (static or dynamic), makes the fetch,
 * and calls the `onResponse` callback to process the result. Errors are
 * handled via `onError` or default to a 502 GatewayError.
 *
 * @security When the `url` parameter is a dynamic function that derives
 * the callout target from request data (headers, path, query, or body),
 * this policy is vulnerable to Server-Side Request Forgery (SSRF). An
 * attacker could manipulate request data to make the worker issue requests
 * to internal services, metadata endpoints (e.g. cloud provider instance
 * metadata), or other unintended targets. Hardcode callout URLs whenever
 * possible. If dynamic URLs are required, validate them against an
 * explicit allowlist of permitted hosts and schemes.
 *
 * @param config - Callout target, method, headers, body, and response handler.
 * @returns A {@link Policy} at priority 50 (REQUEST_TRANSFORM).
 *
 * @example
 * ```ts
 * httpCallout({
 *   url: "https://auth.example.com/validate",
 *   method: "POST",
 *   headers: { authorization: (c) => c.req.header("authorization") ?? "" },
 *   body: (c) => ({ path: c.req.path }),
 *   onResponse: async (res, c) => {
 *     const data = await res.json();
 *     c.set("userId", data.userId);
 *   },
 * });
 * ```
 */
export declare const httpCallout: (config?: HttpCalloutConfig | undefined) => Policy;
export interface ResourceFilterConfig extends PolicyConfig {
	/** Filter mode: "deny" removes listed fields, "allow" keeps only listed fields */
	mode: "allow" | "deny";
	/** Field paths to filter. Supports dot-notation (e.g. "user.password") */
	fields: string[];
	/** Content types to filter. Default: ["application/json"] */
	contentTypes?: string[];
	/** Apply filtering to array items. Default: true */
	applyToArrayItems?: boolean;
}
/**
 * Strip or allow fields from JSON responses.
 *
 * @example
 * ```ts
 * import { resourceFilter } from "@homegrower-club/stoma";
 *
 * // Remove sensitive fields
 * resourceFilter({
 *   mode: "deny",
 *   fields: ["password", "user.ssn"],
 * });
 *
 * // Keep only specific fields
 * resourceFilter({
 *   mode: "allow",
 *   fields: ["id", "name", "email"],
 * });
 * ```
 */
export declare const resourceFilter: (config?: ResourceFilterConfig | undefined) => Policy;
export interface TimeoutConfig extends PolicyConfig {
	/** Timeout in milliseconds. Default: 30000. */
	timeoutMs?: number;
	/** Error message when timeout fires. */
	message?: string;
	/** HTTP status code when timeout fires. Default: 504. */
	statusCode?: number;
}
/**
 * Enforce a time budget for downstream execution.
 *
 * Races `next()` against a timer. If the timer fires first, throws a
 * GatewayError (default 504). The timer is always cleaned up, even on
 * downstream errors.
 *
 * @param config - Timeout duration and custom error message. Defaults to 30 seconds.
 * @returns A {@link Policy} at priority 85 (runs late, close to upstream).
 *
 * @example
 * ```ts
 * // 5-second timeout with custom message
 * timeout({ timeoutMs: 5000, message: "Upstream did not respond in time" });
 * ```
 */
export declare const timeout: (config?: TimeoutConfig | undefined) => Policy;
/**
 * Retry policy — automatic retry with configurable backoff for failed upstream calls.
 *
 * Retries work by inspecting the response status after `next()` completes.
 * When a retryable status code is detected and a `_proxyRequest` exists on
 * the Hono context (set by the URL upstream handler in `gateway.ts`), the
 * policy clones the stored request and re-issues it via `fetch()` directly —
 * no `globalThis.fetch` patching, fully concurrency-safe.
 *
 * For handler-based or service-binding upstreams there is no `_proxyRequest`,
 * so the retry policy is effectively a no-op — which is the correct behavior
 * since those upstream types would require calling `next()` multiple times
 * (disallowed by Hono's compose model).
 *
 * @module retry
 */
export interface RetryConfig extends PolicyConfig {
	/** Maximum number of retries. Default: 3. */
	maxRetries?: number;
	/** Status codes that trigger a retry. Default: [502, 503, 504]. */
	retryOn?: number[];
	/** Backoff strategy. Default: "exponential". */
	backoff?: "fixed" | "exponential";
	/** Base delay in ms for backoff. Default: 200. */
	baseDelayMs?: number;
	/** Maximum delay in ms. Default: 5000. */
	maxDelayMs?: number;
	/** HTTP methods eligible for retry. Default: idempotent methods. */
	retryMethods?: string[];
	/** Response header name for the retry count. Default: `"x-retry-count"`. */
	retryCountHeader?: string;
}
/**
 * Retry failed upstream calls with configurable backoff.
 *
 * After `next()` completes, checks the response status against `retryOn`
 * codes. If a retry is warranted and a `_proxyRequest` is available on the
 * context (set by `createUrlUpstream()` in `gateway.ts`), the policy clones
 * the stored request and calls `fetch()` directly — fully concurrency-safe
 * with no `globalThis.fetch` patching.
 *
 * For handler-based or service-binding upstreams (no `_proxyRequest`), the
 * retry policy is a no-op since there is no stored request to re-issue.
 * Sets `X-Retry-Count` on the response when retries occur.
 *
 * @param config - Retry limits, backoff strategy, and retryable status codes.
 * @returns A {@link Policy} at priority 90 (runs late, wraps the upstream fetch).
 *
 * @example
 * ```ts
 * // Retry 502/503/504 up to 3 times with exponential backoff
 * retry();
 *
 * // Fixed 500ms delay, retry on 500 too
 * retry({
 *   maxRetries: 2,
 *   retryOn: [500, 502, 503, 504],
 *   backoff: "fixed",
 *   baseDelayMs: 500,
 * });
 * ```
 */
export declare function retry(config?: RetryConfig): Policy;
export interface LatencyInjectionConfig extends PolicyConfig {
	/** Base delay in milliseconds. Required. */
	delayMs: number;
	/** Jitter proportion (0 to 1). Actual delay varies by +/- jitter * delayMs. Default: 0. */
	jitter?: number;
	/** Probability of injecting latency (0 to 1). Default: 1 (always). */
	probability?: number;
}
/**
 * Inject artificial latency into the pipeline for chaos/resilience testing.
 *
 * When active, pauses execution for a configurable duration before calling
 * `next()`. Supports jitter to vary the delay and a probability setting to
 * inject latency only a fraction of the time.
 *
 * @param config - Delay duration, jitter, and injection probability.
 * @returns A {@link Policy} at priority 5 (early pipeline).
 *
 * @example
 * ```ts
 * // Fixed 100ms delay on every request
 * latencyInjection({ delayMs: 100 });
 *
 * // 200ms +/- 50% jitter, injected 30% of the time
 * latencyInjection({ delayMs: 200, jitter: 0.5, probability: 0.3 });
 * ```
 */
export declare const latencyInjection: (config?: LatencyInjectionConfig | undefined) => Policy;
export interface CorsConfig extends PolicyConfig {
	/** Allowed origins. Default: "*" */
	origins?: string | string[] | ((origin: string) => boolean);
	/** Allowed HTTP methods. Default: all. */
	methods?: string[];
	/** Headers the client is allowed to send. */
	allowHeaders?: string[];
	/** Headers exposed to the client. */
	exposeHeaders?: string[];
	/** Max age for preflight cache in seconds. Default: 86400. */
	maxAge?: number;
	/** Allow credentials. Default: false. */
	credentials?: boolean;
}
/**
 * Add Cross-Origin Resource Sharing headers to gateway responses.
 *
 * Wraps Hono's built-in CORS middleware as a composable policy. Handles both
 * simple and preflight (OPTIONS) requests. Runs at priority 5 so CORS headers
 * are applied before auth or other policies reject the request.
 *
 * @param config - Origin rules, allowed methods/headers, and credentials. All fields optional.
 * @returns A {@link Policy} at priority 5 (runs very early).
 *
 * @example
 * ```ts
 * import { createGateway } from "@homegrower-club/stoma";
 * import { cors } from "@homegrower-club/stoma/policies";
 *
 * // Allow any origin (default)
 * createGateway({
 *   policies: [cors()],
 *   routes: [{ path: "/api/*", pipeline: { upstream: { type: "url", target: "https://api.example.com" } } }],
 * });
 *
 * // Restrict to specific origins with credentials
 * cors({
 *   origins: ["https://app.example.com", "https://staging.example.com"],
 *   methods: ["GET", "POST", "PUT", "DELETE"],
 *   credentials: true,
 *   maxAge: 3600,
 * });
 *
 * // Dynamic origin validation
 * cors({
 *   origins: (origin) => origin.endsWith(".example.com"),
 * });
 * ```
 */
export declare function cors(config?: CorsConfig): Policy;
export interface OverrideMethodConfig extends PolicyConfig {
	/** Header name to read the override method from. Default: `"X-HTTP-Method-Override"`. */
	header?: string;
	/** Methods allowed as overrides. Default: `["GET", "PUT", "PATCH", "DELETE"]`. */
	allowedMethods?: string[];
}
/**
 * Override the HTTP method of a POST request via a header.
 *
 * Only applies to POST requests — the industry-standard approach for
 * tunneling other methods through POST. Non-POST requests with the
 * override header are ignored.
 *
 * @param config - Header name and allowed override methods.
 * @returns A policy at priority 5 (EARLY).
 *
 * @example
 * ```ts
 * // Default: reads X-HTTP-Method-Override header
 * overrideMethod();
 *
 * // Custom header and restricted methods
 * overrideMethod({ header: "X-Method", allowedMethods: ["PUT", "PATCH"] });
 * ```
 */
export declare const overrideMethod: (config?: OverrideMethodConfig | undefined) => Policy;
export interface AssignAttributesConfig extends PolicyConfig {
	/**
	 * Key-value pairs to set on the Hono context.
	 * Values can be static strings or functions that receive the context.
	 */
	attributes: Record<string, string | ((c: Context) => string | Promise<string>)>;
}
/**
 * Set key-value attributes on the Hono request context.
 *
 * @param config - Must include `attributes` — a record of keys to values or resolver functions.
 * @returns A {@link Policy} at priority 50 (REQUEST_TRANSFORM).
 *
 * @example
 * ```ts
 * import { assignAttributes } from "@homegrower-club/stoma";
 *
 * assignAttributes({
 *   attributes: {
 *     "x-tenant": "acme",
 *     "x-request-path": (c) => new URL(c.req.url).pathname,
 *   },
 * });
 * ```
 */
export declare const assignAttributes: (config?: AssignAttributesConfig | undefined) => Policy;
/** A field value — either a static value or a function resolving to one. */
export type FieldValue = unknown | ((c: Context) => unknown | Promise<unknown>);
export interface AssignContentConfig extends PolicyConfig {
	/** Fields to set/override in the JSON request body. */
	request?: Record<string, FieldValue>;
	/** Fields to set/override in the JSON response body. */
	response?: Record<string, FieldValue>;
	/** Only modify bodies with these content types. Default: `["application/json"]`. */
	contentTypes?: string[];
}
/**
 * Assign content policy.
 *
 * Injects or overrides fields in JSON request and/or response bodies.
 * Useful for injecting tenant IDs, timestamps, metadata, or other
 * fields that should be transparently added by the gateway.
 *
 * @example
 * ```ts
 * import { assignContent } from "@homegrower-club/stoma";
 *
 * assignContent({
 *   request: {
 *     tenantId: "acme",
 *     timestamp: (c) => new Date().toISOString(),
 *   },
 *   response: {
 *     gateway: "stoma",
 *   },
 * });
 * ```
 */
export declare const assignContent: (config?: AssignContentConfig | undefined) => Policy;
export interface RequestTransformConfig extends PolicyConfig {
	/** Headers to add or overwrite on the outgoing request. */
	setHeaders?: Record<string, string>;
	/** Header names to remove from the outgoing request. */
	removeHeaders?: string[];
	/** Rename headers: keys are old names, values are new names. */
	renameHeaders?: Record<string, string>;
}
export interface ResponseTransformConfig extends PolicyConfig {
	/** Headers to add or overwrite on the response. */
	setHeaders?: Record<string, string>;
	/** Header names to remove from the response. */
	removeHeaders?: string[];
	/** Rename headers: keys are old names, values are new names. */
	renameHeaders?: Record<string, string>;
}
/**
 * Modify request headers before they reach the upstream service.
 *
 * Applies header transformations in order: rename → set → remove. Handles
 * Cloudflare Workers' immutable `Request.headers` by cloning the request
 * with modified headers.
 *
 * @param config - Header set/remove/rename operations. At least one should be provided.
 * @returns A {@link Policy} at priority 50 (mid-pipeline, after auth, before upstream).
 *
 * @example
 * ```ts
 * import { requestTransform } from "@homegrower-club/stoma/policies";
 *
 * // Add API version header and strip cookies
 * requestTransform({
 *   setHeaders: { "x-api-version": "2024-01-01" },
 *   removeHeaders: ["cookie"],
 * });
 *
 * // Rename a legacy header to the new convention
 * requestTransform({
 *   renameHeaders: { "x-old-auth": "authorization" },
 * });
 * ```
 */
export declare const requestTransform: (config?: RequestTransformConfig | undefined) => Policy;
/**
 * Modify response headers after the upstream service returns.
 *
 * Applies header transformations in order: rename → set → remove. Runs at
 * priority 92 (late in the pipeline) so it can modify headers set by the
 * upstream or earlier policies.
 *
 * @param config - Header set/remove/rename operations. At least one should be provided.
 * @returns A {@link Policy} at priority 92 (runs late, after upstream responds).
 *
 * @example
 * ```ts
 * import { responseTransform } from "@homegrower-club/stoma/policies";
 *
 * // Add security headers and strip server info
 * responseTransform({
 *   setHeaders: {
 *     "strict-transport-security": "max-age=31536000; includeSubDomains",
 *     "x-content-type-options": "nosniff",
 *   },
 *   removeHeaders: ["server", "x-powered-by"],
 * });
 * ```
 */
export declare const responseTransform: (config?: ResponseTransformConfig | undefined) => Policy;
/** Result shape returned by validation functions that provide error details. */
export interface ValidationResult {
	valid: boolean;
	errors?: string[];
}
export interface RequestValidationConfig extends PolicyConfig {
	/**
	 * Synchronous validation function.
	 * Return `true`/`false` or an object with optional error details.
	 */
	validate?: (body: unknown) => boolean | ValidationResult;
	/**
	 * Async validation function (e.g., for remote schema validation).
	 * If both `validate` and `validateAsync` are provided, `validateAsync` takes precedence.
	 */
	validateAsync?: (body: unknown) => Promise<boolean | ValidationResult>;
	/**
	 * Only validate these content types.
	 * Requests with other content types pass through without validation.
	 * Default: `["application/json"]`.
	 */
	contentTypes?: string[];
	/** Custom error message prefix. Default: `"Request validation failed"`. */
	errorMessage?: string;
}
/**
 * Pluggable request body validation policy.
 *
 * Validates the request body using a user-provided sync or async function.
 * Requests with content types not in the configured list pass through
 * without validation.
 *
 * @example
 * ```ts
 * import { requestValidation } from "@homegrower-club/stoma";
 *
 * // Simple boolean validator
 * requestValidation({
 *   validate: (body) => body != null && typeof body === "object",
 * });
 *
 * // Detailed validation with error messages
 * requestValidation({
 *   validate: (body) => {
 *     const errors: string[] = [];
 *     if (!body || typeof body !== "object") errors.push("Body must be an object");
 *     return { valid: errors.length === 0, errors };
 *   },
 * });
 * ```
 */
export declare const requestValidation: (config?: RequestValidationConfig | undefined) => Policy;
/** Result shape returned by the user-provided validation function. */
export interface JsonValidationResult {
	valid: boolean;
	errors?: string[];
}
export interface JsonValidationConfig extends PolicyConfig {
	/** Custom validation function. Takes parsed body, returns validation result. */
	validate?: (body: unknown) => JsonValidationResult | Promise<JsonValidationResult>;
	/** Content types to validate. Default: ["application/json"] */
	contentTypes?: string[];
	/** HTTP status code on validation failure. Default: 422 */
	rejectStatus?: number;
	/** Include validation errors in response. Default: true */
	errorDetail?: boolean;
}
/**
 * Pluggable JSON body validation policy.
 *
 * Validates the request body using a user-provided function. When no
 * `validate` function is configured, checks that the body is parseable JSON.
 * Requests with content types not in the configured list pass through
 * without validation.
 *
 * @example
 * ```ts
 * import { jsonValidation } from "@homegrower-club/stoma";
 *
 * // With Zod
 * jsonValidation({
 *   validate: (body) => {
 *     const result = myZodSchema.safeParse(body);
 *     return {
 *       valid: result.success,
 *       errors: result.success ? undefined : result.error.issues.map(i => i.message),
 *     };
 *   },
 * });
 *
 * // Just validate JSON is parseable (no validate function)
 * jsonValidation();
 * ```
 */
export declare const jsonValidation: (config?: JsonValidationConfig | undefined) => Policy;
export interface RequestLogConfig extends PolicyConfig {
	/** Additional fields to extract from the request */
	extractFields?: (c: unknown) => Record<string, unknown>;
	/** Custom log sink — defaults to console.log with structured JSON */
	sink?: (entry: LogEntry) => void | Promise<void>;
	/** Ordered list of headers to inspect for the client IP. Default: `["cf-connecting-ip", "x-forwarded-for"]`. */
	ipHeaders?: string[];
	/** Log request body (opt-in). Default: `false`. */
	logRequestBody?: boolean;
	/** Log response body (opt-in). Default: `false`. */
	logResponseBody?: boolean;
	/** Maximum body size in bytes to capture. Default: `8192`. */
	maxBodyLength?: number;
	/** JSON field paths to redact from logged bodies (e.g., `["password", "*.secret"]`). */
	redactPaths?: string[];
}
/** Structured log entry emitted for each request/response pair. */
export interface LogEntry {
	/** ISO 8601 timestamp when the log was emitted. */
	timestamp: string;
	/** Unique request ID for distributed tracing. */
	requestId: string;
	/** HTTP method (e.g. `"GET"`, `"POST"`). */
	method: string;
	/** URL pathname (without query string). */
	path: string;
	/** HTTP response status code. */
	statusCode: number;
	/** End-to-end request duration in milliseconds. */
	durationMs: number;
	/** Client IP from `CF-Connecting-IP` or `X-Forwarded-For`. */
	clientIp: string;
	/** Client User-Agent header value. */
	userAgent: string;
	/** Gateway name from config. */
	gatewayName: string;
	/** Matched route path pattern. */
	routePath: string;
	/** Upstream identifier (reserved for future enrichment). */
	upstream: string;
	/** W3C Trace Context — 32-hex trace ID. */
	traceId?: string;
	/** W3C Trace Context — 16-hex span ID for this gateway request. */
	spanId?: string;
	/** Captured request body (when `logRequestBody` is enabled). */
	requestBody?: unknown;
	/** Captured response body (when `logResponseBody` is enabled). */
	responseBody?: unknown;
	/** Custom fields from `extractFields` callback. */
	extra?: Record<string, unknown>;
}
/**
 * Emit structured JSON logs for every request/response pair.
 *
 * Captures method, path, status, duration, client IP, user agent, and
 * gateway context (request ID, gateway name, route path). Runs at priority 0
 * so it wraps the entire pipeline and measures end-to-end latency.
 *
 * By default, logs are written to `console.log` as JSON lines. Provide a
 * custom `sink` to route logs to an external service (e.g., Logflare,
 * Datadog, or a Durable Object buffer).
 *
 * @param config - Custom field extraction, body logging, and sink. All fields optional.
 * @returns A {@link Policy} at priority 0 (runs first, wraps everything).
 *
 * @example
 * ```ts
 * import { createGateway } from "@homegrower-club/stoma";
 * import { requestLog } from "@homegrower-club/stoma/policies";
 *
 * // Default structured JSON logging to console
 * createGateway({
 *   policies: [requestLog()],
 *   routes: [...],
 * });
 *
 * // With body logging and redaction
 * requestLog({
 *   logRequestBody: true,
 *   logResponseBody: true,
 *   redactPaths: ["password", "*.secret", "auth.token"],
 *   sink: async (entry) => {
 *     await fetch("https://logs.example.com/ingest", {
 *       method: "POST",
 *       body: JSON.stringify(entry),
 *     });
 *   },
 * });
 * ```
 */
export declare const requestLog: (config?: RequestLogConfig | undefined) => Policy;
export interface MetricsReporterConfig extends PolicyConfig {
	/** The metrics collector to record to. */
	collector: MetricsCollector;
}
/**
 * Record standard gateway metrics for every request.
 *
 * Metrics recorded:
 * - `gateway_requests_total` (counter) — total requests, tagged by method/path/status/gateway
 * - `gateway_request_duration_ms` (histogram) — end-to-end request duration
 * - `gateway_request_errors_total` (counter) — requests with status >= 400
 * - `gateway_policy_duration_ms` (histogram) — per-policy timing when available
 *
 * @param config - Must include a {@link MetricsCollector} instance.
 * @returns A {@link Policy} at priority 1.
 */
export declare const metricsReporter: (config?: MetricsReporterConfig | undefined) => Policy;
export interface AssignMetricsConfig extends PolicyConfig {
	/**
	 * Metric tags to attach to the request.
	 * Values can be static strings or functions that receive the context.
	 */
	tags: Record<string, string | ((c: Context) => string | Promise<string>)>;
}
/**
 * Attach metric tags to the request context for downstream consumers.
 *
 * Tags are resolved (static or dynamic) and stored as a plain object at
 * `c.get("_metricsTags")`. The {@link metricsReporter} policy (or any custom
 * observer) can read these tags to enrich collected metrics.
 *
 * @param config - Must include `tags` — a record of tag names to values or resolver functions.
 * @returns A {@link Policy} at priority 0 (OBSERVABILITY).
 *
 * @example
 * ```ts
 * import { assignMetrics } from "@homegrower-club/stoma";
 *
 * assignMetrics({
 *   tags: {
 *     service: "users-api",
 *     region: (c) => c.req.header("cf-ipcountry") ?? "unknown",
 *   },
 * });
 * ```
 */
export declare const assignMetrics: (config?: AssignMetricsConfig | undefined) => Policy;
/** Visibility mode controlling when timing headers are emitted. */
export type ServerTimingVisibility = "always" | "debug-only" | "conditional";
export interface ServerTimingConfig extends PolicyConfig {
	/** Emit the `Server-Timing` header with per-policy breakdown. Default: `true`. */
	serverTimingHeader?: boolean;
	/** Emit the `X-Response-Time` header with total gateway time. Default: `true`. */
	responseTimeHeader?: boolean;
	/** Number of decimal places for duration values. Default: `1`. */
	precision?: number;
	/** Add a `total` entry to `Server-Timing`. Default: `true`. */
	includeTotal?: boolean;
	/** Optional function to generate a description for each timing entry. */
	descriptionFn?: (name: string) => string;
	/** Controls when timing headers are emitted. Default: `"debug-only"`. */
	visibility?: ServerTimingVisibility;
	/** Required when `visibility` is `"conditional"`. Called per-request to decide. */
	visibilityFn?: (c: Context) => boolean | Promise<boolean>;
}
/**
 * Emit W3C `Server-Timing` and `X-Response-Time` response headers.
 *
 * Reads per-policy timing data from the pipeline instrumentation and
 * formats it as standard headers visible in browser DevTools.
 *
 * @param config - Optional configuration for headers, precision, and visibility.
 * @returns A {@link Policy} at priority 1 (METRICS).
 */
export declare const serverTiming: (config?: ServerTimingConfig | undefined) => Policy;
/**
 * Health check route factory with optional upstream probing.
 *
 * @module health
 */
export interface HealthConfig {
	/** Health endpoint path. Default: "/health". */
	path?: string;
	/** URLs to probe for upstream health. */
	upstreamProbes?: string[];
	/** Include individual upstream statuses in response. Default: false. */
	includeUpstreamStatus?: boolean;
	/** Timeout in ms for each upstream probe. Default: 5000. */
	probeTimeoutMs?: number;
	/** HTTP method for upstream probes. Default: `"HEAD"`. */
	probeMethod?: string;
	/** Status code returned when all probes are unhealthy. Default: 503. */
	unhealthyStatusCode?: number;
}
/**
 * Create a health check route for liveness and upstream probing.
 *
 * Returns a {@link RouteConfig} (not a Policy) — add it directly to the
 * gateway's `routes` array. Without upstream probes, returns a simple
 * `{ status: "healthy" }` response. With probes, performs concurrent HEAD
 * requests (5s timeout each) and reports aggregate status:
 * - `"healthy"` — all probes passed
 * - `"degraded"` — some probes failed
 * - `"unhealthy"` — all probes failed (returns 503)
 *
 * @security Enabling `includeUpstreamStatus: true` causes the response to
 * include the URLs and availability status of internal upstream services.
 * On public-facing endpoints this leaks internal service topology, which
 * can aid attackers in reconnaissance (identifying internal hostnames,
 * ports, and service availability patterns). Restrict health routes that
 * expose upstream status to internal or admin-only paths, or protect them
 * with an authentication policy.
 *
 * @param config - Endpoint path, upstream probe URLs, and status detail toggle. All fields optional.
 * @returns A {@link RouteConfig} for a GET health endpoint.
 *
 * @example
 * ```ts
 * import { createGateway } from "@homegrower-club/stoma";
 * import { health } from "@homegrower-club/stoma/policies";
 *
 * createGateway({
 *   routes: [
 *     // Simple liveness check at /health
 *     health(),
 *
 *     // Probe upstreams with detailed status at /healthz
 *     health({
 *       path: "/healthz",
 *       upstreamProbes: [
 *         "https://api.example.com/health",
 *         "https://auth.example.com/health",
 *       ],
 *       includeUpstreamStatus: true,
 *     }),
 *
 *     // ...other routes
 *   ],
 * });
 * ```
 */
export declare function health(config?: HealthConfig): RouteConfig;
/**
 * Create a gateway instance from a declarative configuration.
 *
 * Registers all routes on a Hono app, builds per-route policy pipelines
 * (merging global + route-level policies), and wires up upstream dispatch.
 * Returns a {@link GatewayInstance} whose `.app` property is the Hono app
 * ready to be exported as a Cloudflare Worker default export.
 *
 * @param config - Full gateway configuration including routes, policies, and options.
 * @returns A {@link GatewayInstance} with the configured Hono app.
 * @throws {GatewayError} If no routes are provided.
 *
 * @example
 * ```ts
 * import { createGateway, jwtAuth, rateLimit } from "@homegrower-club/stoma";
 *
 * const gateway = createGateway({
 *   name: "my-api",
 *   basePath: "/api",
 *   routes: [
 *     {
 *       path: "/users/*",
 *       pipeline: {
 *         policies: [jwtAuth({ secret: env.JWT_SECRET }), rateLimit({ max: 100 })],
 *         upstream: { type: "url", target: "https://users-service.internal" },
 *       },
 *     },
 *   ],
 * });
 *
 * export default gateway.app;
 * ```
 */
export declare function createGateway(config: GatewayConfig): GatewayInstance;
/**
 * Error handling utilities for the stoma gateway.
 *
 * {@link GatewayError} is thrown by policies and core code to produce
 * structured JSON error responses. The gateway's `onError` handler catches
 * these and converts them via {@link errorToResponse}. Unexpected errors
 * fall through to {@link defaultErrorResponse}.
 *
 * @module errors
 */
/**
 * Structured gateway error with HTTP status code, machine-readable code,
 * and optional response headers (e.g. `Retry-After`, `X-RateLimit-*`).
 *
 * Throw this from policies or handlers to produce a structured JSON error
 * response. The gateway error handler catches it automatically.
 *
 * @example
 * ```ts
 * throw new GatewayError(429, "rate_limited", "Too many requests", {
 *   "retry-after": "60",
 * });
 * // Produces: { "error": "rate_limited", "message": "Too many requests", "statusCode": 429 }
 * ```
 */
export declare class GatewayError extends Error {
	readonly statusCode: number;
	readonly code: string;
	/** Optional headers to include in the error response (e.g. rate-limit headers) */
	readonly headers?: Record<string, string>;
	constructor(statusCode: number, code: string, message: string, headers?: Record<string, string>);
}
/** Standard JSON error response shape returned by all gateway errors. */
export interface ErrorResponse {
	/** Machine-readable error code (e.g. `"rate_limited"`, `"unauthorized"`). */
	error: string;
	/** Human-readable error description. */
	message: string;
	/** HTTP status code (e.g. 401, 429, 503). */
	statusCode: number;
	/** Request ID for tracing, when available. */
	requestId?: string;
}
/**
 * Policy pipeline — merges, sorts, and wraps policies as Hono middleware.
 *
 * The pipeline is the core execution model: global policies are merged with
 * route-level policies (route wins on name collision), sorted by priority
 * (ascending), and converted to Hono middleware handlers. A context injector
 * runs first on every request to set the request ID, timing, and debug factory.
 *
 * @module pipeline
 */
/**
 * Retrieve the {@link PolicyContext} from a Hono context.
 *
 * Returns `undefined` if called outside the gateway pipeline (e.g. in
 * a standalone Hono app without context injection).
 *
 * @param c - The Hono request context.
 * @returns The gateway context, or `undefined` if not in a gateway pipeline.
 */
export declare function getGatewayContext(c: Context): PolicyContext | undefined;
/**
 * Shared client IP extraction utility.
 *
 * Centralises the IP header lookup logic used by rate limiting, IP filtering,
 * and request logging. The header priority order is configurable — the first
 * header that contains a value wins.
 *
 * @module ip
 */
/** Default ordered list of headers to inspect for the client IP. */
export declare const DEFAULT_IP_HEADERS: string[];
/**
 * Extract the client IP address from request headers.
 *
 * Iterates through `ipHeaders` in order. For comma-separated headers like
 * `X-Forwarded-For`, only the first (leftmost) value is returned.
 *
 * @security The `X-Forwarded-For` header is trivially spoofable by clients
 * outside of trusted proxy infrastructure. An attacker can set arbitrary IP
 * values to bypass IP-based allowlists, rate limits, or geo-restrictions.
 * When deploying behind a load balancer or CDN, configure `ipHeaders` to
 * match your proxy's trusted header (e.g. `cf-connecting-ip` for Cloudflare,
 * `x-real-ip` for nginx) and ensure the proxy strips or overwrites any
 * client-supplied forwarding headers.
 *
 * @param headers - An object with a `.get(name)` method (e.g. `Headers`, Hono `c.req`).
 * @param ipHeaders - Ordered list of headers to inspect. Default: {@link DEFAULT_IP_HEADERS}.
 * @returns The extracted IP address, or `"unknown"` if none found.
 */
export declare function extractClientIp(headers: {
	get(name: string): string | null | undefined;
}, ipHeaders?: readonly string[]): string;
/**
 * Constant-time string comparison to prevent timing side-channel attacks.
 *
 * Use this when comparing secrets (API keys, tokens, HMAC digests) to
 * prevent an attacker from inferring the correct value by measuring
 * response time differences.
 *
 * @module timing-safe
 */
/**
 * Compare two strings in constant time.
 *
 * Returns `true` if `a` and `b` are identical, `false` otherwise.
 * The comparison always examines every byte of the longer string,
 * preventing timing side-channels that leak prefix information.
 *
 * @param a - First string to compare.
 * @param b - Second string to compare.
 * @returns `true` if the strings are identical.
 *
 * @example
 * ```ts
 * import { timingSafeEqual } from "@homegrower-club/stoma";
 *
 * // Use in API key validators to prevent timing attacks
 * const isValid = timingSafeEqual(providedKey, storedKey);
 * ```
 */
export declare function timingSafeEqual(a: string, b: string): boolean;
/** Response cache backed by the Cloudflare Cache API. */
export declare class CacheApiCacheStore implements CacheStore {
	private cache;
	private origin;
	/**
	 * @param cache - A `Cache` instance (e.g. `caches.default`). Falls back to `caches.default` when omitted.
	 * @param origin - Synthetic origin used to construct cache keys. Default: `"https://edge-gateway.internal"`.
	 */
	constructor(cache?: Cache, origin?: string);
	get(key: string): Promise<Response | null>;
	put(key: string, response: Response, ttlSeconds: number): Promise<void>;
	delete(key: string): Promise<boolean>;
}
/** Create a GatewayAdapter using in-memory stores. Suitable for dev/demo/testing. */
export declare function memoryAdapter(): GatewayAdapter;
/**
 * Rate limit store backed by IndexedDB.
 *
 * Each key maps to a `{ count, resetAt }` entry. When the window expires
 * (resetAt < now), a new window is started automatically.
 */
export declare class IDBRateLimitStore implements RateLimitStore {
	private db;
	increment(key: string, windowSeconds: number): Promise<{
		count: number;
		resetAt: number;
	}>;
	/** Close the database connection. */
	destroy(): void;
}

declare namespace sdk {
	export { PolicyDefinition, PolicyHandlerContext, PolicyTestHarnessOptions, PolicyTrace, PolicyTraceDetail, PolicyTraceEntry, Priority, PriorityLevel, TraceReporter, createPolicyTestHarness, definePolicy, getCollectedDebugHeaders, isDebugRequested, isTraceRequested, noopTraceReporter, parseDebugRequest, policyDebug, policyTrace, resolveConfig, safeCall, setDebugHeader, withSkip };
}

export {
	sdk,
};

export {};
