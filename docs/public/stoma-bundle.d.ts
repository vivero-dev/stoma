// Generated by dts-bundle-generator v9.5.1

declare const GET_MATCH_RESULT: unique symbol;
/**
 * Interface representing a router.
 *
 * @template T - The type of the handler.
 */
export interface Router<T> {
	/**
	 * The name of the router.
	 */
	name: string;
	/**
	 * Adds a route to the router.
	 *
	 * @param method - The HTTP method (e.g., 'get', 'post').
	 * @param path - The path for the route.
	 * @param handler - The handler for the route.
	 */
	add(method: string, path: string, handler: T): void;
	/**
	 * Matches a route based on the given method and path.
	 *
	 * @param method - The HTTP method (e.g., 'get', 'post').
	 * @param path - The path to match.
	 * @returns The result of the match.
	 */
	match(method: string, path: string): Result<T>;
}
/**
 * Type representing a map of parameter indices.
 */
export type ParamIndexMap = Record<string, number>;
/**
 * Type representing a stash of parameters.
 */
export type ParamStash = string[];
type Params$1 = Record<string, string>;
/**
 * Type representing the result of a route match.
 *
 * The result can be in one of two formats:
 * 1. An array of handlers with their corresponding parameter index maps, followed by a parameter stash.
 * 2. An array of handlers with their corresponding parameter maps.
 *
 * Example:
 *
 * [[handler, paramIndexMap][], paramArray]
 * ```typescript
 * [
 *   [
 *     [middlewareA, {}],                     // '*'
 *     [funcA,       {'id': 0}],              // '/user/:id/*'
 *     [funcB,       {'id': 0, 'action': 1}], // '/user/:id/:action'
 *   ],
 *   ['123', 'abc']
 * ]
 * ```
 *
 * [[handler, params][]]
 * ```typescript
 * [
 *   [
 *     [middlewareA, {}],                             // '*'
 *     [funcA,       {'id': '123'}],                  // '/user/:id/*'
 *     [funcB,       {'id': '123', 'action': 'abc'}], // '/user/:id/:action'
 *   ]
 * ]
 * ```
 */
export type Result<T> = [
	[
		T,
		ParamIndexMap
	][],
	ParamStash
] | [
	[
		T,
		Params$1
	][]
];
/**
 * @module
 * HTTP Headers utility.
 */
export type RequestHeader = "A-IM" | "Accept" | "Accept-Additions" | "Accept-CH" | "Accept-Charset" | "Accept-Datetime" | "Accept-Encoding" | "Accept-Features" | "Accept-Language" | "Accept-Patch" | "Accept-Post" | "Accept-Ranges" | "Accept-Signature" | "Access-Control" | "Access-Control-Allow-Credentials" | "Access-Control-Allow-Headers" | "Access-Control-Allow-Methods" | "Access-Control-Allow-Origin" | "Access-Control-Expose-Headers" | "Access-Control-Max-Age" | "Access-Control-Request-Headers" | "Access-Control-Request-Method" | "Age" | "Allow" | "ALPN" | "Alt-Svc" | "Alt-Used" | "Alternates" | "AMP-Cache-Transform" | "Apply-To-Redirect-Ref" | "Authentication-Control" | "Authentication-Info" | "Authorization" | "Available-Dictionary" | "C-Ext" | "C-Man" | "C-Opt" | "C-PEP" | "C-PEP-Info" | "Cache-Control" | "Cache-Status" | "Cal-Managed-ID" | "CalDAV-Timezones" | "Capsule-Protocol" | "CDN-Cache-Control" | "CDN-Loop" | "Cert-Not-After" | "Cert-Not-Before" | "Clear-Site-Data" | "Client-Cert" | "Client-Cert-Chain" | "Close" | "CMCD-Object" | "CMCD-Request" | "CMCD-Session" | "CMCD-Status" | "CMSD-Dynamic" | "CMSD-Static" | "Concealed-Auth-Export" | "Configuration-Context" | "Connection" | "Content-Base" | "Content-Digest" | "Content-Disposition" | "Content-Encoding" | "Content-ID" | "Content-Language" | "Content-Length" | "Content-Location" | "Content-MD5" | "Content-Range" | "Content-Script-Type" | "Content-Security-Policy" | "Content-Security-Policy-Report-Only" | "Content-Style-Type" | "Content-Type" | "Content-Version" | "Cookie" | "Cookie2" | "Cross-Origin-Embedder-Policy" | "Cross-Origin-Embedder-Policy-Report-Only" | "Cross-Origin-Opener-Policy" | "Cross-Origin-Opener-Policy-Report-Only" | "Cross-Origin-Resource-Policy" | "CTA-Common-Access-Token" | "DASL" | "Date" | "DAV" | "Default-Style" | "Delta-Base" | "Deprecation" | "Depth" | "Derived-From" | "Destination" | "Differential-ID" | "Dictionary-ID" | "Digest" | "DPoP" | "DPoP-Nonce" | "Early-Data" | "EDIINT-Features" | "ETag" | "Expect" | "Expect-CT" | "Expires" | "Ext" | "Forwarded" | "From" | "GetProfile" | "Hobareg" | "Host" | "HTTP2-Settings" | "If" | "If-Match" | "If-Modified-Since" | "If-None-Match" | "If-Range" | "If-Schedule-Tag-Match" | "If-Unmodified-Since" | "IM" | "Include-Referred-Token-Binding-ID" | "Isolation" | "Keep-Alive" | "Label" | "Last-Event-ID" | "Last-Modified" | "Link" | "Link-Template" | "Location" | "Lock-Token" | "Man" | "Max-Forwards" | "Memento-Datetime" | "Meter" | "Method-Check" | "Method-Check-Expires" | "MIME-Version" | "Negotiate" | "NEL" | "OData-EntityId" | "OData-Isolation" | "OData-MaxVersion" | "OData-Version" | "Opt" | "Optional-WWW-Authenticate" | "Ordering-Type" | "Origin" | "Origin-Agent-Cluster" | "OSCORE" | "OSLC-Core-Version" | "Overwrite" | "P3P" | "PEP" | "PEP-Info" | "Permissions-Policy" | "PICS-Label" | "Ping-From" | "Ping-To" | "Position" | "Pragma" | "Prefer" | "Preference-Applied" | "Priority" | "ProfileObject" | "Protocol" | "Protocol-Info" | "Protocol-Query" | "Protocol-Request" | "Proxy-Authenticate" | "Proxy-Authentication-Info" | "Proxy-Authorization" | "Proxy-Features" | "Proxy-Instruction" | "Proxy-Status" | "Public" | "Public-Key-Pins" | "Public-Key-Pins-Report-Only" | "Range" | "Redirect-Ref" | "Referer" | "Referer-Root" | "Referrer-Policy" | "Refresh" | "Repeatability-Client-ID" | "Repeatability-First-Sent" | "Repeatability-Request-ID" | "Repeatability-Result" | "Replay-Nonce" | "Reporting-Endpoints" | "Repr-Digest" | "Retry-After" | "Safe" | "Schedule-Reply" | "Schedule-Tag" | "Sec-GPC" | "Sec-Purpose" | "Sec-Token-Binding" | "Sec-WebSocket-Accept" | "Sec-WebSocket-Extensions" | "Sec-WebSocket-Key" | "Sec-WebSocket-Protocol" | "Sec-WebSocket-Version" | "Security-Scheme" | "Server" | "Server-Timing" | "Set-Cookie" | "Set-Cookie2" | "SetProfile" | "Signature" | "Signature-Input" | "SLUG" | "SoapAction" | "Status-URI" | "Strict-Transport-Security" | "Sunset" | "Surrogate-Capability" | "Surrogate-Control" | "TCN" | "TE" | "Timeout" | "Timing-Allow-Origin" | "Topic" | "Traceparent" | "Tracestate" | "Trailer" | "Transfer-Encoding" | "TTL" | "Upgrade" | "Urgency" | "URI" | "Use-As-Dictionary" | "User-Agent" | "Variant-Vary" | "Vary" | "Via" | "Want-Content-Digest" | "Want-Digest" | "Want-Repr-Digest" | "Warning" | "WWW-Authenticate" | "X-Content-Type-Options" | "X-Frame-Options";
export type ResponseHeader = "Access-Control-Allow-Credentials" | "Access-Control-Allow-Headers" | "Access-Control-Allow-Methods" | "Access-Control-Allow-Origin" | "Access-Control-Expose-Headers" | "Access-Control-Max-Age" | "Age" | "Allow" | "Cache-Control" | "Clear-Site-Data" | "Content-Disposition" | "Content-Encoding" | "Content-Language" | "Content-Length" | "Content-Location" | "Content-Range" | "Content-Security-Policy" | "Content-Security-Policy-Report-Only" | "Content-Type" | "Cookie" | "Cross-Origin-Embedder-Policy" | "Cross-Origin-Opener-Policy" | "Cross-Origin-Resource-Policy" | "Date" | "ETag" | "Expires" | "Last-Modified" | "Location" | "Permissions-Policy" | "Pragma" | "Retry-After" | "Save-Data" | "Sec-CH-Prefers-Color-Scheme" | "Sec-CH-Prefers-Reduced-Motion" | "Sec-CH-UA" | "Sec-CH-UA-Arch" | "Sec-CH-UA-Bitness" | "Sec-CH-UA-Form-Factor" | "Sec-CH-UA-Full-Version" | "Sec-CH-UA-Full-Version-List" | "Sec-CH-UA-Mobile" | "Sec-CH-UA-Model" | "Sec-CH-UA-Platform" | "Sec-CH-UA-Platform-Version" | "Sec-CH-UA-WoW64" | "Sec-Fetch-Dest" | "Sec-Fetch-Mode" | "Sec-Fetch-Site" | "Sec-Fetch-User" | "Sec-GPC" | "Server" | "Server-Timing" | "Service-Worker-Navigation-Preload" | "Set-Cookie" | "Strict-Transport-Security" | "Timing-Allow-Origin" | "Trailer" | "Transfer-Encoding" | "Upgrade" | "Vary" | "WWW-Authenticate" | "Warning" | "X-Content-Type-Options" | "X-DNS-Prefetch-Control" | "X-Frame-Options" | "X-Permitted-Cross-Domain-Policies" | "X-Powered-By" | "X-Robots-Tag" | "X-XSS-Protection";
export type CustomHeader = string & {};
/**
 * @module
 * HTTP Status utility.
 */
export type InfoStatusCode = 100 | 101 | 102 | 103;
export type SuccessStatusCode = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 226;
export type DeprecatedStatusCode = 305 | 306;
export type RedirectStatusCode = 300 | 301 | 302 | 303 | 304 | DeprecatedStatusCode | 307 | 308;
export type ClientErrorStatusCode = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 421 | 422 | 423 | 424 | 425 | 426 | 428 | 429 | 431 | 451;
export type ServerErrorStatusCode = 500 | 501 | 502 | 503 | 504 | 505 | 506 | 507 | 508 | 510 | 511;
/**
 * `UnofficialStatusCode` can be used to specify an unofficial status code.
 * @example
 *
 * ```ts
 * app.get('/unknown', (c) => {
 *   return c.text("Unknown Error", 520 as UnofficialStatusCode)
 * })
 * ```
 */
export type UnofficialStatusCode = -1;
/**
 * If you want to use an unofficial status, use `UnofficialStatusCode`.
 */
export type StatusCode = InfoStatusCode | SuccessStatusCode | RedirectStatusCode | ClientErrorStatusCode | ServerErrorStatusCode | UnofficialStatusCode;
export type ContentlessStatusCode = 101 | 204 | 205 | 304;
export type ContentfulStatusCode = Exclude<StatusCode, ContentlessStatusCode>;
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
export type RemoveBlankRecord<T> = T extends Record<infer K, unknown> ? (K extends string ? T : never) : never;
export type IfAnyThenEmptyObject<T> = 0 extends 1 & T ? {} : T;
export type JSONPrimitive = string | boolean | number | null;
export type JSONArray = (JSONPrimitive | JSONObject | JSONArray)[];
export type JSONObject = {
	[key: string]: JSONPrimitive | JSONArray | JSONObject | object | InvalidJSONValue;
};
export type InvalidJSONValue = undefined | symbol | ((...args: unknown[]) => unknown);
export type InvalidToNull<T> = T extends InvalidJSONValue ? null : T;
export type IsInvalid<T> = T extends InvalidJSONValue ? true : false;
/**
 * symbol keys are omitted through `JSON.stringify`
 */
export type OmitSymbolKeys<T> = {
	[K in keyof T as K extends symbol ? never : K]: T[K];
};
export type JSONValue = JSONObject | JSONArray | JSONPrimitive;
/**
 * Convert a type to a JSON-compatible type.
 *
 * Non-JSON values such as `Date` implement `.toJSON()`,
 * so they can be transformed to a value assignable to `JSONObject`
 *
 * `JSON.stringify()` throws a `TypeError` when it encounters a `bigint` value,
 * unless a custom `replacer` function or `.toJSON()` method is provided.
 *
 * This behaviour can be controlled by the `TError` generic type parameter,
 * which defaults to `bigint | ReadonlyArray<bigint>`.
 * You can set it to `never` to disable this check.
 */
export type JSONParsed<T, TError = bigint | ReadonlyArray<bigint>> = T extends {
	toJSON(): infer J;
} ? (() => J) extends () => JSONPrimitive ? J : (() => J) extends () => {
	toJSON(): unknown;
} ? {} : JSONParsed<J, TError> : T extends JSONPrimitive ? T : T extends InvalidJSONValue ? never : T extends ReadonlyArray<unknown> ? {
	[K in keyof T]: JSONParsed<InvalidToNull<T[K]>, TError>;
} : T extends Set<unknown> | Map<unknown, unknown> | Record<string, never> ? {} : T extends object ? T[keyof T] extends TError ? never : {
	[K in keyof OmitSymbolKeys<T> as IsInvalid<T[K]> extends true ? never : K]: boolean extends IsInvalid<T[K]> ? JSONParsed<T[K], TError> | undefined : JSONParsed<T[K], TError>;
} : T extends unknown ? T extends TError ? never : JSONValue : never;
/**
 * Useful to flatten the type output to improve type hints shown in editors. And also to transform an interface into a type to aide with assignability.
 * @copyright from sindresorhus/type-fest
 */
export type Simplify<T> = {
	[KeyType in keyof T]: T[KeyType];
} & {};
export type IsAny<T> = boolean extends (T extends never ? true : false) ? true : false;
export type Bindings = object;
export type Variables = object;
export type BlankEnv = {};
export type Env = {
	Bindings?: Bindings;
	Variables?: Variables;
};
export type Next = () => Promise<void>;
export type ExtractInput<I extends Input | Input["in"]> = I extends Input ? unknown extends I["in"] ? {} : I["in"] : I;
export type Input = {
	in?: {};
	out?: {};
	outputFormat?: ResponseFormat;
};
export type BlankSchema = {};
export type BlankInput = {};
export interface RouterRoute {
	basePath: string;
	path: string;
	method: string;
	handler: H;
}
export type HandlerResponse<O> = Response | TypedResponse<O> | Promise<Response | TypedResponse<O>> | Promise<void>;
export type Handler<E extends Env = any, P extends string = any, I extends Input = BlankInput, R extends HandlerResponse<any> = any> = (c: Context<E, P, I>, next: Next) => R;
export type MiddlewareHandler<E extends Env = any, P extends string = string, I extends Input = {}, R extends HandlerResponse<any> = Response> = (c: Context<E, P, I>, next: Next) => Promise<R | void>;
export type H<E extends Env = any, P extends string = any, I extends Input = BlankInput, R extends HandlerResponse<any> = any> = Handler<E, P, I, R> | MiddlewareHandler<E, P, I, R>;
/**
 * You can extend this interface to define a custom `c.notFound()` Response type.
 *
 * @example
 * declare module 'hono' {
 *   interface NotFoundResponse extends Response, TypedResponse<string, 404, 'text'> {}
 * }
 */
export interface NotFoundResponse {
}
export type NotFoundHandler<E extends Env = any> = (c: Context<E>) => NotFoundResponse extends Response ? NotFoundResponse | Promise<NotFoundResponse> : Response | Promise<Response>;
export interface HTTPResponseError extends Error {
	getResponse: () => Response;
}
export type ErrorHandler<E extends Env = any> = (err: Error | HTTPResponseError, c: Context<E>) => Response | Promise<Response>;
export interface HandlerInterface<E extends Env = Env, M extends string = string, S extends Schema = BlankSchema, BasePath extends string = "/", CurrentPath extends string = BasePath> {
	<P extends string = CurrentPath, I extends Input = BlankInput, R extends HandlerResponse<any> = any, E2 extends Env = E>(handler: H<E2, P, I, R>): Hono<IntersectNonAnyTypes<[
		E,
		E2
	]>, S & ToSchema<M, P, I, MergeTypedResponse<R>>, BasePath, CurrentPath>;
	<P extends string = CurrentPath, I extends Input = BlankInput, I2 extends Input = I, R extends HandlerResponse<any> = any, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, M1 extends H<E2, P, any> = H<E2, P, any>>(...handlers: [
		H<E2, P, I> & M1,
		H<E3, P, I2, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, S & ToSchema<M, P, I2, MergeTypedResponse<R> | MergeMiddlewareResponse<M1>>, BasePath, CurrentPath>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, E2 extends Env = E>(path: P, handler: H<E2, MergedPath, I, R>): Hono<E, AddSchemaIfHasResponse<MergeTypedResponse<R>, S, M, P, I, BasePath>, BasePath, MergePath<BasePath, P>>;
	<P extends string = CurrentPath, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, M1 extends H<E2, P, any> = H<E2, P, any>, M2 extends H<E3, P, any> = H<E3, P, any>>(...handlers: [
		H<E2, P, I> & M1,
		H<E3, P, I2> & M2,
		H<E4, P, I3, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, S & ToSchema<M, P, I3, MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2>>, BasePath, CurrentPath>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, M1 extends H<E2, MergedPath, any> = H<E2, MergedPath, any>>(path: P, ...handlers: [
		H<E2, MergedPath, I> & M1,
		H<E3, MergedPath, I2, R>
	]): Hono<E, AddSchemaIfHasResponse<MergeTypedResponse<R> | MergeMiddlewareResponse<M1>, S, M, P, I2, BasePath>, BasePath, MergePath<BasePath, P>>;
	<P extends string = CurrentPath, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, M1 extends H<E2, P, any> = H<E2, P, any>, M2 extends H<E3, P, any> = H<E3, P, any>, M3 extends H<E4, P, any> = H<E4, P, any>>(...handlers: [
		H<E2, P, I> & M1,
		H<E3, P, I2> & M2,
		H<E4, P, I3> & M3,
		H<E5, P, I4, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, S & ToSchema<M, P, I4, MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3>>, BasePath, CurrentPath>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, M1 extends H<E2, MergedPath, any> = H<E2, MergedPath, any>, M2 extends H<E3, MergedPath, any> = H<E3, MergedPath, any>>(path: P, ...handlers: [
		H<E2, MergedPath, I> & M1,
		H<E3, MergedPath, I2> & M2,
		H<E4, MergedPath, I3, R>
	]): Hono<E, AddSchemaIfHasResponse<MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2>, S, M, P, I3, BasePath>, BasePath, MergePath<BasePath, P>>;
	<P extends string = CurrentPath, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, M1 extends H<E2, P, any> = H<E2, P, any>, M2 extends H<E3, P, any> = H<E3, P, any>, M3 extends H<E4, P, any> = H<E4, P, any>, M4 extends H<E5, P, any> = H<E5, P, any>>(...handlers: [
		H<E2, P, I> & M1,
		H<E3, P, I2> & M2,
		H<E4, P, I3> & M3,
		H<E5, P, I4> & M4,
		H<E6, P, I5, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, S & ToSchema<M, P, I5, MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3> | MergeMiddlewareResponse<M4>>, BasePath, CurrentPath>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, M1 extends H<E2, MergedPath, any> = H<E2, MergedPath, any>, M2 extends H<E3, MergedPath, any> = H<E3, MergedPath, any>, M3 extends H<E4, MergedPath, any> = H<E4, MergedPath, any>>(path: P, ...handlers: [
		H<E2, MergedPath, I> & M1,
		H<E3, MergedPath, I2> & M2,
		H<E4, MergedPath, I3> & M3,
		H<E5, MergedPath, I4, R>
	]): Hono<E, AddSchemaIfHasResponse<MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3>, S, M, P, I4, BasePath>, BasePath, MergePath<BasePath, P>>;
	<P extends string = CurrentPath, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, M1 extends H<E2, P, any> = H<E2, P, any>, M2 extends H<E3, P, any> = H<E3, P, any>, M3 extends H<E4, P, any> = H<E4, P, any>, M4 extends H<E5, P, any> = H<E5, P, any>, M5 extends H<E6, P, any> = H<E6, P, any>>(...handlers: [
		H<E2, P, I> & M1,
		H<E3, P, I2> & M2,
		H<E4, P, I3> & M3,
		H<E5, P, I4> & M4,
		H<E6, P, I5> & M5,
		H<E7, P, I6, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, S & ToSchema<M, P, I6, MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3> | MergeMiddlewareResponse<M4> | MergeMiddlewareResponse<M5>>, BasePath, CurrentPath>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, M1 extends H<E2, MergedPath, any> = H<E2, MergedPath, any>, M2 extends H<E3, MergedPath, any> = H<E3, MergedPath, any>, M3 extends H<E4, MergedPath, any> = H<E4, MergedPath, any>, M4 extends H<E5, MergedPath, any> = H<E5, MergedPath, any>>(path: P, ...handlers: [
		H<E2, MergedPath, I> & M1,
		H<E3, MergedPath, I2> & M2,
		H<E4, MergedPath, I3> & M3,
		H<E5, MergedPath, I4> & M4,
		H<E6, MergedPath, I5, R>
	]): Hono<E, AddSchemaIfHasResponse<MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3> | MergeMiddlewareResponse<M4>, S, M, P, I5, BasePath>, BasePath, MergePath<BasePath, P>>;
	<P extends string = CurrentPath, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, M1 extends H<E2, P, any> = H<E2, P, any>, M2 extends H<E3, P, any> = H<E3, P, any>, M3 extends H<E4, P, any> = H<E4, P, any>, M4 extends H<E5, P, any> = H<E5, P, any>, M5 extends H<E6, P, any> = H<E6, P, any>, M6 extends H<E7, P, any> = H<E7, P, any>>(...handlers: [
		H<E2, P, I> & M1,
		H<E3, P, I2> & M2,
		H<E4, P, I3> & M3,
		H<E5, P, I4> & M4,
		H<E6, P, I5> & M5,
		H<E7, P, I6> & M6,
		H<E8, P, I7, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, S & ToSchema<M, P, I7, MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3> | MergeMiddlewareResponse<M4> | MergeMiddlewareResponse<M5> | MergeMiddlewareResponse<M6>>, BasePath, CurrentPath>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, M1 extends H<E2, MergedPath, any> = H<E2, MergedPath, any>, M2 extends H<E3, MergedPath, any> = H<E3, MergedPath, any>, M3 extends H<E4, MergedPath, any> = H<E4, MergedPath, any>, M4 extends H<E5, MergedPath, any> = H<E5, MergedPath, any>, M5 extends H<E6, MergedPath, any> = H<E6, MergedPath, any>>(path: P, ...handlers: [
		H<E2, MergedPath, I> & M1,
		H<E3, MergedPath, I2> & M2,
		H<E4, MergedPath, I3> & M3,
		H<E5, MergedPath, I4> & M4,
		H<E6, MergedPath, I5> & M5,
		H<E7, MergedPath, I6, R>
	]): Hono<E, AddSchemaIfHasResponse<MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3> | MergeMiddlewareResponse<M4> | MergeMiddlewareResponse<M5>, S, M, P, I6, BasePath>, BasePath, MergePath<BasePath, P>>;
	<P extends string = CurrentPath, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, M1 extends H<E2, P, any> = H<E2, P, any>, M2 extends H<E3, P, any> = H<E3, P, any>, M3 extends H<E4, P, any> = H<E4, P, any>, M4 extends H<E5, P, any> = H<E5, P, any>, M5 extends H<E6, P, any> = H<E6, P, any>, M6 extends H<E7, P, any> = H<E7, P, any>, M7 extends H<E8, P, any> = H<E8, P, any>>(...handlers: [
		H<E2, P, I> & M1,
		H<E3, P, I2> & M2,
		H<E4, P, I3> & M3,
		H<E5, P, I4> & M4,
		H<E6, P, I5> & M5,
		H<E7, P, I6> & M6,
		H<E8, P, I7> & M7,
		H<E9, P, I8, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, S & ToSchema<M, P, I8, MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3> | MergeMiddlewareResponse<M4> | MergeMiddlewareResponse<M5> | MergeMiddlewareResponse<M6> | MergeMiddlewareResponse<M7>>, BasePath, CurrentPath>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, M1 extends H<E2, MergedPath, any> = H<E2, MergedPath, any>, M2 extends H<E3, MergedPath, any> = H<E3, MergedPath, any>, M3 extends H<E4, MergedPath, any> = H<E4, MergedPath, any>, M4 extends H<E5, MergedPath, any> = H<E5, MergedPath, any>, M5 extends H<E6, MergedPath, any> = H<E6, MergedPath, any>, M6 extends H<E7, MergedPath, any> = H<E7, MergedPath, any>>(path: P, ...handlers: [
		H<E2, MergedPath, I> & M1,
		H<E3, MergedPath, I2> & M2,
		H<E4, MergedPath, I3> & M3,
		H<E5, MergedPath, I4> & M4,
		H<E6, MergedPath, I5> & M5,
		H<E7, MergedPath, I6> & M6,
		H<E8, MergedPath, I7, R>
	]): Hono<E, AddSchemaIfHasResponse<MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3> | MergeMiddlewareResponse<M4> | MergeMiddlewareResponse<M5> | MergeMiddlewareResponse<M6>, S, M, P, I7, BasePath>, BasePath, MergePath<BasePath, P>>;
	<P extends string = CurrentPath, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7, I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, E10 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, M1 extends H<E2, P, any> = H<E2, P, any>, M2 extends H<E3, P, any> = H<E3, P, any>, M3 extends H<E4, P, any> = H<E4, P, any>, M4 extends H<E5, P, any> = H<E5, P, any>, M5 extends H<E6, P, any> = H<E6, P, any>, M6 extends H<E7, P, any> = H<E7, P, any>, M7 extends H<E8, P, any> = H<E8, P, any>, M8 extends H<E9, P, any> = H<E9, P, any>>(...handlers: [
		H<E2, P, I> & M1,
		H<E3, P, I2> & M2,
		H<E4, P, I3> & M3,
		H<E5, P, I4> & M4,
		H<E6, P, I5> & M5,
		H<E7, P, I6> & M6,
		H<E8, P, I7> & M7,
		H<E9, P, I8> & M8,
		H<E10, P, I9, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10
	]>, S & ToSchema<M, P, I9, MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3> | MergeMiddlewareResponse<M4> | MergeMiddlewareResponse<M5> | MergeMiddlewareResponse<M6> | MergeMiddlewareResponse<M7> | MergeMiddlewareResponse<M8>>, BasePath, CurrentPath>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, M1 extends H<E2, MergedPath, any> = H<E2, MergedPath, any>, M2 extends H<E3, MergedPath, any> = H<E3, MergedPath, any>, M3 extends H<E4, MergedPath, any> = H<E4, MergedPath, any>, M4 extends H<E5, MergedPath, any> = H<E5, MergedPath, any>, M5 extends H<E6, MergedPath, any> = H<E6, MergedPath, any>, M6 extends H<E7, MergedPath, any> = H<E7, MergedPath, any>, M7 extends H<E8, MergedPath, any> = H<E8, MergedPath, any>>(path: P, ...handlers: [
		H<E2, MergedPath, I> & M1,
		H<E3, MergedPath, I2> & M2,
		H<E4, MergedPath, I3> & M3,
		H<E5, MergedPath, I4> & M4,
		H<E6, MergedPath, I5> & M5,
		H<E7, MergedPath, I6> & M6,
		H<E8, MergedPath, I7> & M7,
		H<E9, MergedPath, I8, R>
	]): Hono<E, AddSchemaIfHasResponse<MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3> | MergeMiddlewareResponse<M4> | MergeMiddlewareResponse<M5> | MergeMiddlewareResponse<M6> | MergeMiddlewareResponse<M7>, S, M, P, I8, BasePath>, BasePath, MergePath<BasePath, P>>;
	<P extends string = CurrentPath, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7, I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8, I10 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8 & I9, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, E10 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, E11 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10
	]>, M1 extends H<E2, P, any> = H<E2, P, any>, M2 extends H<E3, P, any> = H<E3, P, any>, M3 extends H<E4, P, any> = H<E4, P, any>, M4 extends H<E5, P, any> = H<E5, P, any>, M5 extends H<E6, P, any> = H<E6, P, any>, M6 extends H<E7, P, any> = H<E7, P, any>, M7 extends H<E8, P, any> = H<E8, P, any>, M8 extends H<E9, P, any> = H<E9, P, any>, M9 extends H<E10, P, any> = H<E10, P, any>>(...handlers: [
		H<E2, P, I> & M1,
		H<E3, P, I2> & M2,
		H<E4, P, I3> & M3,
		H<E5, P, I4> & M4,
		H<E6, P, I5> & M5,
		H<E7, P, I6> & M6,
		H<E8, P, I7> & M7,
		H<E9, P, I8> & M8,
		H<E10, P, I9> & M9,
		H<E11, P, I10, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10,
		E11
	]>, S & ToSchema<M, P, I10, MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3> | MergeMiddlewareResponse<M4> | MergeMiddlewareResponse<M5> | MergeMiddlewareResponse<M6> | MergeMiddlewareResponse<M7> | MergeMiddlewareResponse<M8> | MergeMiddlewareResponse<M9>>, BasePath, CurrentPath>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7, I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, E10 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, M1 extends H<E2, MergedPath, any> = H<E2, MergedPath, any>, M2 extends H<E3, MergedPath, any> = H<E3, MergedPath, any>, M3 extends H<E4, MergedPath, any> = H<E4, MergedPath, any>, M4 extends H<E5, MergedPath, any> = H<E5, MergedPath, any>, M5 extends H<E6, MergedPath, any> = H<E6, MergedPath, any>, M6 extends H<E7, MergedPath, any> = H<E7, MergedPath, any>, M7 extends H<E8, MergedPath, any> = H<E8, MergedPath, any>, M8 extends H<E9, MergedPath, any> = H<E9, MergedPath, any>>(path: P, ...handlers: [
		H<E2, MergedPath, I> & M1,
		H<E3, MergedPath, I2> & M2,
		H<E4, MergedPath, I3> & M3,
		H<E5, MergedPath, I4> & M4,
		H<E6, MergedPath, I5> & M5,
		H<E7, MergedPath, I6> & M6,
		H<E8, MergedPath, I7> & M7,
		H<E9, MergedPath, I8> & M8,
		H<E10, MergedPath, I9, R>
	]): Hono<E, AddSchemaIfHasResponse<MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3> | MergeMiddlewareResponse<M4> | MergeMiddlewareResponse<M5> | MergeMiddlewareResponse<M6> | MergeMiddlewareResponse<M7> | MergeMiddlewareResponse<M8>, S, M, P, I9, BasePath>, BasePath, MergePath<BasePath, P>>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7, I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8, I10 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8 & I9, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, E10 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, E11 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10
	]>, M1 extends H<E2, MergedPath, any> = H<E2, MergedPath, any>, M2 extends H<E3, MergedPath, any> = H<E3, MergedPath, any>, M3 extends H<E4, MergedPath, any> = H<E4, MergedPath, any>, M4 extends H<E5, MergedPath, any> = H<E5, MergedPath, any>, M5 extends H<E6, MergedPath, any> = H<E6, MergedPath, any>, M6 extends H<E7, MergedPath, any> = H<E7, MergedPath, any>, M7 extends H<E8, MergedPath, any> = H<E8, MergedPath, any>, M8 extends H<E9, MergedPath, any> = H<E9, MergedPath, any>, M9 extends H<E10, MergedPath, any> = H<E10, MergedPath, any>>(path: P, ...handlers: [
		H<E2, MergedPath, I> & M1,
		H<E3, MergedPath, I2> & M2,
		H<E4, MergedPath, I3> & M3,
		H<E5, MergedPath, I4> & M4,
		H<E6, MergedPath, I5> & M5,
		H<E7, MergedPath, I6> & M6,
		H<E8, MergedPath, I7> & M7,
		H<E9, MergedPath, I8> & M8,
		H<E10, MergedPath, I9> & M9,
		H<E11, MergedPath, I10, R>
	]): Hono<E, AddSchemaIfHasResponse<MergeTypedResponse<R> | MergeMiddlewareResponse<M1> | MergeMiddlewareResponse<M2> | MergeMiddlewareResponse<M3> | MergeMiddlewareResponse<M4> | MergeMiddlewareResponse<M5> | MergeMiddlewareResponse<M6> | MergeMiddlewareResponse<M7> | MergeMiddlewareResponse<M8> | MergeMiddlewareResponse<M9>, S, M, P, I10, BasePath>, BasePath, MergePath<BasePath, P>>;
	<P extends string = CurrentPath, I extends Input = BlankInput, R extends HandlerResponse<any> = any>(...handlers: H<E, P, I, R>[]): Hono<E, S & ToSchema<M, P, I, MergeTypedResponse<R>>, BasePath, CurrentPath>;
	<P extends string, I extends Input = BlankInput, R extends HandlerResponse<any> = any>(path: P, ...handlers: [
		H<E, MergePath<BasePath, P>, I, R>,
		...H<E, MergePath<BasePath, P>, I, R>[]
	]): Hono<E, S & ToSchema<M, MergePath<BasePath, P>, I, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<P extends string, R extends HandlerResponse<any> = any, I extends Input = BlankInput>(path: P): Hono<E, S & ToSchema<M, MergePath<BasePath, P>, I, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
}
export interface MiddlewareHandlerInterface<E extends Env = Env, S extends Schema = BlankSchema, BasePath extends string = "/"> {
	<E2 extends Env = E>(...handlers: MiddlewareHandler<E2, MergePath<BasePath, "*">>[]): Hono<IntersectNonAnyTypes<[
		E,
		E2
	]>, S, BasePath, MergePath<BasePath, "*">>;
	<E2 extends Env = E>(handler: MiddlewareHandler<E2, MergePath<BasePath, "*">>): Hono<IntersectNonAnyTypes<[
		E,
		E2
	]>, S, BasePath, MergePath<BasePath, "*">>;
	<E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, P extends string = MergePath<BasePath, "*">>(...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, S, BasePath, P>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, E2 extends Env = E>(path: P, handler: MiddlewareHandler<E2, MergedPath, any, any>): Hono<IntersectNonAnyTypes<[
		E,
		E2
	]>, S, BasePath, MergedPath>;
	<E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, P extends string = MergePath<BasePath, "*">>(...handlers: [
		MiddlewareHandler<E2, P, any, any>,
		MiddlewareHandler<E3, P, any, any>,
		MiddlewareHandler<E4, P, any, any>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, S, BasePath, P>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>>(path: P, ...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, S, BasePath, MergedPath>;
	<E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, P extends string = MergePath<BasePath, "*">>(...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, S, BasePath, P>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>>(path: P, ...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, S, BasePath, MergedPath>;
	<E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, P extends string = MergePath<BasePath, "*">>(...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>,
		MiddlewareHandler<E6, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, S, BasePath, P>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>>(path: P, ...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, S, BasePath, MergedPath>;
	<E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, P extends string = MergePath<BasePath, "*">>(...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>,
		MiddlewareHandler<E6, P>,
		MiddlewareHandler<E7, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, S, BasePath, P>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>>(path: P, ...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>,
		MiddlewareHandler<E6, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, S, BasePath, MergedPath>;
	<E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, P extends string = MergePath<BasePath, "*">>(...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>,
		MiddlewareHandler<E6, P>,
		MiddlewareHandler<E7, P>,
		MiddlewareHandler<E8, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, S, BasePath, P>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>>(path: P, ...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>,
		MiddlewareHandler<E6, P>,
		MiddlewareHandler<E7, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, S, BasePath, MergedPath>;
	<E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, P extends string = MergePath<BasePath, "*">>(...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>,
		MiddlewareHandler<E6, P>,
		MiddlewareHandler<E7, P>,
		MiddlewareHandler<E8, P>,
		MiddlewareHandler<E9, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, S, BasePath, P>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>>(path: P, ...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>,
		MiddlewareHandler<E6, P>,
		MiddlewareHandler<E7, P>,
		MiddlewareHandler<E8, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, S, BasePath, MergedPath>;
	<E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, E10 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, P extends string = MergePath<BasePath, "*">>(...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>,
		MiddlewareHandler<E6, P>,
		MiddlewareHandler<E7, P>,
		MiddlewareHandler<E8, P>,
		MiddlewareHandler<E9, P>,
		MiddlewareHandler<E10, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10
	]>, S, BasePath, P>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>>(path: P, ...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>,
		MiddlewareHandler<E6, P>,
		MiddlewareHandler<E7, P>,
		MiddlewareHandler<E8, P>,
		MiddlewareHandler<E9, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, S, BasePath, MergedPath>;
	<E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, E10 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, E11 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10
	]>, P extends string = MergePath<BasePath, "*">>(...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>,
		MiddlewareHandler<E6, P>,
		MiddlewareHandler<E7, P>,
		MiddlewareHandler<E8, P>,
		MiddlewareHandler<E9, P>,
		MiddlewareHandler<E10, P>,
		MiddlewareHandler<E11, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10,
		E11
	]>, S, BasePath, P>;
	<P extends string, MergedPath extends MergePath<BasePath, P>, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, E10 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>>(path: P, ...handlers: [
		MiddlewareHandler<E2, P>,
		MiddlewareHandler<E3, P>,
		MiddlewareHandler<E4, P>,
		MiddlewareHandler<E5, P>,
		MiddlewareHandler<E6, P>,
		MiddlewareHandler<E7, P>,
		MiddlewareHandler<E8, P>,
		MiddlewareHandler<E9, P>,
		MiddlewareHandler<E10, P>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10
	]>, S, BasePath, MergedPath>;
	<P extends string, E2 extends Env = E>(path: P, ...handlers: MiddlewareHandler<E2, MergePath<BasePath, P>>[]): Hono<E, S, BasePath, MergePath<BasePath, P>>;
}
export interface OnHandlerInterface<E extends Env = Env, S extends Schema = BlankSchema, BasePath extends string = "/"> {
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, E2 extends Env = E>(method: M, path: P, handler: H<E2, MergedPath, I, R>): Hono<IntersectNonAnyTypes<[
		E,
		E2
	]>, S & ToSchema<M, MergePath<BasePath, P>, I, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>>(method: M, path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, S & ToSchema<M, MergePath<BasePath, P>, I2, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>>(method: M, path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, S & ToSchema<M, MergePath<BasePath, P>, I3, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>>(method: M, path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, S & ToSchema<M, MergePath<BasePath, P>, I4, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>>(method: M, path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4>,
		H<E6, MergedPath, I5, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, S & ToSchema<M, MergePath<BasePath, P>, I5, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>>(method: M, path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4>,
		H<E6, MergedPath, I5>,
		H<E7, MergedPath, I6, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, S & ToSchema<M, MergePath<BasePath, P>, I6, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>>(method: M, path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4>,
		H<E6, MergedPath, I5>,
		H<E7, MergedPath, I6>,
		H<E8, MergedPath, I7, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, S & ToSchema<M, MergePath<BasePath, P>, I7, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>>(method: M, path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4>,
		H<E6, MergedPath, I5>,
		H<E7, MergedPath, I6>,
		H<E8, MergedPath, I7>,
		H<E9, MergedPath, I8, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, S & ToSchema<M, MergePath<BasePath, P>, I8, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7, I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, E10 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>>(method: M, path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4>,
		H<E6, MergedPath, I5>,
		H<E7, MergedPath, I6>,
		H<E8, MergedPath, I7>,
		H<E9, MergedPath, I8>,
		H<E10, MergedPath, I9, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10
	]>, S & ToSchema<M, MergePath<BasePath, P>, I9, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7, I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8, I10 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8 & I9, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, E10 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, E11 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10
	]>>(method: M, path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4>,
		H<E6, MergedPath, I5>,
		H<E7, MergedPath, I6>,
		H<E8, MergedPath, I7>,
		H<E9, MergedPath, I8>,
		H<E10, MergedPath, I9>,
		H<E11, MergedPath, I10, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10,
		E11
	]>, S & ToSchema<M, MergePath<BasePath, P>, I10, MergeTypedResponse<HandlerResponse<any>>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, R extends HandlerResponse<any> = any, I extends Input = BlankInput>(method: M, path: P, ...handlers: [
		H<E, MergePath<BasePath, P>, I, R>,
		...H<E, MergePath<BasePath, P>, I, R>[]
	]): Hono<E, S & ToSchema<M, MergePath<BasePath, P>, I, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, E2 extends Env = E>(methods: M[], path: P, handler: H<E2, MergedPath, I, R>): Hono<IntersectNonAnyTypes<[
		E,
		E2
	]>, S & ToSchema<M, MergePath<BasePath, P>, I, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>>(methods: M[], path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, S & ToSchema<M, MergePath<BasePath, P>, I2, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>>(methods: M[], path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, S & ToSchema<M, MergePath<BasePath, P>, I3, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>>(methods: M[], path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, S & ToSchema<M, MergePath<BasePath, P>, I4, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>>(methods: M[], path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4>,
		H<E6, MergedPath, I5, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, S & ToSchema<M, MergePath<BasePath, P>, I5, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>>(methods: M[], path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4>,
		H<E6, MergedPath, I5>,
		H<E7, MergedPath, I6, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, S & ToSchema<M, MergePath<BasePath, P>, I6, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>>(methods: M[], path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4>,
		H<E6, MergedPath, I5>,
		H<E7, MergedPath, I6>,
		H<E8, MergedPath, I7, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, S & ToSchema<M, MergePath<BasePath, P>, I7, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>>(methods: M[], path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4>,
		H<E6, MergedPath, I5>,
		H<E7, MergedPath, I6>,
		H<E8, MergedPath, I7>,
		H<E9, MergedPath, I8, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, S & ToSchema<M, MergePath<BasePath, P>, I8, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7, I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, E10 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>>(methods: M[], path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4>,
		H<E6, MergedPath, I5>,
		H<E7, MergedPath, I6>,
		H<E8, MergedPath, I7>,
		H<E9, MergedPath, I8>,
		H<E10, MergedPath, I9, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10
	]>, S & ToSchema<M, MergePath<BasePath, P>, I9, MergeTypedResponse<HandlerResponse<any>>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, MergedPath extends MergePath<BasePath, P>, R extends HandlerResponse<any> = any, I extends Input = BlankInput, I2 extends Input = I, I3 extends Input = I & I2, I4 extends Input = I & I2 & I3, I5 extends Input = I & I2 & I3 & I4, I6 extends Input = I & I2 & I3 & I4 & I5, I7 extends Input = I & I2 & I3 & I4 & I5 & I6, I8 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7, I9 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8, I10 extends Input = I & I2 & I3 & I4 & I5 & I6 & I7 & I8 & I9, E2 extends Env = E, E3 extends Env = IntersectNonAnyTypes<[
		E,
		E2
	]>, E4 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3
	]>, E5 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4
	]>, E6 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5
	]>, E7 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6
	]>, E8 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7
	]>, E9 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8
	]>, E10 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9
	]>, E11 extends Env = IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10
	]>>(methods: M[], path: P, ...handlers: [
		H<E2, MergedPath, I>,
		H<E3, MergedPath, I2>,
		H<E4, MergedPath, I3>,
		H<E5, MergedPath, I4>,
		H<E6, MergedPath, I5>,
		H<E7, MergedPath, I6>,
		H<E8, MergedPath, I7>,
		H<E9, MergedPath, I8>,
		H<E10, MergedPath, I9>,
		H<E11, MergedPath, I10, R>
	]): Hono<IntersectNonAnyTypes<[
		E,
		E2,
		E3,
		E4,
		E5,
		E6,
		E7,
		E8,
		E9,
		E10,
		E11
	]>, S & ToSchema<M, MergePath<BasePath, P>, I10, MergeTypedResponse<HandlerResponse<any>>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, P extends string, R extends HandlerResponse<any> = any, I extends Input = BlankInput>(methods: M[], path: P, ...handlers: [
		H<E, MergePath<BasePath, P>, I, R>,
		...H<E, MergePath<BasePath, P>, I, R>[]
	]): Hono<E, S & ToSchema<M, MergePath<BasePath, P>, I, MergeTypedResponse<R>>, BasePath, MergePath<BasePath, P>>;
	<M extends string, const Ps extends string[], I extends Input = BlankInput, R extends HandlerResponse<any> = any, E2 extends Env = E>(methods: M | M[], paths: Ps, ...handlers: H<E2, MergePath<BasePath, Ps[number]>, I, R>[]): Hono<E, S & ToSchema<M, MergePath<BasePath, Ps[number]>, I, MergeTypedResponse<R>>, BasePath, Ps extends [
		...string[],
		infer LastPath extends string
	] ? MergePath<BasePath, LastPath> : never>;
}
export type ToSchemaOutput<RorO, I extends Input | Input["in"]> = RorO extends TypedResponse<infer T, infer U, infer F> ? {
	output: unknown extends T ? {} : T;
	outputFormat: I extends {
		outputFormat: string;
	} ? I["outputFormat"] : F;
	status: U;
} : {
	output: unknown extends RorO ? {} : RorO;
	outputFormat: unknown extends RorO ? "json" : I extends {
		outputFormat: string;
	} ? I["outputFormat"] : "json";
	status: StatusCode;
};
export type ToSchema<M extends string, P extends string, I extends Input | Input["in"], RorO> = IsAny<RorO> extends true ? {
	[K in P]: {
		[K2 in M as AddDollar<K2>]: {
			input: AddParam<ExtractInput<I>, P>;
			output: {};
			outputFormat: ResponseFormat;
			status: StatusCode;
		};
	};
} : [
	RorO
] extends [
	never
] ? {} : [
	RorO
] extends [
	Promise<void>
] ? {} : {
	[K in P]: {
		[K2 in M as AddDollar<K2>]: Simplify<{
			input: AddParam<ExtractInput<I>, P>;
		} & ToSchemaOutput<RorO, I>>;
	};
};
export type Schema = {
	[Path: string]: {
		[Method: `$${Lowercase<string>}`]: Endpoint;
	};
};
export type AddSchemaIfHasResponse<Merged, S extends Schema, M extends string, P extends string, I extends Input | Input["in"], BasePath extends string> = [
	Merged
] extends [
	Promise<void>
] ? S : S & ToSchema<M, MergePath<BasePath, P>, I, Merged>;
export type Endpoint = {
	input: any;
	output: any;
	outputFormat: ResponseFormat;
	status: StatusCode;
};
export type ExtractParams<Path extends string> = string extends Path ? Record<string, string> : Path extends `${infer _Start}:${infer Param}/${infer Rest}` ? {
	[K in Param | keyof ExtractParams<`/${Rest}`>]: string;
} : Path extends `${infer _Start}:${infer Param}` ? {
	[K in Param]: string;
} : never;
export type FlattenIfIntersect<T> = T extends infer O ? {
	[K in keyof O]: O[K];
} : never;
export type MergeSchemaPath<OrigSchema extends Schema, SubPath extends string> = {
	[P in keyof OrigSchema as MergePath<SubPath, P & string>]: [
		OrigSchema[P]
	] extends [
		Record<string, Endpoint>
	] ? {
		[M in keyof OrigSchema[P]]: MergeEndpointParamsWithPath<OrigSchema[P][M], SubPath>;
	} : never;
};
export type MergeEndpointParamsWithPath<T extends Endpoint, SubPath extends string> = T extends unknown ? {
	input: T["input"] extends {
		param: infer _;
	} ? ExtractParams<SubPath> extends never ? T["input"] : FlattenIfIntersect<T["input"] & {
		param: {
			[K in keyof ExtractParams<SubPath> as K extends `${infer Prefix}{${infer _}}` ? Prefix : K]: string;
		};
	}> : RemoveBlankRecord<ExtractParams<SubPath>> extends never ? T["input"] : T["input"] & {
		param: {
			[K in keyof ExtractParams<SubPath> as K extends `${infer Prefix}{${infer _}}` ? Prefix : K]: string;
		};
	};
	output: T["output"];
	outputFormat: T["outputFormat"];
	status: T["status"];
} : never;
export type AddParam<I, P extends string> = ParamKeys<P> extends never ? I : I extends {
	param: infer _;
} ? I : I & {
	param: UnionToIntersection<ParamKeyToRecord<ParamKeys<P>>>;
};
export type AddDollar<T extends string> = `$${Lowercase<T>}`;
export type MergePath<A extends string, B extends string> = B extends "" ? MergePath<A, "/"> : A extends "" ? B : A extends "/" ? B : A extends `${infer P}/` ? B extends `/${infer Q}` ? `${P}/${Q}` : `${P}/${B}` : B extends `/${infer Q}` ? Q extends "" ? A : `${A}/${Q}` : `${A}/${B}`;
export type KnownResponseFormat = "json" | "text" | "redirect";
export type ResponseFormat = KnownResponseFormat | string;
export type TypedResponse<T = unknown, U extends StatusCode = StatusCode, F extends ResponseFormat = T extends string ? "text" : T extends JSONValue ? "json" : ResponseFormat> = {
	_data: T;
	_status: U;
	_format: F;
};
export type MergeTypedResponse<T> = T extends Promise<void> ? T : T extends Promise<infer T2> ? T2 extends TypedResponse ? T2 : TypedResponse : T extends TypedResponse ? T : TypedResponse;
export type ExtractTypedResponseOnly<T> = T extends TypedResponse ? T : never;
export type MergeMiddlewareResponse<T> = T extends (c: any, next: any) => Promise<infer R> ? Exclude<R, void> extends never ? never : Exclude<R, void> extends Response | TypedResponse<any, any, any> ? ExtractTypedResponseOnly<Exclude<R, void>> : never : T extends (c: any, next: any) => infer R ? R extends Response | TypedResponse<any, any, any> ? ExtractTypedResponseOnly<R> : never : never;
export type FormValue = string | Blob;
export type ParsedFormValue = string | File;
export type ValidationTargets<T extends FormValue = ParsedFormValue, P extends string = string> = {
	json: any;
	form: Record<string, T | T[]>;
	query: Record<string, string | string[]>;
	param: Record<P, P extends `${infer _}?` ? string | undefined : string>;
	header: Record<RequestHeader | CustomHeader, string>;
	cookie: Record<string, string>;
};
export type ParamKey<Component> = Component extends `:${infer NameWithPattern}` ? NameWithPattern extends `${infer Name}{${infer Rest}` ? Rest extends `${infer _Pattern}?` ? `${Name}?` : Name : NameWithPattern : never;
export type ParamKeys<Path> = Path extends `${infer Component}/${infer Rest}` ? ParamKey<Component> | ParamKeys<Rest> : ParamKey<Path>;
export type ParamKeyToRecord<T extends string> = T extends `${infer R}?` ? Record<R, string | undefined> : {
	[K in T]: string;
};
export type InputToDataByTarget<T extends Input["out"], Target extends keyof ValidationTargets> = T extends {
	[K in Target]: infer R;
} ? R : never;
export type RemoveQuestion<T> = T extends `${infer R}?` ? R : T;
export type ProcessHead<T> = IfAnyThenEmptyObject<T extends Env ? (Env extends T ? {} : T) : T>;
export type IntersectNonAnyTypes<T extends any[]> = T extends [
	infer Head,
	...infer Rest
] ? ProcessHead<Head> & IntersectNonAnyTypes<Rest> : {};
declare abstract class FetchEventLike {
	abstract readonly request: Request;
	abstract respondWith(promise: Response | Promise<Response>): void;
	abstract passThroughOnException(): void;
	abstract waitUntil(promise: Promise<void>): void;
}
export type BodyDataValueDot = {
	[x: string]: string | File | BodyDataValueDot;
};
export type BodyDataValueDotAll = {
	[x: string]: string | File | (string | File)[] | BodyDataValueDotAll;
};
export type SimplifyBodyData<T> = {
	[K in keyof T]: string | File | (string | File)[] | BodyDataValueDotAll extends T[K] ? string | File | (string | File)[] | BodyDataValueDotAll : string | File | BodyDataValueDot extends T[K] ? string | File | BodyDataValueDot : string | File | (string | File)[] extends T[K] ? string | File | (string | File)[] : string | File;
} & {};
export type BodyDataValueComponent<T> = string | File | (T extends {
	all: false;
} ? never : T extends {
	all: true;
} | {
	all: boolean;
} ? (string | File)[] : never);
export type BodyDataValueObject<T> = {
	[key: string]: BodyDataValueComponent<T> | BodyDataValueObject<T>;
};
export type BodyDataValue<T> = BodyDataValueComponent<T> | (T extends {
	dot: false;
} ? never : T extends {
	dot: true;
} | {
	dot: boolean;
} ? BodyDataValueObject<T> : never);
export type BodyData<T extends Partial<ParseBodyOptions> = {}> = SimplifyBodyData<Record<string, BodyDataValue<T>>>;
export type ParseBodyOptions = {
	/**
	 * Determines whether all fields with multiple values should be parsed as arrays.
	 * @default false
	 * @example
	 * const data = new FormData()
	 * data.append('file', 'aaa')
	 * data.append('file', 'bbb')
	 * data.append('message', 'hello')
	 *
	 * If all is false:
	 * parseBody should return { file: 'bbb', message: 'hello' }
	 *
	 * If all is true:
	 * parseBody should return { file: ['aaa', 'bbb'], message: 'hello' }
	 */
	all: boolean;
	/**
	 * Determines whether all fields with dot notation should be parsed as nested objects.
	 * @default false
	 * @example
	 * const data = new FormData()
	 * data.append('obj.key1', 'value1')
	 * data.append('obj.key2', 'value2')
	 *
	 * If dot is false:
	 * parseBody should return { 'obj.key1': 'value1', 'obj.key2': 'value2' }
	 *
	 * If dot is true:
	 * parseBody should return { obj: { key1: 'value1', key2: 'value2' } }
	 */
	dot: boolean;
};
type Body$1 = {
	json: any;
	text: string;
	arrayBuffer: ArrayBuffer;
	blob: Blob;
	formData: FormData;
};
export type BodyCache = Partial<Body$1 & {
	parsedBody: BodyData;
}>;
declare class HonoRequest<P extends string = "/", I extends Input["out"] = {}> {
	/**
	 * `.raw` can get the raw Request object.
	 *
	 * @see {@link https://hono.dev/docs/api/request#raw}
	 *
	 * @example
	 * ```ts
	 * // For Cloudflare Workers
	 * app.post('/', async (c) => {
	 *   const metadata = c.req.raw.cf?.hostMetadata?
	 *   ...
	 * })
	 * ```
	 */
	raw: Request;
	routeIndex: number;
	/**
	 * `.path` can get the pathname of the request.
	 *
	 * @see {@link https://hono.dev/docs/api/request#path}
	 *
	 * @example
	 * ```ts
	 * app.get('/about/me', (c) => {
	 *   const pathname = c.req.path // `/about/me`
	 * })
	 * ```
	 */
	path: string;
	bodyCache: BodyCache;
	constructor(request: Request, path?: string, matchResult?: Result<[
		unknown,
		RouterRoute
	]>);
	/**
	 * `.req.param()` gets the path parameters.
	 *
	 * @see {@link https://hono.dev/docs/api/routing#path-parameter}
	 *
	 * @example
	 * ```ts
	 * const name = c.req.param('name')
	 * // or all parameters at once
	 * const { id, comment_id } = c.req.param()
	 * ```
	 */
	param<P2 extends ParamKeys<P> = ParamKeys<P>>(key: P2 extends `${infer _}?` ? never : P2): string;
	param<P2 extends RemoveQuestion<ParamKeys<P>> = RemoveQuestion<ParamKeys<P>>>(key: P2): string | undefined;
	param(key: string): string | undefined;
	param<P2 extends string = P>(): Simplify<UnionToIntersection<ParamKeyToRecord<ParamKeys<P2>>>>;
	/**
	 * `.query()` can get querystring parameters.
	 *
	 * @see {@link https://hono.dev/docs/api/request#query}
	 *
	 * @example
	 * ```ts
	 * // Query params
	 * app.get('/search', (c) => {
	 *   const query = c.req.query('q')
	 * })
	 *
	 * // Get all params at once
	 * app.get('/search', (c) => {
	 *   const { q, limit, offset } = c.req.query()
	 * })
	 * ```
	 */
	query(key: string): string | undefined;
	query(): Record<string, string>;
	/**
	 * `.queries()` can get multiple querystring parameter values, e.g. /search?tags=A&tags=B
	 *
	 * @see {@link https://hono.dev/docs/api/request#queries}
	 *
	 * @example
	 * ```ts
	 * app.get('/search', (c) => {
	 *   // tags will be string[]
	 *   const tags = c.req.queries('tags')
	 * })
	 * ```
	 */
	queries(key: string): string[] | undefined;
	queries(): Record<string, string[]>;
	/**
	 * `.header()` can get the request header value.
	 *
	 * @see {@link https://hono.dev/docs/api/request#header}
	 *
	 * @example
	 * ```ts
	 * app.get('/', (c) => {
	 *   const userAgent = c.req.header('User-Agent')
	 * })
	 * ```
	 */
	header(name: RequestHeader): string | undefined;
	header(name: string): string | undefined;
	header(): Record<RequestHeader | (string & CustomHeader), string>;
	/**
	 * `.parseBody()` can parse Request body of type `multipart/form-data` or `application/x-www-form-urlencoded`
	 *
	 * @see {@link https://hono.dev/docs/api/request#parsebody}
	 *
	 * @example
	 * ```ts
	 * app.post('/entry', async (c) => {
	 *   const body = await c.req.parseBody()
	 * })
	 * ```
	 */
	parseBody<Options extends Partial<ParseBodyOptions>, T extends BodyData<Options>>(options?: Options): Promise<T>;
	parseBody<T extends BodyData>(options?: Partial<ParseBodyOptions>): Promise<T>;
	/**
	 * `.json()` can parse Request body of type `application/json`
	 *
	 * @see {@link https://hono.dev/docs/api/request#json}
	 *
	 * @example
	 * ```ts
	 * app.post('/entry', async (c) => {
	 *   const body = await c.req.json()
	 * })
	 * ```
	 */
	json<T = any>(): Promise<T>;
	/**
	 * `.text()` can parse Request body of type `text/plain`
	 *
	 * @see {@link https://hono.dev/docs/api/request#text}
	 *
	 * @example
	 * ```ts
	 * app.post('/entry', async (c) => {
	 *   const body = await c.req.text()
	 * })
	 * ```
	 */
	text(): Promise<string>;
	/**
	 * `.arrayBuffer()` parse Request body as an `ArrayBuffer`
	 *
	 * @see {@link https://hono.dev/docs/api/request#arraybuffer}
	 *
	 * @example
	 * ```ts
	 * app.post('/entry', async (c) => {
	 *   const body = await c.req.arrayBuffer()
	 * })
	 * ```
	 */
	arrayBuffer(): Promise<ArrayBuffer>;
	/**
	 * Parses the request body as a `Blob`.
	 * @example
	 * ```ts
	 * app.post('/entry', async (c) => {
	 *   const body = await c.req.blob();
	 * });
	 * ```
	 * @see https://hono.dev/docs/api/request#blob
	 */
	blob(): Promise<Blob>;
	/**
	 * Parses the request body as `FormData`.
	 * @example
	 * ```ts
	 * app.post('/entry', async (c) => {
	 *   const body = await c.req.formData();
	 * });
	 * ```
	 * @see https://hono.dev/docs/api/request#formdata
	 */
	formData(): Promise<FormData>;
	/**
	 * Adds validated data to the request.
	 *
	 * @param target - The target of the validation.
	 * @param data - The validated data to add.
	 */
	addValidatedData(target: keyof ValidationTargets, data: {}): void;
	/**
	 * Gets validated data from the request.
	 *
	 * @param target - The target of the validation.
	 * @returns The validated data.
	 *
	 * @see https://hono.dev/docs/api/request#valid
	 */
	valid<T extends keyof I & keyof ValidationTargets>(target: T): InputToDataByTarget<I, T>;
	/**
	 * `.url()` can get the request url strings.
	 *
	 * @see {@link https://hono.dev/docs/api/request#url}
	 *
	 * @example
	 * ```ts
	 * app.get('/about/me', (c) => {
	 *   const url = c.req.url // `http://localhost:8787/about/me`
	 *   ...
	 * })
	 * ```
	 */
	get url(): string;
	/**
	 * `.method()` can get the method name of the request.
	 *
	 * @see {@link https://hono.dev/docs/api/request#method}
	 *
	 * @example
	 * ```ts
	 * app.get('/about/me', (c) => {
	 *   const method = c.req.method // `GET`
	 * })
	 * ```
	 */
	get method(): string;
	get [GET_MATCH_RESULT](): Result<[
		unknown,
		RouterRoute
	]>;
	/**
	 * `.matchedRoutes()` can return a matched route in the handler
	 *
	 * @deprecated
	 *
	 * Use matchedRoutes helper defined in "hono/route" instead.
	 *
	 * @see {@link https://hono.dev/docs/api/request#matchedroutes}
	 *
	 * @example
	 * ```ts
	 * app.use('*', async function logger(c, next) {
	 *   await next()
	 *   c.req.matchedRoutes.forEach(({ handler, method, path }, i) => {
	 *     const name = handler.name || (handler.length < 2 ? '[handler]' : '[middleware]')
	 *     console.log(
	 *       method,
	 *       ' ',
	 *       path,
	 *       ' '.repeat(Math.max(10 - path.length, 0)),
	 *       name,
	 *       i === c.req.routeIndex ? '<- respond from here' : ''
	 *     )
	 *   })
	 * })
	 * ```
	 */
	get matchedRoutes(): RouterRoute[];
	/**
	 * `routePath()` can retrieve the path registered within the handler
	 *
	 * @deprecated
	 *
	 * Use routePath helper defined in "hono/route" instead.
	 *
	 * @see {@link https://hono.dev/docs/api/request#routepath}
	 *
	 * @example
	 * ```ts
	 * app.get('/posts/:id', (c) => {
	 *   return c.json({ path: c.req.routePath })
	 * })
	 * ```
	 */
	get routePath(): string;
}
/**
 * Union types for BaseMime
 */
export type BaseMime = (typeof _baseMimes)[keyof typeof _baseMimes];
declare const _baseMimes: {
	readonly aac: "audio/aac";
	readonly avi: "video/x-msvideo";
	readonly avif: "image/avif";
	readonly av1: "video/av1";
	readonly bin: "application/octet-stream";
	readonly bmp: "image/bmp";
	readonly css: "text/css";
	readonly csv: "text/csv";
	readonly eot: "application/vnd.ms-fontobject";
	readonly epub: "application/epub+zip";
	readonly gif: "image/gif";
	readonly gz: "application/gzip";
	readonly htm: "text/html";
	readonly html: "text/html";
	readonly ico: "image/x-icon";
	readonly ics: "text/calendar";
	readonly jpeg: "image/jpeg";
	readonly jpg: "image/jpeg";
	readonly js: "text/javascript";
	readonly json: "application/json";
	readonly jsonld: "application/ld+json";
	readonly map: "application/json";
	readonly mid: "audio/x-midi";
	readonly midi: "audio/x-midi";
	readonly mjs: "text/javascript";
	readonly mp3: "audio/mpeg";
	readonly mp4: "video/mp4";
	readonly mpeg: "video/mpeg";
	readonly oga: "audio/ogg";
	readonly ogv: "video/ogg";
	readonly ogx: "application/ogg";
	readonly opus: "audio/opus";
	readonly otf: "font/otf";
	readonly pdf: "application/pdf";
	readonly png: "image/png";
	readonly rtf: "application/rtf";
	readonly svg: "image/svg+xml";
	readonly tif: "image/tiff";
	readonly tiff: "image/tiff";
	readonly ts: "video/mp2t";
	readonly ttf: "font/ttf";
	readonly txt: "text/plain";
	readonly wasm: "application/wasm";
	readonly webm: "video/webm";
	readonly weba: "audio/webm";
	readonly webmanifest: "application/manifest+json";
	readonly webp: "image/webp";
	readonly woff: "font/woff";
	readonly woff2: "font/woff2";
	readonly xhtml: "application/xhtml+xml";
	readonly xml: "application/xml";
	readonly zip: "application/zip";
	readonly "3gp": "video/3gpp";
	readonly "3g2": "video/3gpp2";
	readonly gltf: "model/gltf+json";
	readonly glb: "model/gltf-binary";
};
export type HeaderRecord = Record<"Content-Type", BaseMime> | Record<ResponseHeader, string | string[]> | Record<string, string | string[]>;
/**
 * Data type can be a string, ArrayBuffer, Uint8Array (buffer), or ReadableStream.
 */
export type Data = string | ArrayBuffer | ReadableStream | Uint8Array<ArrayBuffer>;
interface ExecutionContext$1 {
	/**
	 * Extends the lifetime of the event callback until the promise is settled.
	 *
	 * @param promise - A promise to wait for.
	 */
	waitUntil(promise: Promise<unknown>): void;
	/**
	 * Allows the event to be passed through to subsequent event listeners.
	 */
	passThroughOnException(): void;
	/**
	 * For compatibility with Wrangler 4.x.
	 */
	props: any;
}
/**
 * Interface for context variable mapping.
 */
export interface ContextVariableMap {
}
/**
 * Interface for context renderer.
 */
export interface ContextRenderer {
}
/**
 * Interface representing a renderer for content.
 *
 * @interface DefaultRenderer
 * @param {string | Promise<string>} content - The content to be rendered, which can be either a string or a Promise resolving to a string.
 * @returns {Response | Promise<Response>} - The response after rendering the content, which can be either a Response or a Promise resolving to a Response.
 */
export interface DefaultRenderer {
	(content: string | Promise<string>): Response | Promise<Response>;
}
/**
 * Renderer type which can either be a ContextRenderer or DefaultRenderer.
 */
export type Renderer = ContextRenderer extends Function ? ContextRenderer : DefaultRenderer;
/**
 * Extracts the props for the renderer.
 */
export type PropsForRenderer = [
	...Required<Parameters<Renderer>>
] extends [
	unknown,
	infer Props
] ? Props : unknown;
export type Layout<T = Record<string, any>> = (props: T) => any;
/**
 * Interface for getting context variables.
 *
 * @template E - Environment type.
 */
export interface Get<E extends Env> {
	<Key extends keyof E["Variables"]>(key: Key): E["Variables"][Key];
	<Key extends keyof ContextVariableMap>(key: Key): ContextVariableMap[Key];
}
interface Set$1<E extends Env> {
	<Key extends keyof E["Variables"]>(key: Key, value: E["Variables"][Key]): void;
	<Key extends keyof ContextVariableMap>(key: Key, value: ContextVariableMap[Key]): void;
}
/**
 * Interface for creating a new response.
 */
export interface NewResponse {
	(data: Data | null, status?: StatusCode, headers?: HeaderRecord): Response;
	(data: Data | null, init?: ResponseOrInit): Response;
}
/**
 * Interface for responding with a body.
 */
export interface BodyRespond {
	<T extends Data, U extends ContentfulStatusCode>(data: T, status?: U, headers?: HeaderRecord): Response & TypedResponse<T, U, "body">;
	<T extends Data, U extends ContentfulStatusCode>(data: T, init?: ResponseOrInit<U>): Response & TypedResponse<T, U, "body">;
	<T extends null, U extends StatusCode>(data: T, status?: U, headers?: HeaderRecord): Response & TypedResponse<null, U, "body">;
	<T extends null, U extends StatusCode>(data: T, init?: ResponseOrInit<U>): Response & TypedResponse<null, U, "body">;
}
/**
 * Interface for responding with text.
 *
 * @interface TextRespond
 * @template T - The type of the text content.
 * @template U - The type of the status code.
 *
 * @param {T} text - The text content to be included in the response.
 * @param {U} [status] - An optional status code for the response.
 * @param {HeaderRecord} [headers] - An optional record of headers to include in the response.
 *
 * @returns {Response & TypedResponse<T, U, 'text'>} - The response after rendering the text content, typed with the provided text and status code types.
 */
export interface TextRespond {
	<T extends string, U extends ContentfulStatusCode = ContentfulStatusCode>(text: T, status?: U, headers?: HeaderRecord): Response & TypedResponse<T, U, "text">;
	<T extends string, U extends ContentfulStatusCode = ContentfulStatusCode>(text: T, init?: ResponseOrInit<U>): Response & TypedResponse<T, U, "text">;
}
/**
 * Interface for responding with JSON.
 *
 * @interface JSONRespond
 * @template T - The type of the JSON value or simplified unknown type.
 * @template U - The type of the status code.
 *
 * @param {T} object - The JSON object to be included in the response.
 * @param {U} [status] - An optional status code for the response.
 * @param {HeaderRecord} [headers] - An optional record of headers to include in the response.
 *
 * @returns {JSONRespondReturn<T, U>} - The response after rendering the JSON object, typed with the provided object and status code types.
 */
export interface JSONRespond {
	<T extends JSONValue | {} | InvalidJSONValue, U extends ContentfulStatusCode = ContentfulStatusCode>(object: T, status?: U, headers?: HeaderRecord): JSONRespondReturn<T, U>;
	<T extends JSONValue | {} | InvalidJSONValue, U extends ContentfulStatusCode = ContentfulStatusCode>(object: T, init?: ResponseOrInit<U>): JSONRespondReturn<T, U>;
}
/**
 * @template T - The type of the JSON value or simplified unknown type.
 * @template U - The type of the status code.
 *
 * @returns {Response & TypedResponse<JSONParsed<T>, U, 'json'>} - The response after rendering the JSON object, typed with the provided object and status code types.
 */
export type JSONRespondReturn<T extends JSONValue | {} | InvalidJSONValue, U extends ContentfulStatusCode> = Response & TypedResponse<JSONParsed<T>, U, "json">;
/**
 * Interface representing a function that responds with HTML content.
 *
 * @param html - The HTML content to respond with, which can be a string or a Promise that resolves to a string.
 * @param status - (Optional) The HTTP status code for the response.
 * @param headers - (Optional) A record of headers to include in the response.
 * @param init - (Optional) The response initialization object.
 *
 * @returns A Response object or a Promise that resolves to a Response object.
 */
export interface HTMLRespond {
	<T extends string | Promise<string>>(html: T, status?: ContentfulStatusCode, headers?: HeaderRecord): T extends string ? Response : Promise<Response>;
	<T extends string | Promise<string>>(html: T, init?: ResponseOrInit<ContentfulStatusCode>): T extends string ? Response : Promise<Response>;
}
/**
 * Options for configuring the context.
 *
 * @template E - Environment type.
 */
export type ContextOptions<E extends Env> = {
	/**
	 * Bindings for the environment.
	 */
	env: E["Bindings"];
	/**
	 * Execution context for the request.
	 */
	executionCtx?: FetchEventLike | ExecutionContext$1 | undefined;
	/**
	 * Handler for not found responses.
	 */
	notFoundHandler?: NotFoundHandler<E>;
	matchResult?: Result<[
		H,
		RouterRoute
	]>;
	path?: string;
};
export interface SetHeadersOptions {
	append?: boolean;
}
export interface SetHeaders {
	(name: "Content-Type", value?: BaseMime, options?: SetHeadersOptions): void;
	(name: ResponseHeader, value?: string, options?: SetHeadersOptions): void;
	(name: string, value?: string, options?: SetHeadersOptions): void;
}
export type ResponseHeadersInit = [
	string,
	string
][] | Record<"Content-Type", BaseMime> | Record<ResponseHeader, string> | Record<string, string> | Headers;
interface ResponseInit$1<T extends StatusCode = StatusCode> {
	headers?: ResponseHeadersInit;
	status?: T;
	statusText?: string;
}
export type ResponseOrInit<T extends StatusCode = StatusCode> = ResponseInit$1<T> | Response;
declare class Context<E extends Env = any, P extends string = any, I extends Input = {}> {
	/**
	 * `.env` can get bindings (environment variables, secrets, KV namespaces, D1 database, R2 bucket etc.) in Cloudflare Workers.
	 *
	 * @see {@link https://hono.dev/docs/api/context#env}
	 *
	 * @example
	 * ```ts
	 * // Environment object for Cloudflare Workers
	 * app.get('*', async c => {
	 *   const counter = c.env.COUNTER
	 * })
	 * ```
	 */
	env: E["Bindings"];
	finalized: boolean;
	/**
	 * `.error` can get the error object from the middleware if the Handler throws an error.
	 *
	 * @see {@link https://hono.dev/docs/api/context#error}
	 *
	 * @example
	 * ```ts
	 * app.use('*', async (c, next) => {
	 *   await next()
	 *   if (c.error) {
	 *     // do something...
	 *   }
	 * })
	 * ```
	 */
	error: Error | undefined;
	/**
	 * Creates an instance of the Context class.
	 *
	 * @param req - The Request object.
	 * @param options - Optional configuration options for the context.
	 */
	constructor(req: Request, options?: ContextOptions<E>);
	/**
	 * `.req` is the instance of {@link HonoRequest}.
	 */
	get req(): HonoRequest<P, I["out"]>;
	/**
	 * @see {@link https://hono.dev/docs/api/context#event}
	 * The FetchEvent associated with the current request.
	 *
	 * @throws Will throw an error if the context does not have a FetchEvent.
	 */
	get event(): FetchEventLike;
	/**
	 * @see {@link https://hono.dev/docs/api/context#executionctx}
	 * The ExecutionContext associated with the current request.
	 *
	 * @throws Will throw an error if the context does not have an ExecutionContext.
	 */
	get executionCtx(): ExecutionContext$1;
	/**
	 * @see {@link https://hono.dev/docs/api/context#res}
	 * The Response object for the current request.
	 */
	get res(): Response;
	/**
	 * Sets the Response object for the current request.
	 *
	 * @param _res - The Response object to set.
	 */
	set res(_res: Response | undefined);
	/**
	 * `.render()` can create a response within a layout.
	 *
	 * @see {@link https://hono.dev/docs/api/context#render-setrenderer}
	 *
	 * @example
	 * ```ts
	 * app.get('/', (c) => {
	 *   return c.render('Hello!')
	 * })
	 * ```
	 */
	render: Renderer;
	/**
	 * Sets the layout for the response.
	 *
	 * @param layout - The layout to set.
	 * @returns The layout function.
	 */
	setLayout: (layout: Layout<PropsForRenderer & {
		Layout: Layout;
	}>) => Layout<PropsForRenderer & {
		Layout: Layout;
	}>;
	/**
	 * Gets the current layout for the response.
	 *
	 * @returns The current layout function.
	 */
	getLayout: () => Layout<PropsForRenderer & {
		Layout: Layout;
	}> | undefined;
	/**
	 * `.setRenderer()` can set the layout in the custom middleware.
	 *
	 * @see {@link https://hono.dev/docs/api/context#render-setrenderer}
	 *
	 * @example
	 * ```tsx
	 * app.use('*', async (c, next) => {
	 *   c.setRenderer((content) => {
	 *     return c.html(
	 *       <html>
	 *         <body>
	 *           <p>{content}</p>
	 *         </body>
	 *       </html>
	 *     )
	 *   })
	 *   await next()
	 * })
	 * ```
	 */
	setRenderer: (renderer: Renderer) => void;
	/**
	 * `.header()` can set headers.
	 *
	 * @see {@link https://hono.dev/docs/api/context#header}
	 *
	 * @example
	 * ```ts
	 * app.get('/welcome', (c) => {
	 *   // Set headers
	 *   c.header('X-Message', 'Hello!')
	 *   c.header('Content-Type', 'text/plain')
	 *
	 *   return c.body('Thank you for coming')
	 * })
	 * ```
	 */
	header: SetHeaders;
	status: (status: StatusCode) => void;
	/**
	 * `.set()` can set the value specified by the key.
	 *
	 * @see {@link https://hono.dev/docs/api/context#set-get}
	 *
	 * @example
	 * ```ts
	 * app.use('*', async (c, next) => {
	 *   c.set('message', 'Hono is hot!!')
	 *   await next()
	 * })
	 * ```
	 */
	set: Set$1<IsAny<E> extends true ? {
		Variables: ContextVariableMap & Record<string, any>;
	} : E>;
	/**
	 * `.get()` can use the value specified by the key.
	 *
	 * @see {@link https://hono.dev/docs/api/context#set-get}
	 *
	 * @example
	 * ```ts
	 * app.get('/', (c) => {
	 *   const message = c.get('message')
	 *   return c.text(`The message is "${message}"`)
	 * })
	 * ```
	 */
	get: Get<IsAny<E> extends true ? {
		Variables: ContextVariableMap & Record<string, any>;
	} : E>;
	/**
	 * `.var` can access the value of a variable.
	 *
	 * @see {@link https://hono.dev/docs/api/context#var}
	 *
	 * @example
	 * ```ts
	 * const result = c.var.client.oneMethod()
	 * ```
	 */
	get var(): Readonly<ContextVariableMap & (IsAny<E["Variables"]> extends true ? Record<string, any> : E["Variables"])>;
	newResponse: NewResponse;
	/**
	 * `.body()` can return the HTTP response.
	 * You can set headers with `.header()` and set HTTP status code with `.status`.
	 * This can also be set in `.text()`, `.json()` and so on.
	 *
	 * @see {@link https://hono.dev/docs/api/context#body}
	 *
	 * @example
	 * ```ts
	 * app.get('/welcome', (c) => {
	 *   // Set headers
	 *   c.header('X-Message', 'Hello!')
	 *   c.header('Content-Type', 'text/plain')
	 *   // Set HTTP status code
	 *   c.status(201)
	 *
	 *   // Return the response body
	 *   return c.body('Thank you for coming')
	 * })
	 * ```
	 */
	body: BodyRespond;
	/**
	 * `.text()` can render text as `Content-Type:text/plain`.
	 *
	 * @see {@link https://hono.dev/docs/api/context#text}
	 *
	 * @example
	 * ```ts
	 * app.get('/say', (c) => {
	 *   return c.text('Hello!')
	 * })
	 * ```
	 */
	text: TextRespond;
	/**
	 * `.json()` can render JSON as `Content-Type:application/json`.
	 *
	 * @see {@link https://hono.dev/docs/api/context#json}
	 *
	 * @example
	 * ```ts
	 * app.get('/api', (c) => {
	 *   return c.json({ message: 'Hello!' })
	 * })
	 * ```
	 */
	json: JSONRespond;
	html: HTMLRespond;
	/**
	 * `.redirect()` can Redirect, default status code is 302.
	 *
	 * @see {@link https://hono.dev/docs/api/context#redirect}
	 *
	 * @example
	 * ```ts
	 * app.get('/redirect', (c) => {
	 *   return c.redirect('/')
	 * })
	 * app.get('/redirect-permanently', (c) => {
	 *   return c.redirect('/', 301)
	 * })
	 * ```
	 */
	redirect: <T extends RedirectStatusCode = 302>(location: string | URL, status?: T) => Response & TypedResponse<undefined, T, "redirect">;
	/**
	 * `.notFound()` can return the Not Found Response.
	 *
	 * @see {@link https://hono.dev/docs/api/context#notfound}
	 *
	 * @example
	 * ```ts
	 * app.get('/notfound', (c) => {
	 *   return c.notFound()
	 * })
	 * ```
	 */
	notFound: () => ReturnType<NotFoundHandler>;
}
export type GetPath<E extends Env> = (request: Request, options?: {
	env?: E["Bindings"];
}) => string;
export type HonoOptions<E extends Env> = {
	/**
	 * `strict` option specifies whether to distinguish whether the last path is a directory or not.
	 *
	 * @see {@link https://hono.dev/docs/api/hono#strict-mode}
	 *
	 * @default true
	 */
	strict?: boolean;
	/**
	 * `router` option specifies which router to use.
	 *
	 * @see {@link https://hono.dev/docs/api/hono#router-option}
	 *
	 * @example
	 * ```ts
	 * const app = new Hono({ router: new RegExpRouter() })
	 * ```
	 */
	router?: Router<[
		H,
		RouterRoute
	]>;
	/**
	 * `getPath` can handle the host header value.
	 *
	 * @see {@link https://hono.dev/docs/api/routing#routing-with-host-header-value}
	 *
	 * @example
	 * ```ts
	 * const app = new Hono({
	 *  getPath: (req) =>
	 *   '/' + req.headers.get('host') + req.url.replace(/^https?:\/\/[^/]+(\/[^?]*)/, '$1'),
	 * })
	 *
	 * app.get('/www1.example.com/hello', () => c.text('hello www1'))
	 *
	 * // A following request will match the route:
	 * // new Request('http://www1.example.com/hello', {
	 * //  headers: { host: 'www1.example.com' },
	 * // })
	 * ```
	 */
	getPath?: GetPath<E>;
};
export type MountOptionHandler = (c: Context) => unknown;
export type MountReplaceRequest = (originalRequest: Request) => Request;
export type MountOptions = MountOptionHandler | {
	optionHandler?: MountOptionHandler;
	replaceRequest?: MountReplaceRequest | false;
};
declare class Hono<E extends Env = Env, S extends Schema = {}, BasePath extends string = "/", CurrentPath extends string = BasePath> {
	get: HandlerInterface<E, "get", S, BasePath, CurrentPath>;
	post: HandlerInterface<E, "post", S, BasePath, CurrentPath>;
	put: HandlerInterface<E, "put", S, BasePath, CurrentPath>;
	delete: HandlerInterface<E, "delete", S, BasePath, CurrentPath>;
	options: HandlerInterface<E, "options", S, BasePath, CurrentPath>;
	patch: HandlerInterface<E, "patch", S, BasePath, CurrentPath>;
	all: HandlerInterface<E, "all", S, BasePath, CurrentPath>;
	on: OnHandlerInterface<E, S, BasePath>;
	use: MiddlewareHandlerInterface<E, S, BasePath>;
	router: Router<[
		H,
		RouterRoute
	]>;
	readonly getPath: GetPath<E>;
	private _basePath;
	routes: RouterRoute[];
	constructor(options?: HonoOptions<E>);
	private errorHandler;
	/**
	 * `.route()` allows grouping other Hono instance in routes.
	 *
	 * @see {@link https://hono.dev/docs/api/routing#grouping}
	 *
	 * @param {string} path - base Path
	 * @param {Hono} app - other Hono instance
	 * @returns {Hono} routed Hono instance
	 *
	 * @example
	 * ```ts
	 * const app = new Hono()
	 * const app2 = new Hono()
	 *
	 * app2.get("/user", (c) => c.text("user"))
	 * app.route("/api", app2) // GET /api/user
	 * ```
	 */
	route<SubPath extends string, SubEnv extends Env, SubSchema extends Schema, SubBasePath extends string, SubCurrentPath extends string>(path: SubPath, app: Hono<SubEnv, SubSchema, SubBasePath, SubCurrentPath>): Hono<E, MergeSchemaPath<SubSchema, MergePath<BasePath, SubPath>> | S, BasePath, CurrentPath>;
	/**
	 * `.basePath()` allows base paths to be specified.
	 *
	 * @see {@link https://hono.dev/docs/api/routing#base-path}
	 *
	 * @param {string} path - base Path
	 * @returns {Hono} changed Hono instance
	 *
	 * @example
	 * ```ts
	 * const api = new Hono().basePath('/api')
	 * ```
	 */
	basePath<SubPath extends string>(path: SubPath): Hono<E, S, MergePath<BasePath, SubPath>, MergePath<BasePath, SubPath>>;
	/**
	 * `.onError()` handles an error and returns a customized Response.
	 *
	 * @see {@link https://hono.dev/docs/api/hono#error-handling}
	 *
	 * @param {ErrorHandler} handler - request Handler for error
	 * @returns {Hono} changed Hono instance
	 *
	 * @example
	 * ```ts
	 * app.onError((err, c) => {
	 *   console.error(`${err}`)
	 *   return c.text('Custom Error Message', 500)
	 * })
	 * ```
	 */
	onError: (handler: ErrorHandler<E>) => Hono<E, S, BasePath, CurrentPath>;
	/**
	 * `.notFound()` allows you to customize a Not Found Response.
	 *
	 * @see {@link https://hono.dev/docs/api/hono#not-found}
	 *
	 * @param {NotFoundHandler} handler - request handler for not-found
	 * @returns {Hono} changed Hono instance
	 *
	 * @example
	 * ```ts
	 * app.notFound((c) => {
	 *   return c.text('Custom 404 Message', 404)
	 * })
	 * ```
	 */
	notFound: (handler: NotFoundHandler<E>) => Hono<E, S, BasePath, CurrentPath>;
	/**
	 * `.mount()` allows you to mount applications built with other frameworks into your Hono application.
	 *
	 * @see {@link https://hono.dev/docs/api/hono#mount}
	 *
	 * @param {string} path - base Path
	 * @param {Function} applicationHandler - other Request Handler
	 * @param {MountOptions} [options] - options of `.mount()`
	 * @returns {Hono} mounted Hono instance
	 *
	 * @example
	 * ```ts
	 * import { Router as IttyRouter } from 'itty-router'
	 * import { Hono } from 'hono'
	 * // Create itty-router application
	 * const ittyRouter = IttyRouter()
	 * // GET /itty-router/hello
	 * ittyRouter.get('/hello', () => new Response('Hello from itty-router'))
	 *
	 * const app = new Hono()
	 * app.mount('/itty-router', ittyRouter.handle)
	 * ```
	 *
	 * @example
	 * ```ts
	 * const app = new Hono()
	 * // Send the request to another application without modification.
	 * app.mount('/app', anotherApp, {
	 *   replaceRequest: (req) => req,
	 * })
	 * ```
	 */
	mount(path: string, applicationHandler: (request: Request, ...args: any) => Response | Promise<Response>, options?: MountOptions): Hono<E, S, BasePath, CurrentPath>;
	/**
	 * `.fetch()` will be entry point of your app.
	 *
	 * @see {@link https://hono.dev/docs/api/hono#fetch}
	 *
	 * @param {Request} request - request Object of request
	 * @param {Env} Env - env Object
	 * @param {ExecutionContext} - context of execution
	 * @returns {Response | Promise<Response>} response of request
	 *
	 */
	fetch: (request: Request, Env?: E["Bindings"] | {}, executionCtx?: ExecutionContext$1) => Response | Promise<Response>;
	/**
	 * `.request()` is a useful method for testing.
	 * You can pass a URL or pathname to send a GET request.
	 * app will return a Response object.
	 * ```ts
	 * test('GET /hello is ok', async () => {
	 *   const res = await app.request('/hello')
	 *   expect(res.status).toBe(200)
	 * })
	 * ```
	 * @see https://hono.dev/docs/api/hono#request
	 */
	request: (input: RequestInfo | URL, requestInit?: RequestInit, Env?: E["Bindings"] | {}, executionCtx?: ExecutionContext$1) => Response | Promise<Response>;
	/**
	 * `.fire()` automatically adds a global fetch event listener.
	 * This can be useful for environments that adhere to the Service Worker API, such as non-ES module Cloudflare Workers.
	 * @deprecated
	 * Use `fire` from `hono/service-worker` instead.
	 * ```ts
	 * import { Hono } from 'hono'
	 * import { fire } from 'hono/service-worker'
	 *
	 * const app = new Hono()
	 * // ...
	 * fire(app)
	 * ```
	 * @see https://hono.dev/docs/api/hono#fire
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
	 * @see https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/
	 */
	fire: () => void;
}
declare class Hono$1<E extends Env = BlankEnv, S extends Schema = BlankSchema, BasePath extends string = "/"> extends Hono<E, S, BasePath> {
	/**
	 * Creates an instance of the Hono class.
	 *
	 * @param options - Optional configuration options for the Hono instance.
	 */
	constructor(options?: HonoOptions<E>);
}
/** Auto-captured by the pipeline for every policy when tracing is active. */
export interface PolicyTraceBaseline {
	name: string;
	priority: number;
	durationMs: number;
	calledNext: boolean;
	error: string | null;
}
/** Policy-reported detail (cooperative opt-in via `trace()`). */
export interface PolicyTraceDetail {
	action: string;
	data?: Record<string, unknown>;
}
/** Combined baseline + optional detail for a single policy. */
export interface PolicyTraceEntry extends PolicyTraceBaseline {
	detail?: PolicyTraceDetail;
}
/** Full trace payload emitted as the `x-stoma-trace` response header. */
export interface PolicyTrace {
	requestId: string;
	traceId: string;
	route: string;
	totalMs: number;
	entries: PolicyTraceEntry[];
}
/**
 * A trace reporter function. Always callable - no-op when tracing is inactive.
 *
 * @param action - Human-readable action string (e.g. `"HIT"`, `"allowed"`).
 * @param data   - Optional structured context data.
 */
export type TraceReporter = (action: string, data?: Record<string, unknown>) => void;
/** Shared no-op reporter instance - zero overhead when tracing is off. */
export declare const noopTraceReporter: TraceReporter;
/**
 * Get a trace reporter for a specific policy.
 *
 * When tracing is active (`_stomaTraceRequested` is truthy), returns a
 * function that stores the detail on the context. When inactive, returns
 * {@link noopTraceReporter} - a no-op with zero overhead.
 *
 * @param c          - Hono request context.
 * @param policyName - Policy name used as the Map key.
 * @returns A {@link TraceReporter} - always callable.
 */
export declare function policyTrace(c: Context, policyName: string): TraceReporter;
/**
 * Fast-path check: is tracing requested for this request?
 *
 * @param c - Hono request context.
 * @returns `true` when the client requested tracing via `x-stoma-debug: trace`.
 */
export declare function isTraceRequested(c: Context): boolean;
/**
 * Zero-dependency debug logging for edge runtimes.
 *
 * Provides `debug`-style namespace-based logging without the `debug` npm
 * package (which relies on `process.env` / `localStorage` and doesn't work
 * reliably in Cloudflare Workers). Output goes to `console.debug()`, which
 * is captured by `wrangler tail` and Cloudflare Workers Logs.
 *
 * @module debug
 *
 * @example
 * ```ts
 * // In gateway config
 * createGateway({ debug: "stoma:policy:*", ... });
 *
 * // In a policy
 * const debug = getGatewayContext(c)?.debug("stoma:policy:cache");
 * debug?.("HIT", cacheKey);
 * // Output: [stoma:policy:cache] HIT GET:/api/users
 * ```
 */
/** A debug logging function - call with a message and optional structured data. */
export type DebugLogger = (message: string, ...args: unknown[]) => void;
/**
 * Policy type system - the building blocks of gateway pipelines.
 *
 * A {@link Policy} is a named middleware with priority ordering and
 * optional protocol-agnostic evaluation. Policies are composed into
 * pipelines at the global and route level, merged by name (route-level
 * wins), and sorted by priority ascending.
 *
 * The HTTP runtime uses {@link Policy.handler} (Hono middleware).
 * Non-HTTP runtimes (ext_proc, WebSocket) use {@link Policy.evaluate}.
 *
 * The {@link PolicyContext} provides request metadata (ID, timing, debug)
 * to policies at runtime via `getGatewayContext(c)`.
 *
 * @module policy-types
 */
/**
 * A Policy is a named middleware with priority ordering and optional
 * protocol-agnostic evaluation.
 *
 * - {@link handler} - HTTP runtime entry point (Hono middleware).
 *   Used by {@link createGateway}.
 * - {@link evaluate} - Protocol-agnostic entry point. Used by non-HTTP
 *   runtimes (ext_proc, WebSocket) to invoke the policy without Hono.
 * - {@link phases} - Which processing phases this policy participates in.
 *   Used by phase-based runtimes to skip irrelevant policies.
 * - {@link httpOnly} - Set to `true` for policies that can ONLY work with
 *   the HTTP protocol and don't make sense for ext_proc or WebSocket.
 */
export interface Policy {
	/** Unique policy name (e.g. "jwt-auth", "rate-limit") */
	name: string;
	/** The Hono middleware handler - HTTP runtime entry point. */
	handler: MiddlewareHandler;
	/** Policy priority - lower numbers execute first. Default: 100. */
	priority?: number;
	/**
	 * Protocol-agnostic evaluation entry point.
	 *
	 * Used by non-HTTP runtimes (ext_proc, WebSocket) to invoke this
	 * policy without Hono. The HTTP runtime ({@link createGateway}) uses
	 * {@link handler} directly and ignores this field.
	 *
	 * Policies that implement `evaluate` work across all runtimes.
	 * Policies that only implement `handler` are HTTP-only.
	 */
	evaluate?: PolicyEvaluator;
	/**
	 * Processing phases this policy participates in.
	 *
	 * Used by phase-based runtimes (ext_proc) to skip policies that don't
	 * apply to the current processing phase. For example, a JWT auth policy
	 * only needs `"request-headers"`, while a response transform policy
	 * needs `"response-headers"` and `"response-body"`.
	 *
	 * Default: `["request-headers"]` (most policies only inspect request headers).
	 */
	phases?: ProcessingPhase[];
	/**
	 * Set to `true` for policies that only work with the HTTP protocol.
	 *
	 * These policies rely on HTTP-specific concepts (Request/Response objects,
	 * specific headers, HTTP status codes, etc.) and cannot be meaningfully
	 * evaluated in other protocols like ext_proc or WebSocket.
	 *
	 * Examples:
	 * - `cors` - uses HTTP-specific `Access-Control-*` headers
	 * - `ssl-enforce` - HTTP-only protocol concept
	 * - `proxy` - HTTP-to-HTTP forwarding
	 * - `mock` - returns HTTP Response objects
	 *
	 * Tooling can use this flag to:
	 * - Skip these policies when generating docs for non-HTTP runtimes
	 * - Warn if an HTTP-only policy is used in a non-HTTP gateway config
	 */
	httpOnly?: true;
}
/** Base configuration shared by all policies */
export interface PolicyConfig {
	/** Skip this policy when condition returns true */
	skip?: (c: unknown) => boolean | Promise<boolean>;
}
/** Context available to policies during execution */
export interface PolicyContext {
	/** Unique request ID for tracing */
	requestId: string;
	/** Timestamp when the request entered the gateway */
	startTime: number;
	/** Gateway name */
	gatewayName: string;
	/** Matched route path pattern */
	routePath: string;
	/** W3C Trace Context - 32-hex trace ID (propagated or generated). */
	traceId: string;
	/** W3C Trace Context - 16-hex span ID for this gateway request. */
	spanId: string;
	/**
	 * Get a debug logger for the given namespace.
	 * Returns a no-op when debug is disabled (zero overhead).
	 *
	 * @example
	 * ```ts
	 * const ctx = getGatewayContext(c);
	 * const debug = ctx?.debug("stoma:policy:cache");
	 * debug?.("HIT", cacheKey);
	 * ```
	 */
	debug: (namespace: string) => DebugLogger;
	/** Runtime adapter providing store implementations and runtime-specific capabilities. */
	adapter?: GatewayAdapter;
}
/**
 * Circuit breaker policy - protect upstream services from cascading failures.
 *
 * Implements the three-state circuit breaker pattern (closed / open / half-open)
 * with pluggable state storage via {@link CircuitBreakerStore}.
 *
 * @module circuit-breaker
 */
/** The three states of the circuit breaker state machine. */
export type CircuitState = "closed" | "open" | "half-open";
/** Point-in-time snapshot of a circuit's state and counters. */
export interface CircuitBreakerSnapshot {
	/** Current circuit state. */
	state: CircuitState;
	/** Number of consecutive failures since last reset. */
	failureCount: number;
	/** Number of successful probes in half-open state. */
	successCount: number;
	/** Epoch ms of the most recent failure. `0` if no failures recorded. */
	lastFailureTime: number;
	/** Epoch ms of the most recent state transition. */
	lastStateChange: number;
}
/**
 * Pluggable storage backend for circuit breaker state.
 *
 * Implement this interface to store circuit state in Durable Objects,
 * KV, or any shared datastore for multi-instance deployments.
 */
export interface CircuitBreakerStore {
	/** Read the current snapshot for a circuit key. */
	getState(key: string): Promise<CircuitBreakerSnapshot>;
	/** Record a successful request and return the updated snapshot. */
	recordSuccess(key: string): Promise<CircuitBreakerSnapshot>;
	/** Record a failed request and return the updated snapshot. */
	recordFailure(key: string): Promise<CircuitBreakerSnapshot>;
	/** Transition the circuit to a new state and return the updated snapshot. */
	transition(key: string, to: CircuitState): Promise<CircuitBreakerSnapshot>;
	/** Fully reset a circuit, removing all state. */
	reset(key: string): Promise<void>;
	/** Optional cleanup - release timers, close connections, etc. */
	destroy?(): void;
}
export declare class InMemoryCircuitBreakerStore implements CircuitBreakerStore {
	private circuits;
	private getOrCreate;
	getState(key: string): Promise<CircuitBreakerSnapshot>;
	recordSuccess(key: string): Promise<CircuitBreakerSnapshot>;
	recordFailure(key: string): Promise<CircuitBreakerSnapshot>;
	transition(key: string, to: CircuitState): Promise<CircuitBreakerSnapshot>;
	reset(key: string): Promise<void>;
	/** Remove all circuits (for testing) */
	clear(): void;
	/** Release all state. */
	destroy(): void;
}
export interface CircuitBreakerConfig extends PolicyConfig {
	/** Number of failures before opening the circuit. Default: 5. */
	failureThreshold?: number;
	/** Time in ms before transitioning from open  half-open. Default: 30000. */
	resetTimeoutMs?: number;
	/** Max concurrent probes allowed in half-open state. Default: 1. */
	halfOpenMax?: number;
	/** Status codes considered failures. Default: [500, 502, 503, 504]. */
	failureOn?: number[];
	/** Storage backend. Default: InMemoryCircuitBreakerStore. */
	store?: CircuitBreakerStore;
	/** Key extractor. Default: request URL pathname. */
	key?: (c: Context) => string;
	/** HTTP status code when the circuit is open. Default: 503. */
	openStatusCode?: number;
	/**
	 * Callback invoked on every state transition.
	 *
	 * Called via `safeCall` so errors are swallowed - a failing callback
	 * never blocks traffic. Useful for metrics, logging, or alerting.
	 *
	 * @param key - The circuit key that transitioned.
	 * @param from - The previous circuit state.
	 * @param to - The new circuit state.
	 */
	onStateChange?: (key: string, from: CircuitState, to: CircuitState) => void | Promise<void>;
}
/**
 * Protect upstream services by breaking the circuit on repeated failures.
 *
 * Implements the three-state circuit breaker pattern:
 * - **Closed** - requests flow normally; failures are counted.
 * - **Open** - requests are immediately rejected with 503; a `Retry-After` header is set.
 * - **Half-open** - a limited number of probe requests are allowed through to test recovery.
 *
 * State transitions: `closed  open` when failures reach the threshold,
 * `open  half-open` after the reset timeout, `half-open  closed` on
 * probe success or `half-open  open` on probe failure.
 *
 * @param config - Failure threshold, reset timeout, and storage backend.
 * @returns A {@link Policy} at priority 30.
 *
 * @example
 * ```ts
 * // Open after 5 failures, retry after 30s
 * circuitBreaker();
 *
 * // Tighter threshold with custom store
 * circuitBreaker({
 *   failureThreshold: 3,
 *   resetTimeoutMs: 10_000,
 *   failureOn: [500, 502, 503],
 *   store: new InMemoryCircuitBreakerStore(),
 * });
 *
 * // With state change notifications
 * circuitBreaker({
 *   failureThreshold: 5,
 *   onStateChange: (key, from, to) => {
 *     console.log(`Circuit ${key}: ${from} -> ${to}`);
 *   },
 * });
 * ```
 */
export declare function circuitBreaker(config?: CircuitBreakerConfig): Policy;
/**
 * Response caching policy with pluggable storage backends.
 *
 * @module cache
 */
/** Pluggable cache storage backend */
export interface CacheStore {
	/** Retrieve a cached response by key. Returns null on miss. */
	get(key: string): Promise<Response | null>;
	/** Store a response under key with a TTL in seconds. */
	put(key: string, response: Response, ttlSeconds: number): Promise<void>;
	/** Delete a cached entry. Returns true if something was removed. */
	delete(key: string): Promise<boolean>;
	/** Optional cleanup - clear expired entries, release resources. */
	destroy?(): void;
}
/** Options for the in-memory cache store. */
export interface InMemoryCacheStoreOptions {
	/** Maximum number of cached entries. When exceeded, the oldest entry is evicted (LRU). */
	maxEntries?: number;
}
export declare class InMemoryCacheStore implements CacheStore {
	private entries;
	private maxEntries;
	constructor(options?: InMemoryCacheStoreOptions);
	get(key: string): Promise<Response | null>;
	put(key: string, response: Response, ttlSeconds: number): Promise<void>;
	delete(key: string): Promise<boolean>;
	/** Remove all entries (for testing) */
	clear(): void;
	/** Current number of entries (for testing/inspection) */
	get size(): number;
	/** Release all cached entries. */
	destroy(): void;
}
export interface CacheConfig extends PolicyConfig {
	/** Cache TTL in seconds. Default: 300. */
	ttlSeconds?: number;
	/** HTTP methods to cache. Default: ["GET"]. Case-insensitive. */
	methods?: string[];
	/** Custom cache key builder. Supports async for body-based keys. Default: method + url (+ body hash for POST/PUT/PATCH). */
	cacheKeyFn?: (c: Context) => string | Promise<string>;
	/** Only cache responses with these status codes. When set, responses with other statuses are not cached (5xx is always excluded regardless). */
	cacheableStatuses?: number[];
	/** Vary cache key on these request headers. */
	varyHeaders?: string[];
	/** Storage backend. Default: InMemoryCacheStore. */
	store?: CacheStore;
	/** Respect upstream Cache-Control directives. Default: true. */
	respectCacheControl?: boolean;
	/** Response header name for cache status (HIT/MISS/BYPASS/SKIP). Default: `"x-cache"`. */
	cacheStatusHeader?: string;
	/** Cache-Control directives that trigger a bypass. Matched at the directive level, not substring. Default: `["no-store", "no-cache"]`. */
	bypassDirectives?: string[];
}
/**
 * Cache upstream responses to reduce latency and load.
 *
 * Sets a cache status header on **every** response:
 * - `HIT` - served from cache
 * - `MISS` - fetched from upstream, now cached
 * - `BYPASS` - upstream Cache-Control directive prevented caching
 * - `SKIP` - not eligible for caching (wrong method or server error status)
 *
 * Server error responses (5xx) are never cached. Store failures degrade
 * gracefully via {@link safeCall} - a broken cache store never crashes the
 * request.
 *
 * For methods with a request body (POST, PUT, PATCH), the default cache key
 * includes a SHA-256 hash of the body to prevent key collisions across
 * different payloads.
 *
 * @param config - Cache TTL, storage backend, and key strategy. All fields optional.
 * @returns A {@link Policy} at priority 40.
 *
 * @example
 * ```ts
 * // Simple 5-minute in-memory cache for GET requests
 * cache({ ttlSeconds: 300 });
 *
 * // Cache with Vary on Accept-Language and custom store
 * cache({
 *   ttlSeconds: 600,
 *   varyHeaders: ["accept-language"],
 *   store: new CacheApiCacheStore(caches.default),
 * });
 * ```
 */
export declare function cache(config?: CacheConfig): Policy;
export interface RateLimitConfig extends PolicyConfig {
	/** Maximum requests per window */
	max: number;
	/** Time window in seconds. Default: 60. */
	windowSeconds?: number;
	/** Key extractor - determines the rate limit bucket. Default: client IP. */
	keyBy?: (c: Context) => string | Promise<string>;
	/** Storage backend for counters */
	store?: RateLimitStore;
	/** Response status code when limited. Default: 429. */
	statusCode?: number;
	/** Custom response body when limited */
	message?: string;
	/** Ordered list of headers to inspect for the client IP (when `keyBy` is not set). Default: `["cf-connecting-ip", "x-forwarded-for"]`. */
	ipHeaders?: string[];
}
/** Pluggable storage backend for rate limit counters */
export interface RateLimitStore {
	/** Increment the counter for a key, returning the new count and TTL */
	increment(key: string, windowSeconds: number): Promise<{
		count: number;
		resetAt: number;
	}>;
	/** Optional: cleanup resources (like intervals) used by the store */
	destroy?(): void;
}
/** Default in-memory rate limit store */
export interface InMemoryRateLimitStoreOptions {
	/** Maximum number of unique keys to prevent memory exhaustion. Default: 100000. */
	maxKeys?: number;
	/** Cleanup interval in ms for expired entries. Default: 60000. */
	cleanupIntervalMs?: number;
}
/**
 * Rate limit requests with pluggable storage backends.
 *
 * Defaults to client IP extraction via `CF-Connecting-IP` or `X-Forwarded-For`.
 * Sets standard `X-RateLimit-*` response headers on every request and
 * throws a 429 when the limit is exceeded.
 *
 * @param config - Rate limit settings. `max` is required; other fields have sensible defaults.
 * @returns A {@link Policy} at priority 20 (runs after auth).
 *
 * @example
 * ```ts
 * // 100 requests per minute per IP (in-memory)
 * rateLimit({ max: 100 });
 *
 * // Custom key + Cloudflare KV store
 * rateLimit({
 *   max: 50,
 *   windowSeconds: 300,
 *   keyBy: (c) => c.req.header("x-user-id") ?? "anonymous",
 *   store: new KVRateLimitStore(env.RATE_LIMIT_KV),
 * });
 * ```
 */
export declare const rateLimit: (config: RateLimitConfig) => Policy;
/** Bag of optional store implementations and runtime capabilities for a given runtime. */
export interface GatewayAdapter {
	rateLimitStore?: RateLimitStore;
	circuitBreakerStore?: CircuitBreakerStore;
	cacheStore?: CacheStore;
	/** Schedule background work that outlives the response (e.g. Cloudflare `executionCtx.waitUntil`). */
	waitUntil?: (promise: Promise<unknown>) => void;
	/** Dispatch a request to a named service binding or sidecar. */
	dispatchBinding?: (service: string, request: Request) => Promise<Response>;
}
/**
 * Protocol-agnostic types for multi-runtime policy evaluation.
 *
 * These types define the contract between policy logic and protocol runtimes.
 * The HTTP runtime (Hono-based) uses {@link Policy.handler} directly.
 * Non-HTTP runtimes (ext_proc, WebSocket) use {@link Policy.evaluate}.
 *
 * **Architecture:**
 * ```
 *                    
 *                          Policy Definitions      
 *                      name, priority, evaluate()  
 *                        (protocol-agnostic)       
 *                    
 *                               
 *              
 *                                              
 *      
 *      HTTP Runtime      ext_proc      WebSocket   
 *      (Hono-based)      (gRPC)        Runtime     
 *     createGateway()                              
 *      
 * ```
 *
 * Hono powers the HTTP runtime. Other runtimes (ext_proc via gRPC,
 * WebSocket) are peer implementations - same policy definitions,
 * different wire protocols.
 *
 * @module protocol
 */
/**
 * Lifecycle phases a policy can participate in.
 *
 * Maps to:
 * - **HTTP**: `request-headers`  `request-body`  `response-headers`  `response-body`
 *   (trailers are N/A for HTTP/1.1; available in HTTP/2)
 * - **ext_proc**: All 6 phases - Envoy sends each as a `ProcessingRequest`
 * - **WebSocket**: `request-headers` (upgrade)  `request-body` (per-message)
 */
export type ProcessingPhase = "request-headers" | "request-body" | "request-trailers" | "response-headers" | "response-body" | "response-trailers";
/** Identifies the protocol runtime invoking a policy. */
export type ProtocolType = "http" | "grpc" | "websocket";
/**
 * Protocol-agnostic view of what's being processed.
 *
 * Constructed by each runtime from its native message type:
 * - HTTP runtime builds it from Hono's `Context`
 * - ext_proc runtime builds it from gRPC `ProcessingRequest`
 * - WebSocket runtime builds it from the upgrade request or message frame
 */
export interface PolicyInput {
	/** Current processing phase. */
	phase: ProcessingPhase;
	/**
	 * Request method or action.
	 *
	 * - HTTP: `"GET"`, `"POST"`, etc.
	 * - gRPC: Full method name, e.g. `"users.UserService/GetUser"`
	 */
	method: string;
	/**
	 * Request path or resource identifier.
	 *
	 * - HTTP: URL path, e.g. `"/users/123"`
	 * - gRPC: Service path, e.g. `"/users.UserService/GetUser"`
	 */
	path: string;
	/**
	 * Headers (HTTP) or metadata (gRPC).
	 *
	 * Treat as read-only - express modifications via
	 * {@link PolicyResult} mutations, not by mutating this object.
	 */
	headers: Headers;
	/**
	 * Client IP address, extracted by the runtime from protocol-specific
	 * sources (e.g. `CF-Connecting-IP`, `X-Forwarded-For`, gRPC peer address).
	 */
	clientIp?: string;
	/**
	 * Message body, present only during body phases.
	 *
	 * May be the full buffered body or a streaming chunk, depending on
	 * the runtime's buffering mode.
	 */
	body?: ArrayBuffer | string;
	/**
	 * Trailers, present only during trailer phases.
	 *
	 * Relevant for gRPC (which uses trailers for status codes and error
	 * details) and HTTP/2.
	 */
	trailers?: Headers;
	/**
	 * Cross-policy attribute bag.
	 *
	 * Policies read attributes set by upstream policies and set
	 * attributes for downstream policies via {@link AttributeMutation}.
	 * Runtime-populated attributes use the `runtime.*` namespace
	 * (e.g. `runtime.matched_route`, `runtime.upstream_name`).
	 */
	attributes: Map<string, unknown>;
	/** The protocol runtime that constructed this input. */
	protocol: ProtocolType;
}
/**
 * The outcome of a policy evaluation. Discriminated on `action`.
 *
 * - `"continue"` - Allow processing to continue, optionally with mutations.
 * - `"reject"` - Reject with a structured error response.
 * - `"immediate-response"` - Short-circuit with a complete non-error response.
 */
export type PolicyResult = PolicyContinue | PolicyReject | PolicyImmediateResponse;
/**
 * Allow processing to continue, optionally with mutations.
 *
 * Equivalent to `await next()` in HTTP middleware, or ext_proc
 * `CommonResponse` with header/body mutations.
 */
export interface PolicyContinue {
	action: "continue";
	/** Mutations to apply before continuing to the next policy or upstream. */
	mutations?: Mutation[];
}
/**
 * Reject the request with a structured error.
 *
 * Equivalent to `throw new GatewayError(...)` in HTTP middleware, or
 * ext_proc `ImmediateResponse` with an error status code.
 */
export interface PolicyReject {
	action: "reject";
	/** HTTP status code (or gRPC status equivalent). */
	status: number;
	/** Machine-readable error code (e.g. `"rate_limited"`, `"unauthorized"`). */
	code: string;
	/** Human-readable error message. */
	message: string;
	/** Additional headers to include on the error response. */
	headers?: Record<string, string>;
}
/**
 * Short-circuit with a complete non-error response.
 *
 * Used for cache hits, mock responses, redirects - cases where the
 * policy provides the full response and upstream should not be called.
 *
 * Equivalent to returning a `Response` without calling `next()` in
 * HTTP middleware, or ext_proc `ImmediateResponse` with a success status.
 */
export interface PolicyImmediateResponse {
	action: "immediate-response";
	/** HTTP status code for the response. */
	status: number;
	/** Response headers. */
	headers?: Record<string, string>;
	/** Response body. */
	body?: string | ArrayBuffer;
}
/**
 * A discrete modification to apply to the request or response.
 * Discriminated on `type`.
 *
 * Designed to map cleanly to ext_proc `HeaderMutation`, `BodyMutation`,
 * and Envoy dynamic metadata.
 */
export type Mutation = HeaderMutation | BodyMutation | StatusMutation | AttributeMutation;
/** Add, remove, or append a header value. */
export interface HeaderMutation {
	type: "header";
	/** `"set"` replaces, `"remove"` deletes, `"append"` adds without replacing. */
	op: "set" | "remove" | "append";
	/** Header name (case-insensitive). */
	name: string;
	/** Header value. Required for `"set"` and `"append"`, ignored for `"remove"`. */
	value?: string;
}
/** Replace or clear the message body. */
export interface BodyMutation {
	type: "body";
	/** `"replace"` substitutes the body, `"clear"` removes it entirely. */
	op: "replace" | "clear";
	/** New body content. Required for `"replace"`, ignored for `"clear"`. */
	content?: string | ArrayBuffer;
}
/**
 * Modify the response status code.
 *
 * Only meaningful during response processing phases. Ignored during
 * request phases.
 */
export interface StatusMutation {
	type: "status";
	/** New HTTP status code. */
	code: number;
}
/**
 * Set a cross-policy attribute.
 *
 * Downstream policies see this value in {@link PolicyInput.attributes}.
 * In ext_proc, this maps to Envoy dynamic metadata.
 */
export interface AttributeMutation {
	type: "attribute";
	/** Attribute key. Use namespaced keys (e.g. `"auth.user_id"`) to avoid collisions. */
	key: string;
	/** Attribute value. */
	value: unknown;
}
/**
 * Runtime-facing evaluation context provided to policy evaluators.
 *
 * This is the base context without typed config - runtimes construct
 * this from their native request representation. The policy SDK
 * ({@link definePolicy}) extends this with a typed `config` field
 * via `PolicyEvalHandlerContext`.
 */
export interface PolicyEvalContext {
	/** Debug logger pre-namespaced to `stoma:policy:{name}`. Always callable. */
	debug: DebugLogger;
	/** Trace reporter - always callable, no-op when tracing is not active. */
	trace: TraceReporter;
	/** Unique request ID for correlation. */
	requestId: string;
	/** W3C trace ID (32-hex). */
	traceId: string;
	/** Runtime adapter (stores, waitUntil, etc.). */
	adapter?: GatewayAdapter;
}
/**
 * Protocol-agnostic policy evaluation entry point.
 *
 * Implement this on a {@link Policy} to make it work across all runtimes
 * (HTTP, ext_proc, WebSocket). The HTTP runtime uses {@link Policy.handler}
 * directly - `evaluate` is consumed by non-HTTP runtimes.
 *
 * Runtimes call `onRequest` for request-phase processing and `onResponse`
 * for response-phase processing. A policy can implement one or both.
 *
 * @example
 * ```ts
 * // Protocol-agnostic JWT verification
 * const evaluator: PolicyEvaluator = {
 *   onRequest: async (input, ctx) => {
 *     const auth = input.headers.get("authorization");
 *     if (!auth) return { action: "reject", status: 401, code: "unauthorized", message: "Missing token" };
 *     // ... verify token ...
 *     return { action: "continue", mutations: [
 *       { type: "header", op: "set", name: "x-user-id", value: claims.sub },
 *     ]};
 *   },
 * };
 * ```
 */
/**
 * Current `evaluate` coverage across policy categories:
 * - auth: 6/9 (jwt-auth, api-key-auth, basic-auth, oauth2, rbac, jws)
 * - traffic: 5/13 (rate-limit, ip-filter, cache, geo-ip-filter, ssl-enforce)
 * - transform: 5/7 (cors, assign-attributes, assign-content, request-transform, response-transform)
 * - observability: 0/4
 * - resilience: 0/4
 *
 * Total: 16/38 policies have evaluate support. The remaining policies
 * will gain evaluate implementations as non-HTTP runtimes (ext_proc, WebSocket)
 * are built out. See PLAN.md Phase 5 for the ext_proc roadmap.
 */
export interface PolicyEvaluator {
	/**
	 * Evaluate during request processing phases.
	 *
	 * Called for: `request-headers`, `request-body`, `request-trailers`.
	 */
	onRequest?: (input: PolicyInput, ctx: PolicyEvalContext) => Promise<PolicyResult>;
	/**
	 * Evaluate during response processing phases.
	 *
	 * Called for: `response-headers`, `response-body`, `response-trailers`.
	 */
	onResponse?: (input: PolicyInput, ctx: PolicyEvalContext) => Promise<PolicyResult>;
}
/**
 * Error handling utilities for the stoma gateway.
 *
 * {@link GatewayError} is thrown by policies and core code to produce
 * structured JSON error responses. The gateway's `onError` handler catches
 * these and converts them via {@link errorToResponse}. Unexpected errors
 * fall through to {@link defaultErrorResponse}.
 *
 * @module errors
 */
/**
 * Structured gateway error with HTTP status code, machine-readable code,
 * and optional response headers (e.g. `Retry-After`, `X-RateLimit-*`).
 *
 * Throw this from policies or handlers to produce a structured JSON error
 * response. The gateway error handler catches it automatically.
 *
 * @example
 * ```ts
 * throw new GatewayError(429, "rate_limited", "Too many requests", {
 *   "retry-after": "60",
 * });
 * // Produces: { "error": "rate_limited", "message": "Too many requests", "statusCode": 429 }
 * ```
 */
export declare class GatewayError extends Error {
	readonly statusCode: number;
	readonly code: string;
	/** Optional headers to include in the error response (e.g. rate-limit headers) */
	readonly headers?: Record<string, string>;
	constructor(statusCode: number, code: string, message: string, headers?: Record<string, string>);
}
/** Standard JSON error response shape returned by all gateway errors. */
export interface ErrorResponse {
	/** Machine-readable error code (e.g. `"rate_limited"`, `"unauthorized"`). */
	error: string;
	/** Human-readable error description. */
	message: string;
	/** HTTP status code (e.g. 401, 429, 503). */
	statusCode: number;
	/** Request ID for tracing, when available. */
	requestId?: string;
}
/**
 * Build a JSON {@link Response} from a {@link GatewayError}.
 *
 * Merges any custom headers from the error (e.g. `Retry-After`) into the
 * response. Includes the request ID when available for tracing.
 *
 * @param error - The gateway error to convert.
 * @param requestId - Optional request ID to include in the response body.
 * @returns A `Response` with JSON body and appropriate status code.
 */
export declare function errorToResponse(error: GatewayError, requestId?: string): Response;
/**
 * Produce a generic 500 error response for unexpected (non-{@link GatewayError}) errors.
 *
 * Used by the global error handler when an unrecognized error reaches the
 * gateway boundary. Does not leak internal error details.
 *
 * @param requestId - Optional request ID to include in the response body.
 * @returns A 500 `Response` with a generic error message.
 */
export declare function defaultErrorResponse(requestId?: string, message?: string): Response;
/**
 * Pluggable metrics collection for the gateway pipeline.
 *
 * Defines the {@link MetricsCollector} interface and provides an
 * {@link InMemoryMetricsCollector} for testing and development.
 * The {@link toPrometheusText} function serializes a snapshot to
 * Prometheus text exposition format.
 *
 * @module metrics
 */
/** A single tagged metric data point. */
export interface TaggedValue {
	value: number;
	tags?: Record<string, string>;
}
/** A histogram data point with accumulated values. */
export interface HistogramEntry {
	values: number[];
	tags?: Record<string, string>;
}
/** Point-in-time snapshot of all collected metrics. */
export interface MetricsSnapshot {
	counters: Record<string, TaggedValue[]>;
	histograms: Record<string, HistogramEntry[]>;
	gauges: Record<string, TaggedValue[]>;
}
/**
 * Pluggable metrics collector interface.
 *
 * Implementations can ship metrics to Prometheus, Datadog, CloudWatch,
 * or any other backend. The gateway pipeline records request counts,
 * latencies, and error rates through this interface.
 */
export interface MetricsCollector {
	/** Increment a counter by `value` (default 1). */
	increment(name: string, value?: number, tags?: Record<string, string>): void;
	/** Record a histogram observation. */
	histogram(name: string, value: number, tags?: Record<string, string>): void;
	/** Set a gauge to an absolute value. */
	gauge(name: string, value: number, tags?: Record<string, string>): void;
	/** Return a point-in-time snapshot of all metrics. */
	snapshot(): MetricsSnapshot;
	/** Reset all metrics to zero. */
	reset(): void;
}
/**
 * In-memory metrics collector for testing, development, and admin API.
 *
 * Accumulates counters, histograms, and gauges in plain arrays/maps.
 * Not intended for high-throughput production use - prefer shipping
 * metrics to a dedicated backend for production workloads.
 */
export declare class InMemoryMetricsCollector implements MetricsCollector {
	private counters;
	private histograms;
	private gauges;
	increment(name: string, value?: number, tags?: Record<string, string>): void;
	histogram(name: string, value: number, tags?: Record<string, string>): void;
	gauge(name: string, value: number, tags?: Record<string, string>): void;
	snapshot(): MetricsSnapshot;
	reset(): void;
}
/**
 * Serialize a metrics snapshot to Prometheus text exposition format.
 *
 * Produces lines like:
 * ```
 * gateway_requests_total{method="GET",status="200"} 42
 * gateway_request_duration_ms_sum{method="GET"} 1234
 * gateway_request_duration_ms_count{method="GET"} 10
 * ```
 *
 * @param snapshot - The metrics snapshot to serialize.
 * @returns Prometheus text exposition format string.
 */
export declare function toPrometheusText(snapshot: MetricsSnapshot): string;
/**
 * Lightweight OpenTelemetry-compatible tracing for edge runtimes.
 *
 * Provides span creation, OTLP/HTTP JSON export via `fetch()`, and
 * head-based sampling - all without any runtime dependencies beyond
 * the Web Platform APIs available in Cloudflare Workers.
 *
 * Follows the OTel data model but uses own lightweight types to avoid
 * pulling in `@opentelemetry/api` (which is not edge-compatible).
 *
 * @module tracing
 */
export type SpanKind = "SERVER" | "CLIENT" | "INTERNAL";
export type SpanStatusCode = "UNSET" | "OK" | "ERROR";
/** An immutable representation of a completed span. */
export interface ReadableSpan {
	traceId: string;
	spanId: string;
	parentSpanId?: string;
	name: string;
	kind: SpanKind;
	startTimeMs: number;
	endTimeMs: number;
	attributes: Record<string, string | number | boolean>;
	status: {
		code: SpanStatusCode;
		message?: string;
	};
	events: SpanEvent[];
}
/** A timestamped event recorded during a span's lifetime. */
export interface SpanEvent {
	name: string;
	timeMs: number;
	attributes?: Record<string, string | number | boolean>;
}
/**
 * Pluggable span exporter interface.
 *
 * Implementations ship completed spans to a backend (OTLP collector,
 * console, or any custom destination). Export is expected to be called
 * via `waitUntil()` so it does not block the response.
 */
export interface SpanExporter {
	export(spans: ReadableSpan[]): Promise<void>;
	shutdown?(): Promise<void>;
}
/** Configuration for gateway-level tracing. */
export interface TracingConfig {
	exporter: SpanExporter;
	serviceName?: string;
	serviceVersion?: string;
	/** Head-based sampling rate [0.0, 1.0]. Default: 1.0 */
	sampleRate?: number;
}
/**
 * OTel semantic convention attribute keys (HTTP subset).
 *
 * Uses the stable HTTP semconv names from the OpenTelemetry specification.
 * @see https://opentelemetry.io/docs/specs/semconv/http/
 */
export declare const SemConv: {
	readonly HTTP_METHOD: "http.request.method";
	readonly HTTP_ROUTE: "http.route";
	readonly HTTP_STATUS_CODE: "http.response.status_code";
	readonly URL_PATH: "url.path";
	readonly SERVER_ADDRESS: "server.address";
};
/**
 * Mutable span builder - accumulates attributes, events, and status
 * during a request lifecycle. Call {@link end} to produce an immutable
 * {@link ReadableSpan}.
 */
export declare class SpanBuilder {
	readonly name: string;
	readonly kind: SpanKind;
	readonly traceId: string;
	readonly spanId: string;
	readonly parentSpanId?: string | undefined;
	readonly startTimeMs: number;
	private _attributes;
	private _events;
	private _status;
	private _endTimeMs?;
	constructor(name: string, kind: SpanKind, traceId: string, spanId: string, parentSpanId?: string | undefined, startTimeMs?: number);
	/** Set a single attribute. Chainable. */
	setAttribute(key: string, value: string | number | boolean): this;
	/** Record a timestamped event with optional attributes. Chainable. */
	addEvent(name: string, attributes?: Record<string, string | number | boolean>): this;
	/** Set the span status. Chainable. */
	setStatus(code: SpanStatusCode, message?: string): this;
	/**
	 * Finalize the span and return an immutable {@link ReadableSpan}.
	 *
	 * Sets `endTimeMs` on first call; subsequent calls return the same
	 * snapshot with defensive copies of mutable fields.
	 */
	end(): ReadableSpan;
}
/**
 * OTLP/HTTP JSON span exporter.
 *
 * Ships spans to an OpenTelemetry Collector (or compatible endpoint)
 * using `fetch()` with the OTLP JSON encoding. Designed for edge
 * runtimes - no gRPC, no protobuf, no Node.js dependencies.
 *
 * Export calls should be dispatched via `waitUntil()` so they do not
 * block the response path.
 */
export declare class OTLPSpanExporter implements SpanExporter {
	private readonly endpoint;
	private readonly headers;
	private readonly timeoutMs;
	private readonly serviceName;
	private readonly serviceVersion?;
	constructor(config: {
		endpoint: string;
		headers?: Record<string, string>;
		timeoutMs?: number;
		serviceName?: string;
		serviceVersion?: string;
	});
	export(spans: ReadableSpan[]): Promise<void>;
}
/**
 * Console span exporter for development and debugging.
 *
 * Logs each span to `console.debug()` with a compact one-line format
 * showing name, kind, duration, trace/span IDs, and status.
 */
export declare class ConsoleSpanExporter implements SpanExporter {
	export(spans: ReadableSpan[]): Promise<void>;
}
/**
 * Core type definitions for the stoma gateway.
 *
 * All gateway configuration is expressed through these types. The main entry
 * point is {@link GatewayConfig}, which composes {@link RouteConfig},
 * {@link PipelineConfig}, and {@link UpstreamConfig} into a fully declarative
 * gateway specification.
 *
 * @module types
 */
/**
 * Top-level gateway configuration.
 *
 * @typeParam TBindings - Worker bindings type (e.g. your `Env` interface).
 *   Defaults to `Record<string, unknown>` so `service` on
 *   {@link ServiceBindingUpstream} accepts any string. When you pass your
 *   own Env type, `service` autocompletes to valid binding names.
 */
export interface GatewayConfig<TBindings = Record<string, unknown>> {
	/** Gateway name, used in logs and metrics */
	name?: string;
	/** Base path prefix for all routes (e.g. "/api") */
	basePath?: string;
	/** Route definitions */
	routes: RouteConfig<TBindings>[];
	/** Global policies applied to all routes */
	policies?: Policy[];
	/** Global error handler */
	onError?: (error: Error, c: Context) => Response | Promise<Response>;
	/**
	 * Enable internal debug logging for gateway operators.
	 *
	 * - `true` - log all namespaces
	 * - `false` / `undefined` - disabled (default, zero overhead)
	 * - `string` - comma-separated glob patterns to filter namespaces
	 *
	 * Namespaces: `stoma:gateway`, `stoma:pipeline`, `stoma:upstream`,
	 * `stoma:policy:*` (e.g. `stoma:policy:cache`, `stoma:policy:jwt-auth`)
	 *
	 * Output goes to `console.debug()` which is captured by `wrangler tail`
	 * and Cloudflare Workers Logs.
	 *
	 * @example
	 * ```ts
	 * createGateway({ debug: true, ... })                         // everything
	 * createGateway({ debug: "stoma:gateway,stoma:upstream", ... }) // core only
	 * createGateway({ debug: "stoma:policy:*", ... })              // policies only
	 * ```
	 */
	debug?: boolean | string;
	/** Response header name for the request ID. Default: `"x-request-id"`. */
	requestIdHeader?: string;
	/**
	 * Default HTTP methods for routes that don't specify `methods`.
	 * Default: `["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"]`.
	 */
	defaultMethods?: HttpMethod[];
	/** Default error message for unexpected (non-GatewayError) errors. Default: `"An unexpected error occurred"`. */
	defaultErrorMessage?: string;
	/** Default priority for policies that don't specify one. Default: `100`. */
	defaultPolicyPriority?: number;
	/**
	 * Runtime adapter providing store implementations and runtime-specific capabilities
	 * (e.g. `waitUntil`, `dispatchBinding`). Created via adapter factories like
	 * `cloudflareAdapter()`, `memoryAdapter()`, etc.
	 */
	adapter?: GatewayAdapter;
	/**
	 * Admin introspection API. Exposes `___gateway/*` routes for operational visibility.
	 *
	 * - `true` - enable with defaults (no auth)
	 * - `AdminConfig` object - full customization
	 * - `false` / `undefined` - disabled (default)
	 */
	admin?: boolean | AdminConfig;
	/**
	 * Enable client-requested debug headers.
	 *
	 * When enabled, clients can send an `x-stoma-debug` request header listing
	 * the debug values they want returned as response headers. Policies contribute
	 * debug data via {@link setDebugHeader} from the SDK - only requested values
	 * are included in the response.
	 *
	 * - `true` - enable with defaults
	 * - `DebugHeadersConfig` - full customization (request header name, allowlist)
	 * - `false` / `undefined` - disabled (default, zero overhead)
	 *
	 * @example
	 * ```
	 * // Client request:
	 * GET /api/users
	 * x-stoma-debug: x-stoma-cache-key, x-stoma-cache-ttl
	 *
	 * // Response includes:
	 * x-stoma-cache-key: GET:http://example.com/api/users
	 * x-stoma-cache-ttl: 300
	 * ```
	 */
	debugHeaders?: boolean | DebugHeadersConfig;
	/**
	 * OpenTelemetry-compatible distributed tracing.
	 *
	 * When configured, the gateway creates a root SERVER span per request,
	 * INTERNAL child spans per policy, and CLIENT child spans for upstream
	 * calls. Spans are exported asynchronously via `adapter.waitUntil()`.
	 *
	 * Zero overhead when not configured - no span objects are allocated.
	 *
	 * @example
	 * ```ts
	 * import { createGateway, OTLPSpanExporter } from "@homegrower-club/stoma";
	 *
	 * createGateway({
	 *   tracing: {
	 *     exporter: new OTLPSpanExporter({ endpoint: "https://otel-collector/v1/traces" }),
	 *     serviceName: "my-api",
	 *     sampleRate: 0.1,
	 *   },
	 *   // ...routes
	 * });
	 * ```
	 */
	tracing?: TracingConfig;
}
/** Configuration for client-requested debug headers. */
export interface DebugHeadersConfig {
	/** Request header name clients use to request debug values. Default: `"x-stoma-debug"`. */
	requestHeader?: string;
	/** Allowlist of debug header names clients can request. When set, only these headers are emitted. Default: all. */
	allow?: string[];
}
/**
 * Individual route configuration.
 *
 * @typeParam TBindings - Worker bindings type, propagated from {@link GatewayConfig}.
 */
export interface RouteConfig<TBindings = Record<string, unknown>> {
	/** Route path pattern (Hono syntax, e.g. "/users/:id") */
	path: string;
	/** Allowed HTTP methods. Defaults to all. */
	methods?: HttpMethod[];
	/** Pipeline to process this route */
	pipeline: PipelineConfig<TBindings>;
	/** Route-level metadata for logging/observability */
	metadata?: Record<string, unknown>;
}
/**
 * Pipeline: ordered chain of policies leading to an upstream.
 *
 * @typeParam TBindings - Worker bindings type, propagated from {@link RouteConfig}.
 */
export interface PipelineConfig<TBindings = Record<string, unknown>> {
	/** Policies executed in order before the upstream */
	policies?: Policy[];
	/** Upstream target configuration */
	upstream: UpstreamConfig<TBindings>;
}
/**
 * Upstream target - where the request is forwarded.
 *
 * @typeParam TBindings - Worker bindings type, constrains {@link ServiceBindingUpstream.service}.
 */
export type UpstreamConfig<TBindings = Record<string, unknown>> = UrlUpstream | ServiceBindingUpstream<TBindings> | HandlerUpstream;
/**
 * Proxy to a remote URL. The gateway clones the request, rewrites headers,
 * and forwards it via `fetch()`. SSRF protection ensures the rewritten URL
 * stays on the same origin as the target.
 */
export interface UrlUpstream {
	type: "url";
	/** Target URL (e.g. `"https://api.example.com"`). Validated at config time. */
	target: string;
	/** Rewrite the path before forwarding. Must not change the origin. */
	rewritePath?: (path: string) => string;
	/** Headers to add/override on the forwarded request. */
	headers?: Record<string, string>;
}
/**
 * Forward to another Cloudflare Worker via a Service Binding.
 * The binding must be configured in the consumer's `wrangler.jsonc`.
 *
 * @typeParam TBindings - Worker bindings type. When provided, `service`
 *   autocompletes to valid binding names from your Env interface.
 */
export interface ServiceBindingUpstream<TBindings = Record<string, unknown>> {
	type: "service-binding";
	/** Name of the Service Binding in `wrangler.jsonc` (e.g. `"AUTH_SERVICE"`). */
	service: Extract<keyof TBindings, string>;
	/** Rewrite the path before forwarding to the bound service. */
	rewritePath?: (path: string) => string;
}
/**
 * Invoke a custom handler function directly. Useful for health checks,
 * mock responses, or routes that don't proxy to an upstream.
 */
export interface HandlerUpstream {
	type: "handler";
	/** Handler function receiving the Hono context and returning a Response. */
	handler: (c: Context) => Response | Promise<Response>;
}
/** HTTP methods supported by gateway route registration. */
export type HttpMethod = "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "HEAD" | "OPTIONS";
/** Configuration for the admin introspection API. */
export interface AdminConfig {
	/** Enable admin routes. Default: `false`. */
	enabled: boolean;
	/** Path prefix for admin routes. Default: `"___gateway"`. */
	prefix?: string;
	/** Optional auth check - return `false` to deny access. */
	auth?: (c: Context) => boolean | Promise<boolean>;
	/** MetricsCollector instance for the `/metrics` endpoint. */
	metrics?: MetricsCollector;
}
/** Registered route information for admin introspection. */
export interface RegisteredRoute {
	path: string;
	methods: string[];
	policyNames: string[];
	upstreamType: string;
}
/** Registered policy information for admin introspection. */
export interface RegisteredPolicy {
	name: string;
	priority: number;
}
/** Internal registry for admin introspection. */
export interface GatewayRegistry {
	routes: RegisteredRoute[];
	policies: RegisteredPolicy[];
	gatewayName: string;
}
/** The instantiated gateway - a configured Hono app */
export interface GatewayInstance {
	/** The underlying Hono app, ready to be exported as a Worker */
	app: Hono$1;
	/** Registered route count */
	routeCount: number;
	/** Gateway name */
	name: string;
	/** Internal registry for admin introspection */
	_registry: GatewayRegistry;
}
/**
 * Create a gateway instance from a declarative configuration.
 *
 * Registers all routes on a Hono app, builds per-route policy pipelines
 * (merging global + route-level policies), and wires up upstream dispatch.
 * Returns a {@link GatewayInstance} whose `.app` property is the Hono app
 * ready to be exported as a Cloudflare Worker default export.
 *
 * @param config - Full gateway configuration including routes, policies, and options.
 * @returns A {@link GatewayInstance} with the configured Hono app.
 * @throws {GatewayError} If no routes are provided.
 *
 * @example
 * ```ts
 * import { createGateway, jwtAuth, rateLimit } from "@homegrower-club/stoma";
 *
 * const gateway = createGateway({
 *   name: "my-api",
 *   basePath: "/api",
 *   routes: [
 *     {
 *       path: "/users/*",
 *       pipeline: {
 *         policies: [jwtAuth({ secret: env.JWT_SECRET }), rateLimit({ max: 100 })],
 *         upstream: { type: "url", target: "https://users-service.internal" },
 *       },
 *     },
 *   ],
 * });
 *
 * export default gateway.app;
 * ```
 */
export declare function createGateway<TBindings = Record<string, unknown>>(config: GatewayConfig<TBindings>): GatewayInstance;
/**
 * Retrieve the {@link PolicyContext} from a Hono context.
 *
 * Returns `undefined` if called outside the gateway pipeline (e.g. in
 * a standalone Hono app without context injection).
 *
 * @param c - The Hono request context.
 * @returns The gateway context, or `undefined` if not in a gateway pipeline.
 */
export declare function getGatewayContext(c: Context): PolicyContext | undefined;
/**
 * Route scoping - group routes under a shared path prefix with shared policies.
 *
 * `scope()` transforms an array of {@link RouteConfig} by prepending a path
 * prefix, prepending shared policies, and merging metadata. The output is a
 * flat `RouteConfig[]` that can be spread directly into `GatewayConfig.routes`.
 *
 * Nesting works naturally - pass the output of an inner `scope()` as the
 * `routes` of an outer `scope()`.
 *
 * @module scope
 *
 * @example
 * ```ts
 * import { createGateway, scope, jwtAuth, rateLimit } from "@homegrower-club/stoma";
 *
 * const gateway = createGateway({
 *   routes: [
 *     ...scope({
 *       prefix: "/api/v1",
 *       policies: [jwtAuth({ secret: "..." })],
 *       routes: [
 *         { path: "/users", pipeline: { upstream: { type: "url", target: "https://users.internal" } } },
 *         { path: "/orders", pipeline: { upstream: { type: "url", target: "https://orders.internal" } } },
 *       ],
 *     }),
 *   ],
 * });
 * ```
 */
/**
 * Configuration for a route scope (group).
 *
 * @typeParam TBindings - Worker bindings type, propagated to child routes.
 */
export interface ScopeConfig<TBindings = Record<string, unknown>> {
	/** Path prefix prepended to all child routes (e.g. "/api/v1") */
	prefix: string;
	/** Policies prepended to every child route's pipeline policies */
	policies?: Policy[];
	/** Child routes to scope */
	routes: RouteConfig<TBindings>[];
	/** Metadata merged into every child route (child wins on conflict) */
	metadata?: Record<string, unknown>;
}
/**
 * Group routes under a shared path prefix with shared policies and metadata.
 *
 * Returns a flat array of transformed {@link RouteConfig} objects ready to be
 * spread into `GatewayConfig.routes`.
 *
 * @typeParam TBindings - Worker bindings type, propagated to child routes.
 * @param config - Scope configuration.
 * @returns Array of route configs with prefix, policies, and metadata applied.
 */
export declare function scope<TBindings = Record<string, unknown>>(config: ScopeConfig<TBindings>): RouteConfig<TBindings>[];
export interface MockConfig extends PolicyConfig {
	/** HTTP status code to return. Default: 200. */
	status?: number;
	/** Response body. Can be a string or object (will be JSON-serialized). */
	body?: string | Record<string, unknown>;
	/** Response headers. */
	headers?: Record<string, string>;
	/** Artificial delay in milliseconds. Default: 0. */
	delayMs?: number;
	/** When `true`, suppress the production usage warning. Default: `false`. */
	allowInProduction?: boolean;
}
/**
 * Return a static mock response, bypassing the upstream entirely.
 *
 * Useful for development stubs, testing, and placeholder routes. Runs at
 * priority 999 (always last) and short-circuits - `next()` is never called,
 * so no upstream request is made. Object bodies are automatically
 * JSON-serialized with `content-type: application/json`.
 *
 * @param config - Status code, response body, headers, and artificial delay. All fields optional.
 * @returns A {@link Policy} at priority 999 (replaces the upstream).
 *
 * @example
 * ```ts
 * import { createGateway } from "@homegrower-club/stoma";
 * import { mock } from "@homegrower-club/stoma/policies";
 *
 * createGateway({
 *   routes: [{
 *     path: "/api/stub",
 *     pipeline: {
 *       policies: [
 *         // Return a JSON stub with 200ms simulated latency
 *         mock({
 *           body: { message: "Hello from stub" },
 *           delayMs: 200,
 *         }),
 *       ],
 *       upstream: { type: "handler", handler: () => new Response() }, // never reached
 *     },
 *   }],
 * });
 *
 * // Simulate a 503 maintenance page
 * mock({
 *   status: 503,
 *   body: "Service temporarily unavailable",
 *   headers: { "retry-after": "300" },
 * });
 * ```
 */
export declare const mock: (config?: MockConfig | undefined) => Policy;
/**
 * Proxy policy - per-route header manipulation and timeout control.
 *
 * @module proxy
 */
export interface ProxyPolicyConfig extends PolicyConfig {
	/** Headers to add to the proxied request */
	headers?: Record<string, string>;
	/** Headers to strip from the proxied request */
	stripHeaders?: string[];
	/** Timeout in milliseconds. Default: 30000. */
	timeout?: number;
	/**
	 * Whether to preserve the inbound Host header when proxying to URL upstreams.
	 * Default: false (Host is rewritten to the upstream target host).
	 */
	preserveHost?: boolean;
}
/**
 * Apply additional header manipulation and timeout control to the upstream call.
 *
 * Use this when you need per-route header injection, header stripping, or
 * a custom timeout that wraps the upstream dispatch. The core proxy
 * forwarding (URL, Service Binding, Handler) is handled by the gateway's
 * upstream handler - this policy layers on top of it.
 *
 * `preserveHost` applies to URL upstreams, instructing the upstream handler
 * not to rewrite the Host header to the target host.
 *
 * Handles Cloudflare Workers' immutable `Request.headers` by cloning the
 * request when header modifications are needed.
 *
 * @param config - Headers to add/strip, timeout, and host preservation. All fields optional.
 * @returns A {@link Policy} at priority 95 (runs late, just before the upstream call).
 *
 * @example
 * ```ts
 * import { proxy } from "@homegrower-club/stoma/policies";
 *
 * // Add an internal auth header and strip cookies for the upstream
 * proxy({
 *   headers: { "x-internal-key": "secret-123" },
 *   stripHeaders: ["cookie", "x-forwarded-for"],
 *   timeout: 10_000,
 * });
 *
 * // Preserve the original Host header for virtual-host routing
 * proxy({ preserveHost: true });
 * ```
 */
export declare function proxy(config?: ProxyPolicyConfig): Policy;
export interface ApiKeyAuthConfig extends PolicyConfig {
	/** Header name to read the API key from. Default: "X-API-Key" */
	headerName?: string;
	/** Query parameter name as fallback. Default: undefined (disabled) */
	queryParam?: string;
	/** Validator function - return true if the key is valid */
	validate: (key: string) => boolean | Promise<boolean>;
	/**
	 * After successful validation, derive an identity string from the key
	 * and set it as a request header for upstream consumption.
	 *
	 * @example
	 * ```ts
	 * apiKeyAuth({
	 *   validate: (key) => keys.has(key),
	 *   forwardKeyIdentity: {
	 *     headerName: "x-api-client",
	 *     identityFn: (key) => keyToClientMap.get(key) ?? "unknown",
	 *   },
	 * });
	 * ```
	 */
	forwardKeyIdentity?: {
		/** Header name to set on the request. */
		headerName: string;
		/** Derive an identity string from the validated key. Can be async. */
		identityFn: (key: string) => string | Promise<string>;
	};
}
/**
 * Validate API keys from headers or query parameters.
 *
 * Checks the `X-API-Key` header by default, with an optional query parameter
 * fallback. The `validate` function can be async to support remote key lookups.
 *
 * @param config - API key settings with a required `validate` function.
 * @returns A {@link Policy} at priority 10.
 *
 * @example
 * ```ts
 * // Static key validation
 * apiKeyAuth({
 *   validate: (key) => key === env.API_KEY,
 * });
 *
 * // Async validation with query parameter fallback
 * apiKeyAuth({
 *   headerName: "Authorization",
 *   queryParam: "api_key",
 *   validate: async (key) => {
 *     const result = await kv.get(`api-key:${key}`);
 *     return result !== null;
 *   },
 * });
 * ```
 */
export declare const apiKeyAuth: (config: ApiKeyAuthConfig) => Policy;
export interface BasicAuthConfig extends PolicyConfig {
	/** Validate username/password. Return true if valid. */
	validate: (username: string, password: string, c: Context) => boolean | Promise<boolean>;
	/** Realm for the WWW-Authenticate header. Default: "Restricted" */
	realm?: string;
}
/**
 * Basic Authentication policy - validate base64-encoded credentials.
 *
 * Sends a `WWW-Authenticate` header on failure to prompt browser credential dialogs.
 * The realm is sanitized to prevent header injection.
 *
 * @param config - Validation function and optional realm name.
 * @returns A {@link Policy} at priority 10.
 *
 * @example
 * ```ts
 * basicAuth({
 *   realm: "Admin Area",
 *   validate: async (username, password) => {
 *     return username === "admin" && password === env.ADMIN_PASSWORD;
 *   },
 * });
 * ```
 */
export declare const basicAuth: (config: BasicAuthConfig) => Policy;
/** Clear the unified JWKS cache. Exported for testing. */
export declare function clearJwksCache(): void;
export interface GenerateHttpSignatureConfig extends PolicyConfig {
	/** Key identifier included in signature parameters. */
	keyId: string;
	/** HMAC secret for signing. */
	secret?: string;
	/** RSA private key as JWK. */
	privateKey?: JsonWebKey;
	/** Signing algorithm identifier (e.g. "hmac-sha256", "rsa-pss-sha512", "rsa-v1_5-sha256"). */
	algorithm: string;
	/** Components to include in signature. Default: ["@method", "@path", "@authority"]. */
	components?: string[];
	/** Signature header name. Default: "Signature". */
	signatureHeaderName?: string;
	/** Signature-Input header name. Default: "Signature-Input". */
	signatureInputHeaderName?: string;
	/** Signature label. Default: "sig1". */
	label?: string;
	/** Signature expiry in seconds from creation. Optional. */
	expires?: number;
	/** Include a nonce parameter. Default: false. */
	nonce?: boolean;
}
export declare const generateHttpSignature: (config: GenerateHttpSignatureConfig) => Policy;
export interface GenerateJwtConfig extends PolicyConfig {
	/** Signing algorithm */
	algorithm: "HS256" | "HS384" | "HS512" | "RS256" | "RS384" | "RS512";
	/** HMAC secret (for HS* algorithms) */
	secret?: string;
	/** RSA private key as JWK (for RS* algorithms) */
	privateKey?: JsonWebKey;
	/** Claims to include. Static record or dynamic function. */
	claims?: Record<string, unknown> | ((c: Context) => Record<string, unknown> | Promise<Record<string, unknown>>);
	/** Token lifetime in seconds. Default: 3600 (1 hour) */
	expiresIn?: number;
	/** Issuer claim */
	issuer?: string;
	/** Audience claim */
	audience?: string;
	/** Header name for the generated token. Default: "Authorization" */
	headerName?: string;
	/** Token prefix. Default: "Bearer" */
	tokenPrefix?: string;
}
/**
 * Mint JWTs and attach them to the request for upstream consumption.
 *
 * @example
 * ```ts
 * import { generateJwt } from "@homegrower-club/stoma";
 *
 * generateJwt({
 *   algorithm: "HS256",
 *   secret: env.JWT_SIGNING_SECRET,
 *   claims: (c) => ({ sub: c.req.header("x-user-id") }),
 *   issuer: "my-gateway",
 *   expiresIn: 300,
 * });
 * ```
 */
export declare const generateJwt: (config: GenerateJwtConfig) => Policy;
export interface JwsConfig extends PolicyConfig {
	/** HMAC secret for verification */
	secret?: string;
	/** JWKS endpoint for RSA verification */
	jwksUrl?: string;
	/** Header containing the JWS. Default: "X-JWS-Signature" */
	headerName?: string;
	/** Where the payload comes from for detached JWS. Default: "embedded" */
	payloadSource?: "embedded" | "body";
	/** Whether to forward the verified payload as a header. Default: false */
	forwardPayload?: boolean;
	/** Header name for forwarded payload. Default: "X-JWS-Payload" */
	forwardHeaderName?: string;
	/** JWKS cache TTL in ms. Default: 300000 */
	jwksCacheTtlMs?: number;
	/** JWKS fetch timeout in milliseconds. Default: 10000 (10 seconds). */
	jwksTimeoutMs?: number;
}
/**
 * Verify JWS compact serialization signatures on requests.
 *
 * The `none` algorithm is always rejected to prevent signature bypass attacks.
 * Config validation (`secret` or `jwksUrl` required) is performed at construction
 * time - a missing config throws immediately, not on first request.
 *
 * @example
 * ```ts
 * import { jws } from "@homegrower-club/stoma";
 *
 * // HMAC verification with embedded payload
 * jws({ secret: env.JWS_SECRET });
 *
 * // Detached JWS - payload comes from the request body
 * jws({ secret: env.JWS_SECRET, payloadSource: "body" });
 * ```
 */
export declare const jws: (config?: JwsConfig | undefined) => Policy;
export interface JwtAuthConfig extends PolicyConfig {
	/** JWT secret for HMAC verification */
	secret?: string;
	/** JWKS endpoint URL (e.g. Supabase, Auth0) */
	jwksUrl?: string;
	/** Expected JWT issuer */
	issuer?: string;
	/** Expected JWT audience */
	audience?: string;
	/** Header to read the token from. Default: "Authorization" */
	headerName?: string;
	/** Token prefix. Default: "Bearer" */
	tokenPrefix?: string;
	/** Claims to inject into request headers for upstream consumption */
	forwardClaims?: Record<string, string>;
	/** JWKS cache TTL in milliseconds. Default: 300000 (5 minutes). */
	jwksCacheTtlMs?: number;
	/** JWKS fetch timeout in milliseconds. Default: 10000 (10 seconds). */
	jwksTimeoutMs?: number;
	/** Clock skew tolerance in seconds for expiry checks. Default: 0. */
	clockSkewSeconds?: number;
	/** Require the `exp` claim to be present. Default: false. */
	requireExp?: boolean;
}
/**
 * Validate JWT tokens and optionally forward claims as upstream headers.
 *
 * Supports both HMAC (shared secret) and RSA (JWKS endpoint) verification.
 * JWKS responses are cached for 5 minutes. The `none` algorithm is always
 * rejected to prevent signature bypass attacks.
 *
 * @param config - JWT authentication settings. Requires either `secret` (HMAC) or `jwksUrl` (RSA).
 * @returns A {@link Policy} at priority 10 (runs early, before rate limiting).
 *
 * @example
 * ```ts
 * // HMAC verification with a shared secret
 * createGateway({
 *   routes: [{
 *     path: "/api/*",
 *     pipeline: {
 *       policies: [jwtAuth({ secret: env.JWT_SECRET })],
 *       upstream: { type: "url", target: "https://backend.internal" },
 *     },
 *   }],
 * });
 *
 * // JWKS verification (e.g. Supabase, Auth0) with claim forwarding
 * jwtAuth({
 *   jwksUrl: "https://your-project.supabase.co/auth/v1/.well-known/jwks.json",
 *   issuer: "https://your-project.supabase.co/auth/v1",
 *   forwardClaims: { sub: "x-user-id", email: "x-user-email" },
 * });
 * ```
 */
export declare const jwtAuth: (config?: JwtAuthConfig | undefined) => Policy;
export interface OAuth2Config extends PolicyConfig {
	/** OAuth2 token introspection endpoint (RFC 7662). */
	introspectionUrl?: string;
	/** Client ID for authenticating with the introspection endpoint. */
	clientId?: string;
	/** Client secret for authenticating with the introspection endpoint. */
	clientSecret?: string;
	/** Local validation function as alternative to introspection. Takes precedence if both provided. */
	localValidate?: (token: string) => boolean | Promise<boolean>;
	/** Where to look for the token. Default: "header". */
	tokenLocation?: "header" | "query";
	/** Header name when tokenLocation is "header". Default: "authorization". */
	headerName?: string;
	/** Prefix to strip from header value. Default: "Bearer". */
	headerPrefix?: string;
	/** Query param name when tokenLocation is "query". Default: "access_token". */
	queryParam?: string;
	/** Map introspection response fields to request headers. Only applies with introspection. */
	forwardTokenInfo?: Record<string, string>;
	/** Cache introspection results for this many seconds. Default: 0 (no cache). */
	cacheTtlSeconds?: number;
	/** Maximum number of tokens to cache. Default: 100. */
	cacheMaxEntries?: number;
	/** Required scopes - token must have ALL of these (space-separated scope string). */
	requiredScopes?: string[];
	/** Introspection endpoint fetch timeout in milliseconds. Default: 5000. */
	introspectionTimeoutMs?: number;
}
export declare const oauth2: (config?: OAuth2Config | undefined) => Policy;
export interface RbacConfig extends PolicyConfig {
	/** Header name containing the user's role(s). Default: "x-user-role". */
	roleHeader?: string;
	/** Allowed roles - pass if user has ANY of these. */
	roles?: string[];
	/** Required permissions - pass if user has ALL of these. */
	permissions?: string[];
	/** Header containing permissions. Default: "x-user-permissions". */
	permissionHeader?: string;
	/** Delimiter for permission string. Default: ",". */
	permissionDelimiter?: string;
	/** Delimiter for role string. Default: ",". */
	roleDelimiter?: string;
	/** Custom deny message. Default: "Access denied: insufficient permissions". */
	denyMessage?: string;
	/**
	 * Strip role/permission headers from incoming requests for security.
	 * These headers should only be set by trusted upstream auth policies,
	 * not by external clients. Default: true.
	 */
	stripHeaders?: boolean;
}
export declare const rbac: (config?: RbacConfig | undefined) => Policy;
export interface HttpSignatureKey {
	/** HMAC secret. */
	secret?: string;
	/** RSA public key as JWK. */
	publicKey?: JsonWebKey;
	/** Algorithm identifier. */
	algorithm: string;
}
export interface VerifyHttpSignatureConfig extends PolicyConfig {
	/** Map of keyId to key material. */
	keys: Record<string, HttpSignatureKey>;
	/** Components that MUST be in the signature. Default: ["@method"]. */
	requiredComponents?: string[];
	/** Max signature age in seconds. Default: 300 (5 min). */
	maxAge?: number;
	/** Signature header name. Default: "Signature". */
	signatureHeaderName?: string;
	/** Signature-Input header name. Default: "Signature-Input". */
	signatureInputHeaderName?: string;
	/** Expected signature label. Default: "sig1". */
	label?: string;
}
export declare const verifyHttpSignature: (config: VerifyHttpSignatureConfig) => Policy;
export interface RoutingRule {
	/** Human-readable rule name for debugging. */
	name?: string;
	/** Condition that determines if this rule applies. */
	condition: (c: Context) => boolean | Promise<boolean>;
	/** Target upstream URL to route to. */
	target: string;
	/** Optional path rewrite function. */
	rewritePath?: (path: string) => string;
	/** Optional headers to add to the upstream request. */
	headers?: Record<string, string>;
}
export interface DynamicRoutingConfig extends PolicyConfig {
	/** Ordered list of routing rules. First match wins. Required. */
	rules: Array<RoutingRule>;
	/** If true and no rule matches, call next() normally. If false, throw 404. Default: true. */
	fallthrough?: boolean;
}
/**
 * Evaluate routing rules and expose the first match on request context.
 *
 * Evaluates rules in order. The first matching rule's target, rewritePath,
 * and headers are set as context variables for downstream consumption.
 *
 * @param config - Routing rules and fallthrough behavior.
 * @returns A {@link Policy} at priority 50 (REQUEST_TRANSFORM).
 *
 * @example
 * ```ts
 * dynamicRouting({
 *   rules: [
 *     {
 *       name: "v2-api",
 *       condition: (c) => c.req.header("x-api-version") === "2",
 *       target: "https://api-v2.internal",
 *       rewritePath: (path) => path.replace("/api/", "/v2/"),
 *     },
 *     {
 *       name: "default",
 *       condition: () => true,
 *       target: "https://api-v1.internal",
 *     },
 *   ],
 * });
 * ```
 */
export declare const dynamicRouting: (config: DynamicRoutingConfig) => Policy;
export interface GeoIpFilterConfig extends PolicyConfig {
	/** Country codes to allow (e.g. `["US", "CA", "GB"]`). Used in "allow" mode. */
	allow?: string[];
	/** Country codes to deny. Used in "deny" mode. */
	deny?: string[];
	/** Filter mode. Default: `"deny"`. */
	mode?: "allow" | "deny";
	/** Header name to read the country code from. Default: `"cf-ipcountry"`. */
	countryHeader?: string;
}
/**
 * Block or allow requests based on geographic country code.
 *
 * Reads the country from the configured header (default `cf-ipcountry`,
 * set by Cloudflare). Supports allowlist and denylist modes. Country
 * sets are pre-computed once at construction time for efficiency.
 *
 * @param config - Country filter rules and mode selection.
 * @returns A policy at priority 1 (IP_FILTER).
 *
 * @example
 * ```ts
 * // Allow only US, Canada, and UK
 * geoIpFilter({ mode: "allow", allow: ["US", "CA", "GB"] });
 *
 * // Block specific countries
 * geoIpFilter({ deny: ["CN", "RU"] });
 * ```
 */
export declare function geoIpFilter(config?: GeoIpFilterConfig): Policy;
export interface HttpCalloutConfig extends PolicyConfig {
	/** Target URL - static string or dynamic function. Required. */
	url: string | ((c: Context) => string | Promise<string>);
	/** HTTP method. Default: "GET". */
	method?: string;
	/** Request headers - static values or dynamic functions. */
	headers?: Record<string, string | ((c: Context) => string | Promise<string>)>;
	/** Request body - static or dynamic. JSON-serialized if object. */
	body?: unknown | ((c: Context) => unknown | Promise<unknown>);
	/** Timeout in ms. Default: 5000. */
	timeout?: number;
	/** Callback to process the callout response. Required. */
	onResponse: (response: Response, c: Context) => void | Promise<void>;
	/** Error handler. Default: throw GatewayError 502. */
	onError?: (error: unknown, c: Context) => void | Promise<void>;
	/** If true, throw on non-2xx response. Default: true. */
	abortOnFailure?: boolean;
}
/**
 * Make an external HTTP call mid-pipeline.
 *
 * Resolves URL, headers, and body (static or dynamic), makes the fetch,
 * and calls the `onResponse` callback to process the result. Errors are
 * handled via `onError` or default to a 502 GatewayError.
 *
 * @security When the `url` parameter is a dynamic function that derives
 * the callout target from request data (headers, path, query, or body),
 * this policy is vulnerable to Server-Side Request Forgery (SSRF). An
 * attacker could manipulate request data to make the worker issue requests
 * to internal services, metadata endpoints (e.g. cloud provider instance
 * metadata), or other unintended targets. Hardcode callout URLs whenever
 * possible. If dynamic URLs are required, validate them against an
 * explicit allowlist of permitted hosts and schemes.
 *
 * @param config - Callout target, method, headers, body, and response handler.
 * @returns A {@link Policy} at priority 50 (REQUEST_TRANSFORM).
 *
 * @example
 * ```ts
 * httpCallout({
 *   url: "https://auth.example.com/validate",
 *   method: "POST",
 *   headers: { authorization: (c) => c.req.header("authorization") ?? "" },
 *   body: (c) => ({ path: c.req.path }),
 *   onResponse: async (res, c) => {
 *     const data = await res.json();
 *     c.set("userId", data.userId);
 *   },
 * });
 * ```
 */
export declare const httpCallout: (config: HttpCalloutConfig) => Policy;
export interface InterruptConfig extends PolicyConfig {
	/** Predicate that determines whether to short-circuit. Required. */
	condition: (c: Context) => boolean | Promise<boolean>;
	/** HTTP status code for the interrupt response. Default: 200. */
	statusCode?: number;
	/** Response body. String  text/plain, object  application/json, undefined  empty. */
	body?: unknown;
	/** Additional response headers. */
	headers?: Record<string, string>;
}
/**
 * Conditionally short-circuit the pipeline and return a static response.
 *
 * Evaluates a predicate against the incoming request context. When the
 * condition returns `true`, the pipeline is interrupted - a response is
 * returned immediately and `next()` is never called (upstream is skipped).
 * When the condition returns `false`, the pipeline continues normally.
 *
 * @param config - Condition predicate, status code, body, and headers.
 * @returns A {@link Policy} at priority 100 (default - users typically set a custom priority).
 *
 * @example
 * ```ts
 * // Maintenance mode
 * interrupt({
 *   condition: (c) => c.req.header("x-maintenance") === "true",
 *   statusCode: 503,
 *   body: { maintenance: true, message: "Back soon" },
 *   headers: { "retry-after": "300" },
 * });
 *
 * // Health check short-circuit
 * interrupt({
 *   condition: (c) => c.req.path === "/healthz",
 *   body: "ok",
 * });
 * ```
 */
export declare const interrupt: (config: InterruptConfig) => Policy;
/**
 * IP allowlist/denylist filtering policy.
 *
 * Supports both HTTP (`handler`) and protocol-agnostic (`evaluate`) entry
 * points. The evaluate path uses {@link PolicyInput.clientIp} when available
 * (set by the runtime), falling back to header extraction.
 *
 * @module ip-filter
 */
export interface IpFilterConfig extends PolicyConfig {
	/** IPs or CIDR ranges to allow (allowlist mode). */
	allow?: string[];
	/** IPs or CIDR ranges to deny (denylist mode). */
	deny?: string[];
	/** Filter mode. Default: "deny". */
	mode?: "allow" | "deny";
	/** Ordered list of headers to inspect for the client IP. Default: `["cf-connecting-ip", "x-forwarded-for"]`. */
	ipHeaders?: string[];
}
/**
 * Block or allow requests based on client IP address or CIDR range.
 *
 * Supports both allowlist and denylist modes. Client IP is extracted from
 * `CF-Connecting-IP` (Cloudflare) or `X-Forwarded-For`. Accepts individual
 * IPs (`192.168.1.1`) and CIDR notation (`10.0.0.0/8`).
 *
 * @param config - IP filter rules and mode selection.
 * @returns A {@link Policy} at priority 1 (runs before everything else).
 *
 * @example
 * ```ts
 * // Allow only internal IPs
 * ipFilter({ mode: "allow", allow: ["10.0.0.0/8", "172.16.0.0/12"] });
 *
 * // Block known bad actors
 * ipFilter({ deny: ["203.0.113.0/24", "198.51.100.42"] });
 * ```
 */
export declare function ipFilter(config: IpFilterConfig): Policy;
export interface JsonThreatProtectionConfig extends PolicyConfig {
	/** Maximum nesting depth. Default: `20`. */
	maxDepth?: number;
	/** Maximum number of keys per object. Default: `100`. */
	maxKeys?: number;
	/** Maximum string value length (also applies to object keys). Default: `10000`. */
	maxStringLength?: number;
	/** Maximum array length. Default: `100`. */
	maxArraySize?: number;
	/** Maximum raw body size in bytes. Checked BEFORE parsing. Default: `1048576` (1 MB). */
	maxBodySize?: number;
	/**
	 * Content types to inspect.
	 * Requests with other content types pass through without inspection.
	 * Default: `["application/json"]`.
	 */
	contentTypes?: string[];
}
/**
 * JSON threat protection policy.
 *
 * Enforces structural limits on JSON request bodies to prevent abuse
 * from deeply nested objects, excessively large arrays, long strings,
 * or oversized payloads. Runs at EARLY priority to reject malicious
 * payloads before they reach business logic.
 *
 * @example
 * ```ts
 * import { jsonThreatProtection } from "@homegrower-club/stoma";
 *
 * // Default limits (20 depth, 100 keys, 10K string, 100 array, 1MB body)
 * jsonThreatProtection();
 *
 * // Strict limits for a public API
 * jsonThreatProtection({
 *   maxDepth: 5,
 *   maxKeys: 20,
 *   maxStringLength: 1000,
 *   maxArraySize: 50,
 *   maxBodySize: 102400, // 100KB
 * });
 * ```
 */
export declare const jsonThreatProtection: (config?: JsonThreatProtectionConfig | undefined) => Policy;
/** A single pattern rule with target areas and optional custom message. */
export interface RegexPatternRule {
	/** Regular expression pattern string. */
	regex: string;
	/** Which parts of the request to scan. */
	targets: Array<"path" | "headers" | "body" | "query">;
	/** Custom error message when this pattern matches. */
	message?: string;
}
export interface RegexThreatProtectionConfig extends PolicyConfig {
	/** Pattern rules to evaluate against request data. */
	patterns: RegexPatternRule[];
	/** Regex flags applied to all patterns. Default: `"i"` (case-insensitive). */
	flags?: string;
	/** Only inspect body for these content types. Default: `["application/json", "text/plain"]`. */
	contentTypes?: string[];
	/** Maximum body bytes to scan. Default: `65536` (64KB). */
	maxBodyScanLength?: number;
}
/**
 * Regex threat protection policy.
 *
 * Scans request path, query string, headers, and/or body against
 * configurable regex patterns. Throws a 400 GatewayError on first match.
 *
 * @security User-provided regex patterns can cause catastrophic backtracking
 * (ReDoS) if they contain nested quantifiers or overlapping alternations
 * (e.g. `(a+)+`, `(a|a)*b`). A crafted input string can cause the regex
 * engine to run in exponential time, blocking the worker thread and
 * effectively denying service. All patterns should be reviewed for
 * super-linear time complexity before deployment. Consider using atomic
 * patterns, possessive quantifiers (where supported), or testing patterns
 * with a ReDoS detection tool.
 *
 * @example
 * ```ts
 * import { regexThreatProtection } from "@homegrower-club/stoma";
 *
 * regexThreatProtection({
 *   patterns: [
 *     { regex: "(union|select|insert|delete|drop)\\s", targets: ["path", "query", "body"], message: "SQL injection detected" },
 *     { regex: "<script[^>]*>", targets: ["body", "headers"], message: "XSS detected" },
 *   ],
 * });
 * ```
 */
export declare const regexThreatProtection: (config: RegexThreatProtectionConfig) => Policy;
export interface RequestLimitConfig extends PolicyConfig {
	/** Maximum allowed body size in bytes (based on Content-Length). */
	maxBytes: number;
	/** Custom error message. Default: "Request body too large". */
	message?: string;
}
/**
 * Reject requests whose declared Content-Length exceeds `maxBytes`.
 *
 * This policy checks only the `Content-Length` header. If the header is
 * absent or invalid, the request passes through. Notably, requests using
 * chunked transfer encoding (`Transfer-Encoding: chunked`) do not include
 * a `Content-Length` header and will bypass this check entirely. For strict
 * body size enforcement, combine this policy with a body-reading policy
 * that enforces limits on the actual stream length.
 *
 * @param config - Maximum byte limit and optional custom message.
 * @returns A {@link Policy} at priority 5 (EARLY).
 */
export declare const requestLimit: (config: RequestLimitConfig) => Policy;
export interface ResourceFilterConfig extends PolicyConfig {
	/** Filter mode: "deny" removes listed fields, "allow" keeps only listed fields */
	mode: "allow" | "deny";
	/** Field paths to filter. Supports dot-notation (e.g. "user.password") */
	fields: string[];
	/** Content types to filter. Default: ["application/json"] */
	contentTypes?: string[];
	/** Apply filtering to array items. Default: true */
	applyToArrayItems?: boolean;
}
/**
 * Strip or allow fields from JSON responses.
 *
 * @example
 * ```ts
 * import { resourceFilter } from "@homegrower-club/stoma";
 *
 * // Remove sensitive fields
 * resourceFilter({
 *   mode: "deny",
 *   fields: ["password", "user.ssn"],
 * });
 *
 * // Keep only specific fields
 * resourceFilter({
 *   mode: "allow",
 *   fields: ["id", "name", "email"],
 * });
 * ```
 */
export declare const resourceFilter: (config: ResourceFilterConfig) => Policy;
export interface SslEnforceConfig extends PolicyConfig {
	/** Redirect HTTP to HTTPS (301). If false, block with 403. Default: true. */
	redirect?: boolean;
	/** HSTS max-age in seconds. Default: 31536000 (1 year). */
	hstsMaxAge?: number;
	/** Add includeSubDomains to HSTS header. Default: false. */
	includeSubDomains?: boolean;
	/** Add preload to HSTS header. Default: false. */
	preload?: boolean;
}
/**
 * Enforce HTTPS and append HSTS headers on secure responses.
 *
 * Detects protocol from `x-forwarded-proto` (or request URL protocol).
 * For non-HTTPS requests, either redirects to HTTPS (301) or throws 403.
 *
 * @param config - Redirect behavior and HSTS settings.
 * @returns A {@link Policy} at priority 5 (EARLY).
 */
export declare const sslEnforce: (config?: SslEnforceConfig | undefined) => Policy;
export interface TrafficShadowConfig extends PolicyConfig {
	/** URL of the shadow upstream (required). */
	target: string;
	/** Percentage of traffic to mirror, 0-100. Default: `100`. */
	percentage?: number;
	/** Only mirror these HTTP methods. Default: `["GET", "POST", "PUT", "PATCH", "DELETE"]`. */
	methods?: string[];
	/** Include request body in shadow request. Default: `true`. */
	mirrorBody?: boolean;
	/** Timeout for shadow request in ms. Default: `5000`. */
	timeout?: number;
	/** Optional error handler for shadow failures. Default: silent. */
	onError?: (error: unknown) => void;
}
/**
 * Traffic shadow policy.
 *
 * Mirrors traffic to a secondary upstream after the primary response
 * is ready. The shadow request is fire-and-forget and never affects
 * the primary response.
 *
 * @example
 * ```ts
 * import { trafficShadow } from "@homegrower-club/stoma";
 *
 * trafficShadow({
 *   target: "https://shadow.internal",
 *   percentage: 10,
 *   methods: ["POST", "PUT"],
 * });
 * ```
 */
export declare const trafficShadow: (config: TrafficShadowConfig) => Policy;
export interface LatencyInjectionConfig extends PolicyConfig {
	/** Base delay in milliseconds. Required. */
	delayMs: number;
	/** Jitter proportion (0 to 1). Actual delay varies by +/- jitter * delayMs. Default: 0. */
	jitter?: number;
	/** Probability of injecting latency (0 to 1). Default: 1 (always). */
	probability?: number;
}
/**
 * Inject artificial latency into the pipeline for chaos/resilience testing.
 *
 * When active, pauses execution for a configurable duration before calling
 * `next()`. Supports jitter to vary the delay and a probability setting to
 * inject latency only a fraction of the time.
 *
 * @param config - Delay duration, jitter, and injection probability.
 * @returns A {@link Policy} at priority 5 (early pipeline).
 *
 * @example
 * ```ts
 * // Fixed 100ms delay on every request
 * latencyInjection({ delayMs: 100 });
 *
 * // 200ms +/- 50% jitter, injected 30% of the time
 * latencyInjection({ delayMs: 200, jitter: 0.5, probability: 0.3 });
 * ```
 */
export declare const latencyInjection: (config: LatencyInjectionConfig) => Policy;
/**
 * Retry policy - automatic retry with configurable backoff for failed upstream calls.
 *
 * Retries work by inspecting the response status after `next()` completes.
 * When a retryable status code is detected and a `_proxyRequest` exists on
 * the Hono context (set by the URL upstream handler in `gateway.ts`), the
 * policy clones the stored request and re-issues it via `fetch()` directly -
 * no `globalThis.fetch` patching, fully concurrency-safe.
 *
 * For handler-based or service-binding upstreams there is no `_proxyRequest`,
 * so the retry policy is effectively a no-op - which is the correct behavior
 * since those upstream types would require calling `next()` multiple times
 * (disallowed by Hono's compose model).
 *
 * @module retry
 */
export interface RetryConfig extends PolicyConfig {
	/** Maximum number of retries. Default: 3. */
	maxRetries?: number;
	/** Status codes that trigger a retry. Default: [502, 503, 504]. */
	retryOn?: number[];
	/** Backoff strategy. Default: "exponential". */
	backoff?: "fixed" | "exponential";
	/** Base delay in ms for backoff. Default: 200. */
	baseDelayMs?: number;
	/** Maximum delay in ms. Default: 5000. */
	maxDelayMs?: number;
	/** HTTP methods eligible for retry. Default: idempotent methods. */
	retryMethods?: string[];
	/** Response header name for the retry count. Default: `"x-retry-count"`. */
	retryCountHeader?: string;
}
/**
 * Retry failed upstream calls with configurable backoff.
 *
 * After `next()` completes, checks the response status against `retryOn`
 * codes. If a retry is warranted and a `_proxyRequest` is available on the
 * context (set by `createUrlUpstream()` in `gateway.ts`), the policy clones
 * the stored request and calls `fetch()` directly - fully concurrency-safe
 * with no `globalThis.fetch` patching.
 *
 * For handler-based or service-binding upstreams (no `_proxyRequest`), the
 * retry policy is a no-op since there is no stored request to re-issue.
 * Sets `X-Retry-Count` on the response when retries occur.
 *
 * @param config - Retry limits, backoff strategy, and retryable status codes.
 * @returns A {@link Policy} at priority 90 (runs late, wraps the upstream fetch).
 *
 * @example
 * ```ts
 * // Retry 502/503/504 up to 3 times with exponential backoff
 * retry();
 *
 * // Fixed 500ms delay, retry on 500 too
 * retry({
 *   maxRetries: 2,
 *   retryOn: [500, 502, 503, 504],
 *   backoff: "fixed",
 *   baseDelayMs: 500,
 * });
 * ```
 */
export declare function retry(config?: RetryConfig): Policy;
export interface TimeoutConfig extends PolicyConfig {
	/** Timeout in milliseconds. Default: 30000. */
	timeoutMs?: number;
	/** Error message when timeout fires. */
	message?: string;
	/** HTTP status code when timeout fires. Default: 504. */
	statusCode?: number;
}
/**
 * Enforce a time budget for downstream execution.
 *
 * Races `next()` against a timer. If the timer fires first, throws a
 * GatewayError (default 504). The timer is always cleaned up, even on
 * downstream errors.
 *
 * @param config - Timeout duration and custom error message. Defaults to 30 seconds.
 * @returns A {@link Policy} at priority 85 (runs late, close to upstream).
 *
 * @example
 * ```ts
 * // 5-second timeout with custom message
 * timeout({ timeoutMs: 5000, message: "Upstream did not respond in time" });
 * ```
 */
export declare const timeout: (config?: TimeoutConfig | undefined) => Policy;
export interface AssignAttributesConfig extends PolicyConfig {
	/**
	 * Key-value pairs to set on the Hono context.
	 * Values can be static strings or functions that receive the context.
	 */
	attributes: Record<string, string | ((c: Context) => string | Promise<string>)>;
}
/**
 * Set key-value attributes on the Hono request context.
 *
 * @param config - Must include `attributes` - a record of keys to values or resolver functions.
 * @returns A {@link Policy} at priority 50 (REQUEST_TRANSFORM).
 *
 * @example
 * ```ts
 * import { assignAttributes } from "@homegrower-club/stoma";
 *
 * assignAttributes({
 *   attributes: {
 *     "x-tenant": "acme",
 *     "x-request-path": (c) => new URL(c.req.url).pathname,
 *   },
 * });
 * ```
 */
export declare const assignAttributes: (config: AssignAttributesConfig) => Policy;
/** A field value - either a static value or a function resolving to one. */
export type FieldValue = unknown | ((c: Context) => unknown | Promise<unknown>);
export interface AssignContentConfig extends PolicyConfig {
	/** Fields to set/override in the JSON request body. */
	request?: Record<string, FieldValue>;
	/** Fields to set/override in the JSON response body. */
	response?: Record<string, FieldValue>;
	/** Only modify bodies with these content types. Default: `["application/json"]`. */
	contentTypes?: string[];
}
/**
 * Assign content policy.
 *
 * Injects or overrides fields in JSON request and/or response bodies.
 * Useful for injecting tenant IDs, timestamps, metadata, or other
 * fields that should be transparently added by the gateway.
 *
 * @example
 * ```ts
 * import { assignContent } from "@homegrower-club/stoma";
 *
 * assignContent({
 *   request: {
 *     tenantId: "acme",
 *     timestamp: (c) => new Date().toISOString(),
 *   },
 *   response: {
 *     gateway: "stoma",
 *   },
 * });
 * ```
 */
export declare const assignContent: (config?: AssignContentConfig | undefined) => Policy;
export interface CorsConfig extends PolicyConfig {
	/** Allowed origins. Default: "*" */
	origins?: string | string[] | ((origin: string) => boolean);
	/** Allowed HTTP methods. Default: all. */
	methods?: string[];
	/** Headers the client is allowed to send. */
	allowHeaders?: string[];
	/** Headers exposed to the client. */
	exposeHeaders?: string[];
	/** Max age for preflight cache in seconds. Default: 86400. */
	maxAge?: number;
	/** Allow credentials. Default: false. */
	credentials?: boolean;
}
/**
 * Add Cross-Origin Resource Sharing headers to gateway responses.
 *
 * Wraps Hono's built-in CORS middleware as a composable policy. Handles both
 * simple and preflight (OPTIONS) requests. Runs at priority 5 so CORS headers
 * are applied before auth or other policies reject the request.
 *
 * @param config - Origin rules, allowed methods/headers, and credentials. All fields optional.
 * @returns A {@link Policy} at priority 5 (runs very early).
 *
 * @example
 * ```ts
 * import { createGateway } from "@homegrower-club/stoma";
 * import { cors } from "@homegrower-club/stoma/policies";
 *
 * // Allow any origin (default)
 * createGateway({
 *   policies: [cors()],
 *   routes: [{ path: "/api/*", pipeline: { upstream: { type: "url", target: "https://api.example.com" } } }],
 * });
 *
 * // Restrict to specific origins with credentials
 * cors({
 *   origins: ["https://app.example.com", "https://staging.example.com"],
 *   methods: ["GET", "POST", "PUT", "DELETE"],
 *   credentials: true,
 *   maxAge: 3600,
 * });
 *
 * // Dynamic origin validation
 * cors({
 *   origins: (origin) => origin.endsWith(".example.com"),
 * });
 * ```
 */
export declare function cors(config?: CorsConfig): Policy;
/** Result shape returned by the user-provided validation function. */
export interface JsonValidationResult {
	valid: boolean;
	errors?: string[];
}
export interface JsonValidationConfig extends PolicyConfig {
	/** Custom validation function. Takes parsed body, returns validation result. */
	validate?: (body: unknown) => JsonValidationResult | Promise<JsonValidationResult>;
	/** Content types to validate. Default: ["application/json"] */
	contentTypes?: string[];
	/** HTTP status code on validation failure. Default: 422 */
	rejectStatus?: number;
	/** Include validation errors in response. Default: true */
	errorDetail?: boolean;
}
/**
 * Pluggable JSON body validation policy.
 *
 * Validates the request body using a user-provided function. When no
 * `validate` function is configured, checks that the body is parseable JSON.
 * Requests with content types not in the configured list pass through
 * without validation.
 *
 * @example
 * ```ts
 * import { jsonValidation } from "@homegrower-club/stoma";
 *
 * // With Zod
 * jsonValidation({
 *   validate: (body) => {
 *     const result = myZodSchema.safeParse(body);
 *     return {
 *       valid: result.success,
 *       errors: result.success ? undefined : result.error.issues.map(i => i.message),
 *     };
 *   },
 * });
 *
 * // Just validate JSON is parseable (no validate function)
 * jsonValidation();
 * ```
 */
export declare const jsonValidation: (config?: JsonValidationConfig | undefined) => Policy;
export interface OverrideMethodConfig extends PolicyConfig {
	/** Header name to read the override method from. Default: `"X-HTTP-Method-Override"`. */
	header?: string;
	/** Methods allowed as overrides. Default: `["GET", "PUT", "PATCH", "DELETE"]`. */
	allowedMethods?: string[];
}
/**
 * Override the HTTP method of a POST request via a header.
 *
 * Only applies to POST requests - the industry-standard approach for
 * tunneling other methods through POST. Non-POST requests with the
 * override header are ignored.
 *
 * @param config - Header name and allowed override methods.
 * @returns A policy at priority 5 (EARLY).
 *
 * @example
 * ```ts
 * // Default: reads X-HTTP-Method-Override header
 * overrideMethod();
 *
 * // Custom header and restricted methods
 * overrideMethod({ header: "X-Method", allowedMethods: ["PUT", "PATCH"] });
 * ```
 */
export declare const overrideMethod: (config?: OverrideMethodConfig | undefined) => Policy;
/** Result shape returned by validation functions that provide error details. */
export interface ValidationResult {
	valid: boolean;
	errors?: string[];
}
export interface RequestValidationConfig extends PolicyConfig {
	/**
	 * Synchronous validation function.
	 * Return `true`/`false` or an object with optional error details.
	 */
	validate?: (body: unknown) => boolean | ValidationResult;
	/**
	 * Async validation function (e.g., for remote schema validation).
	 * If both `validate` and `validateAsync` are provided, `validateAsync` takes precedence.
	 */
	validateAsync?: (body: unknown) => Promise<boolean | ValidationResult>;
	/**
	 * Only validate these content types.
	 * Requests with other content types pass through without validation.
	 * Default: `["application/json"]`.
	 */
	contentTypes?: string[];
	/** Custom error message prefix. Default: `"Request validation failed"`. */
	errorMessage?: string;
}
/**
 * Pluggable request body validation policy.
 *
 * Validates the request body using a user-provided sync or async function.
 * Requests with content types not in the configured list pass through
 * without validation.
 *
 * @example
 * ```ts
 * import { requestValidation } from "@homegrower-club/stoma";
 *
 * // Simple boolean validator
 * requestValidation({
 *   validate: (body) => body != null && typeof body === "object",
 * });
 *
 * // Detailed validation with error messages
 * requestValidation({
 *   validate: (body) => {
 *     const errors: string[] = [];
 *     if (!body || typeof body !== "object") errors.push("Body must be an object");
 *     return { valid: errors.length === 0, errors };
 *   },
 * });
 * ```
 */
export declare const requestValidation: (config?: RequestValidationConfig | undefined) => Policy;
export interface RequestTransformConfig extends PolicyConfig {
	/** Headers to add or overwrite on the outgoing request. */
	setHeaders?: Record<string, string>;
	/** Header names to remove from the outgoing request. */
	removeHeaders?: string[];
	/** Rename headers: keys are old names, values are new names. */
	renameHeaders?: Record<string, string>;
}
export interface ResponseTransformConfig extends PolicyConfig {
	/** Headers to add or overwrite on the response. */
	setHeaders?: Record<string, string>;
	/** Header names to remove from the response. */
	removeHeaders?: string[];
	/** Rename headers: keys are old names, values are new names. */
	renameHeaders?: Record<string, string>;
}
/**
 * Modify request headers before they reach the upstream service.
 *
 * Applies header transformations in order: rename  set  remove. Handles
 * Cloudflare Workers' immutable `Request.headers` by cloning the request
 * with modified headers.
 *
 * @param config - Header set/remove/rename operations. At least one should be provided.
 * @returns A {@link Policy} at priority 50 (mid-pipeline, after auth, before upstream).
 *
 * @example
 * ```ts
 * import { requestTransform } from "@homegrower-club/stoma/policies";
 *
 * // Add API version header and strip cookies
 * requestTransform({
 *   setHeaders: { "x-api-version": "2024-01-01" },
 *   removeHeaders: ["cookie"],
 * });
 *
 * // Rename a legacy header to the new convention
 * requestTransform({
 *   renameHeaders: { "x-old-auth": "authorization" },
 * });
 * ```
 */
export declare const requestTransform: (config?: RequestTransformConfig | undefined) => Policy;
/**
 * Modify response headers after the upstream service returns.
 *
 * Applies header transformations in order: rename  set  remove. Runs at
 * priority 92 (late in the pipeline) so it can modify headers set by the
 * upstream or earlier policies.
 *
 * @param config - Header set/remove/rename operations. At least one should be provided.
 * @returns A {@link Policy} at priority 92 (runs late, after upstream responds).
 *
 * @example
 * ```ts
 * import { responseTransform } from "@homegrower-club/stoma/policies";
 *
 * // Add security headers and strip server info
 * responseTransform({
 *   setHeaders: {
 *     "strict-transport-security": "max-age=31536000; includeSubDomains",
 *     "x-content-type-options": "nosniff",
 *   },
 *   removeHeaders: ["server", "x-powered-by"],
 * });
 * ```
 */
export declare const responseTransform: (config?: ResponseTransformConfig | undefined) => Policy;
/**
 * Health check route factory with optional upstream probing.
 *
 * @module health
 */
export interface HealthConfig {
	/** Health endpoint path. Default: "/health". */
	path?: string;
	/** URLs to probe for upstream health. */
	upstreamProbes?: string[];
	/** Include individual upstream statuses in response. Default: false. */
	includeUpstreamStatus?: boolean;
	/** Timeout in ms for each upstream probe. Default: 5000. */
	probeTimeoutMs?: number;
	/** HTTP method for upstream probes. Default: `"HEAD"`. */
	probeMethod?: string;
	/** Status code returned when all probes are unhealthy. Default: 503. */
	unhealthyStatusCode?: number;
}
/**
 * Create a health check route for liveness and upstream probing.
 *
 * Returns a {@link RouteConfig} (not a Policy) - add it directly to the
 * gateway's `routes` array. Without upstream probes, returns a simple
 * `{ status: "healthy" }` response. With probes, performs concurrent HEAD
 * requests (5s timeout each) and reports aggregate status:
 * - `"healthy"` - all probes passed
 * - `"degraded"` - some probes failed
 * - `"unhealthy"` - all probes failed (returns 503)
 *
 * @security Enabling `includeUpstreamStatus: true` causes the response to
 * include the URLs and availability status of internal upstream services.
 * On public-facing endpoints this leaks internal service topology, which
 * can aid attackers in reconnaissance (identifying internal hostnames,
 * ports, and service availability patterns). Restrict health routes that
 * expose upstream status to internal or admin-only paths, or protect them
 * with an authentication policy.
 *
 * @param config - Endpoint path, upstream probe URLs, and status detail toggle. All fields optional.
 * @returns A {@link RouteConfig} for a GET health endpoint.
 *
 * @example
 * ```ts
 * import { createGateway } from "@homegrower-club/stoma";
 * import { health } from "@homegrower-club/stoma/policies";
 *
 * createGateway({
 *   routes: [
 *     // Simple liveness check at /health
 *     health(),
 *
 *     // Probe upstreams with detailed status at /healthz
 *     health({
 *       path: "/healthz",
 *       upstreamProbes: [
 *         "https://api.example.com/health",
 *         "https://auth.example.com/health",
 *       ],
 *       includeUpstreamStatus: true,
 *     }),
 *
 *     // ...other routes
 *   ],
 * });
 * ```
 */
export declare function health<TBindings = Record<string, unknown>>(config?: HealthConfig): RouteConfig<TBindings>;
export interface AssignMetricsConfig extends PolicyConfig {
	/**
	 * Metric tags to attach to the request.
	 * Values can be static strings or functions that receive the context.
	 */
	tags: Record<string, string | ((c: Context) => string | Promise<string>)>;
}
/**
 * Attach metric tags to the request context for downstream consumers.
 *
 * Tags are resolved (static or dynamic) and stored as a plain object at
 * `c.get("_metricsTags")`. The {@link metricsReporter} policy (or any custom
 * observer) can read these tags to enrich collected metrics.
 *
 * @param config - Must include `tags` - a record of tag names to values or resolver functions.
 * @returns A {@link Policy} at priority 0 (OBSERVABILITY).
 *
 * @example
 * ```ts
 * import { assignMetrics } from "@homegrower-club/stoma";
 *
 * assignMetrics({
 *   tags: {
 *     service: "users-api",
 *     region: (c) => c.req.header("cf-ipcountry") ?? "unknown",
 *   },
 * });
 * ```
 */
export declare const assignMetrics: (config: AssignMetricsConfig) => Policy;
export interface MetricsReporterConfig extends PolicyConfig {
	/** The metrics collector to record to. */
	collector: MetricsCollector;
}
/**
 * Record standard gateway metrics for every request.
 *
 * Metrics recorded:
 * - `gateway_requests_total` (counter) - total requests, tagged by method/path/status/gateway
 * - `gateway_request_duration_ms` (histogram) - end-to-end request duration
 * - `gateway_request_errors_total` (counter) - requests with status >= 400
 * - `gateway_policy_duration_ms` (histogram) - per-policy timing when available
 *
 * @param config - Must include a {@link MetricsCollector} instance.
 * @returns A {@link Policy} at priority 1.
 */
export declare const metricsReporter: (config: MetricsReporterConfig) => Policy;
export interface RequestLogConfig extends PolicyConfig {
	/** Additional fields to extract from the request */
	extractFields?: (c: unknown) => Record<string, unknown>;
	/** Custom log sink - defaults to console.log with structured JSON */
	sink?: (entry: LogEntry) => void | Promise<void>;
	/** Ordered list of headers to inspect for the client IP. Default: `["cf-connecting-ip", "x-forwarded-for"]`. */
	ipHeaders?: string[];
	/** Log request body (opt-in). Default: `false`. */
	logRequestBody?: boolean;
	/** Log response body (opt-in). Default: `false`. */
	logResponseBody?: boolean;
	/** Maximum body size in bytes to capture. Default: `8192`. */
	maxBodyLength?: number;
	/** JSON field paths to redact from logged bodies (e.g., `["password", "*.secret"]`). */
	redactPaths?: string[];
}
/** Structured log entry emitted for each request/response pair. */
export interface LogEntry {
	/** ISO 8601 timestamp when the log was emitted. */
	timestamp: string;
	/** Unique request ID for distributed tracing. */
	requestId: string;
	/** HTTP method (e.g. `"GET"`, `"POST"`). */
	method: string;
	/** URL pathname (without query string). */
	path: string;
	/** HTTP response status code. */
	statusCode: number;
	/** End-to-end request duration in milliseconds. */
	durationMs: number;
	/** Client IP from `CF-Connecting-IP` or `X-Forwarded-For`. */
	clientIp: string;
	/** Client User-Agent header value. */
	userAgent: string;
	/** Gateway name from config. */
	gatewayName: string;
	/** Matched route path pattern. */
	routePath: string;
	/** Upstream identifier (reserved for future enrichment). */
	upstream: string;
	/** W3C Trace Context - 32-hex trace ID. */
	traceId?: string;
	/** W3C Trace Context - 16-hex span ID for this gateway request. */
	spanId?: string;
	/** Captured request body (when `logRequestBody` is enabled). */
	requestBody?: unknown;
	/** Captured response body (when `logResponseBody` is enabled). */
	responseBody?: unknown;
	/** Custom fields from `extractFields` callback. */
	extra?: Record<string, unknown>;
}
/**
 * Emit structured JSON logs for every request/response pair.
 *
 * Captures method, path, status, duration, client IP, user agent, and
 * gateway context (request ID, gateway name, route path). Runs at priority 0
 * so it wraps the entire pipeline and measures end-to-end latency.
 *
 * By default, logs are written to `console.log` as JSON lines. Provide a
 * custom `sink` to route logs to an external service (e.g., Logflare,
 * Datadog, or a Durable Object buffer).
 *
 * ## Data boundary: request logs vs analytics
 *
 * Request logs and analytics (`@homegrower-club/stoma-analytics`) serve
 * different purposes and deliberately carry different fields.
 *
 * **Request logs** (this policy) are for **debugging and operational triage**.
 * Fields are high-cardinality  grep-friendly, not GROUP BY-friendly:
 *
 * | Field        | Why it's here                                          |
 * |--------------|--------------------------------------------------------|
 * | requestId    | Unique per request  grep to find a single transaction |
 * | path         | Actual URL e.g. /users/42 (high cardinality)           |
 * | clientIp     | PII, high cardinality  abuse investigation only       |
 * | userAgent    | High cardinality  debug specific client issues         |
 * | spanId       | Distributed tracing span correlation                   |
 * | requestBody  | Deep debugging (opt-in, redactable)                    |
 * | responseBody | Deep debugging (opt-in, redactable)                    |
 *
 * **Overlapping fields** (appear in both logs and analytics):
 *
 * | Field       | Why both need it                                       |
 * |-------------|--------------------------------------------------------|
 * | timestamp   | Time-series bucketing (analytics) / grep by time (logs)|
 * | gatewayName | GROUP BY gateway (analytics) / filter logs by gateway  |
 * | routePath   | GROUP BY route pattern (analytics) / filter by route   |
 * | method      | GROUP BY method (analytics) / filter logs by method    |
 * | statusCode  | Error rate dashboards (analytics) / grep errors (logs) |
 * | durationMs  | AVG/P99 latency (analytics) / slow request triage      |
 * | traceId     | Dashboard anomaly drill-down  find matching log lines |
 *
 * **Analytics-only fields** (NOT in request logs):
 *
 * | Field        | Why only analytics                                    |
 * |--------------|-------------------------------------------------------|
 * | responseSize | SUM bandwidth, detect payload bloat  aggregate only   |
 * | dimensions   | Extensible low-cardinality facets for GROUP BY         |
 *
 * @param config - Custom field extraction, body logging, and sink. All fields optional.
 * @returns A {@link Policy} at priority 0 (runs first, wraps everything).
 *
 * @example
 * ```ts
 * import { createGateway } from "@homegrower-club/stoma";
 * import { requestLog } from "@homegrower-club/stoma/policies";
 *
 * // Default structured JSON logging to console
 * createGateway({
 *   policies: [requestLog()],
 *   routes: [...],
 * });
 *
 * // With body logging and redaction
 * requestLog({
 *   logRequestBody: true,
 *   logResponseBody: true,
 *   redactPaths: ["password", "*.secret", "auth.token"],
 *   sink: async (entry) => {
 *     await fetch("https://logs.example.com/ingest", {
 *       method: "POST",
 *       body: JSON.stringify(entry),
 *     });
 *   },
 * });
 * ```
 */
export declare const requestLog: (config?: RequestLogConfig | undefined) => Policy;
/** Visibility mode controlling when timing headers are emitted. */
export type ServerTimingVisibility = "always" | "debug-only" | "conditional";
export interface ServerTimingConfig extends PolicyConfig {
	/** Emit the `Server-Timing` header with per-policy breakdown. Default: `true`. */
	serverTimingHeader?: boolean;
	/** Emit the `X-Response-Time` header with total gateway time. Default: `true`. */
	responseTimeHeader?: boolean;
	/** Number of decimal places for duration values. Default: `1`. */
	precision?: number;
	/** Add a `total` entry to `Server-Timing`. Default: `true`. */
	includeTotal?: boolean;
	/** Optional function to generate a description for each timing entry. */
	descriptionFn?: (name: string) => string;
	/** Controls when timing headers are emitted. Default: `"debug-only"`. */
	visibility?: ServerTimingVisibility;
	/** Required when `visibility` is `"conditional"`. Called per-request to decide. */
	visibilityFn?: (c: Context) => boolean | Promise<boolean>;
}
/**
 * Emit W3C `Server-Timing` and `X-Response-Time` response headers.
 *
 * Reads per-policy timing data from the pipeline instrumentation and
 * formats it as standard headers visible in browser DevTools.
 *
 * @param config - Optional configuration for headers, precision, and visibility.
 * @returns A {@link Policy} at priority 1 (METRICS).
 */
export declare const serverTiming: (config?: ServerTimingConfig | undefined) => Policy;
/**
 * Named priority constants for policy ordering.
 *
 * Lower numbers execute first. These replace magic numbers throughout
 * the built-in policies and are exported for custom policy authors.
 *
 * @module priority
 */
export declare const Priority: {
	/** Observability policies (e.g. requestLog) - wraps everything */
	readonly OBSERVABILITY: 0;
	/** IP filtering - runs before all other logic */
	readonly IP_FILTER: 1;
	/** Metrics collection - just after observability */
	readonly METRICS: 1;
	/** Early pipeline (e.g. cors) - before auth */
	readonly EARLY: 5;
	/** Authentication (e.g. jwtAuth, apiKeyAuth, basicAuth) */
	readonly AUTH: 10;
	/** Rate limiting - after auth */
	readonly RATE_LIMIT: 20;
	/** Circuit breaker - protects upstream */
	readonly CIRCUIT_BREAKER: 30;
	/** Caching - before upstream */
	readonly CACHE: 40;
	/** Request header transforms - mid-pipeline */
	readonly REQUEST_TRANSFORM: 50;
	/** Timeout - wraps upstream call */
	readonly TIMEOUT: 85;
	/** Retry - wraps upstream fetch */
	readonly RETRY: 90;
	/** Response header transforms - after upstream */
	readonly RESPONSE_TRANSFORM: 92;
	/** Proxy header manipulation - just before upstream */
	readonly PROXY: 95;
	/** Default priority for unspecified policies */
	readonly DEFAULT: 100;
	/** Mock - terminal, replaces upstream */
	readonly MOCK: 999;
};
/** Union of all named priority levels. */
export type PriorityLevel = (typeof Priority)[keyof typeof Priority];
/**
 * Composable helpers for policy authors.
 *
 * Utilities that eliminate the most common boilerplate:
 * - {@link resolveConfig} - merge defaults with user config
 * - {@link policyDebug} - get a pre-namespaced debug logger
 * - {@link withSkip} - wrap a handler with `PolicyConfig.skip` logic
 * - {@link safeCall} - graceful store failure degradation
 * - {@link setDebugHeader} - contribute debug data for client-requested debug headers
 *
 * @module helpers
 */
/**
 * Merge default config values with user-provided config.
 *
 * Performs a shallow merge: `{ ...defaults, ...userConfig }`.
 * Explicit `undefined` values in userConfig override defaults.
 *
 * @param defaults - Default values for all optional config fields.
 * @param userConfig - User-provided config (may be undefined).
 * @returns Fully merged config typed as `TConfig`.
 */
export declare function resolveConfig<TConfig>(defaults: Partial<TConfig>, userConfig?: Partial<TConfig>): TConfig;
/**
 * Get a debug logger pre-namespaced to `stoma:policy:{name}`.
 *
 * Returns {@link noopDebugLogger} when there is no gateway context
 * (e.g. outside a gateway pipeline) or when debug is disabled.
 * This eliminates the repeated `getGatewayContext(c)?.debug(...)` pattern.
 *
 * @param c - Hono request context.
 * @param policyName - Policy name used in the namespace.
 * @returns A {@link DebugLogger} - always callable, never undefined.
 */
export declare function policyDebug(c: Context, policyName: string): DebugLogger;
/**
 * Wrap a middleware handler with skip logic.
 *
 * If `skipFn` is undefined, returns the original handler unchanged
 * (zero overhead). Otherwise wraps it: when `skipFn(c)` returns `true`,
 * calls `next()` without running the handler.
 *
 * This implements the `PolicyConfig.skip` feature that was defined in
 * types but never enforced at runtime.
 *
 * @param skipFn - Optional predicate from `PolicyConfig.skip`.
 * @param handler - The policy's middleware handler.
 * @returns The original handler or a skip-aware wrapper.
 */
export declare function withSkip(skipFn: ((c: unknown) => boolean | Promise<boolean>) | undefined, handler: MiddlewareHandler): MiddlewareHandler;
/**
 * Execute an async operation with graceful error handling.
 *
 * Designed for store-backed policies (cache, rate-limit, circuit-breaker)
 * where a store failure should degrade gracefully - not crash the request.
 * Returns the `fallback` value if `fn` throws.
 *
 * @param fn - The async operation to attempt.
 * @param fallback - Value to return if `fn` throws.
 * @param debug - Optional debug logger for error reporting.
 * @param label - Optional label for the debug message (e.g. `"store.get()"`).
 * @returns The result of `fn`, or `fallback` on error.
 *
 * @example
 * ```ts
 * const cached = await safeCall(
 *   () => store.get(key),
 *   null,
 *   debug,
 *   "store.get()",
 * );
 * ```
 */
export declare function safeCall<T>(fn: () => Promise<T>, fallback: T, debug?: DebugLogger, label?: string): Promise<T>;
/**
 * Set a debug header value for client-requested debug output.
 *
 * Policies call this to contribute debug data. The value is only stored
 * if the client requested it via the `x-stoma-debug` request header AND
 * the gateway has debug headers enabled. When neither condition is met,
 * this is a no-op (single Map lookup).
 *
 * @param c - Hono request context.
 * @param name - Header name (e.g. `"x-stoma-cache-key"`).
 * @param value - Header value. Numbers and booleans are stringified.
 *
 * @example
 * ```ts
 * setDebugHeader(c, "x-stoma-cache-key", key);
 * setDebugHeader(c, "x-stoma-cache-ttl", resolved.ttlSeconds);
 * ```
 */
export declare function setDebugHeader(c: Context, name: string, value: string | number | boolean): void;
declare function parseDebugRequest(c: Context, requestHeaderName: string, allow?: string[]): void;
declare function getCollectedDebugHeaders(c: Context): Map<string, string> | undefined;
/**
 * Check whether the client requested debug output via the `x-stoma-debug` header.
 *
 * Returns `true` when any debug header names were requested (i.e. the
 * `_stomaDebugRequested` context key is a non-empty Set).
 *
 * @param c - Hono request context.
 * @returns `true` if the client sent a valid `x-stoma-debug` request header.
 */
export declare function isDebugRequested(c: Context): boolean;
/**
 * `definePolicy()` - full convenience wrapper for policy authors.
 *
 * Combines {@link resolveConfig}, {@link policyDebug}, and {@link withSkip}
 * into a single declarative API. Takes a {@link PolicyDefinition} and returns
 * a factory function `(config?) => Policy`.
 *
 * Supports both HTTP-specific handlers (Hono middleware) and protocol-agnostic
 * evaluators for multi-runtime policies (ext_proc, WebSocket).
 *
 * @module define-policy
 */
/**
 * Context injected into every `definePolicy` handler invocation.
 *
 * Provides the fully-merged config, a pre-namespaced debug logger,
 * and the gateway context (request ID, trace ID, etc.).
 */
export interface PolicyHandlerContext<TConfig> {
	/** Fully merged config (defaults + user overrides). */
	config: TConfig;
	/** Debug logger pre-namespaced to `stoma:policy:{name}`. Always callable. */
	debug: DebugLogger;
	/** Trace reporter - always callable, no-op when tracing is not active. */
	trace: TraceReporter;
	/** Gateway context, or `undefined` when running outside a gateway pipeline. */
	gateway: PolicyContext | undefined;
}
/**
 * Context injected into `definePolicy` evaluate handlers.
 *
 * Parallel to {@link PolicyHandlerContext} but protocol-agnostic -
 * no Hono types. Extends the runtime-facing {@link PolicyEvalContext}
 * with the fully-merged, typed config.
 */
export interface PolicyEvalHandlerContext<TConfig> extends PolicyEvalContext {
	/** Fully merged config (defaults + user overrides). */
	config: TConfig;
}
/**
 * Declarative policy definition passed to {@link definePolicy}.
 */
export interface PolicyDefinition<TConfig extends PolicyConfig = PolicyConfig> {
	/** Unique policy name (e.g. `"my-auth"`, `"custom-cache"`). */
	name: string;
	/** Execution priority. Use {@link Priority} constants. Default: `Priority.DEFAULT` (100). */
	priority?: number;
	/** Default values for optional config fields. */
	defaults?: Partial<TConfig>;
	/**
	 * Optional construction-time config validation.
	 *
	 * Called once when the factory is invoked (before any requests).
	 * Throw a {@link GatewayError} to reject invalid config eagerly
	 * rather than failing on the first request.
	 */
	validate?: (config: TConfig) => void;
	/**
	 * The HTTP policy handler. Receives the Hono context, `next`, and a
	 * {@link PolicyHandlerContext} with config, debug, and gateway context.
	 *
	 * Used by the HTTP runtime ({@link createGateway}).
	 */
	handler: (c: Context, next: Next, ctx: PolicyHandlerContext<TConfig>) => Promise<void> | void;
	/**
	 * Protocol-agnostic evaluator for multi-runtime policies.
	 *
	 * Used by non-HTTP runtimes (ext_proc, WebSocket). The HTTP runtime
	 * uses {@link handler} and ignores this field.
	 *
	 * Implement this alongside `handler` to make a policy work across
	 * all runtimes. The `config` is pre-merged and injected into
	 * {@link PolicyEvalHandlerContext}.
	 *
	 * @example
	 * ```ts
	 * const myPolicy = definePolicy<MyConfig>({
	 *   name: "my-policy",
	 *   priority: Priority.AUTH,
	 *   phases: ["request-headers"],
	 *   handler: async (c, next, { config }) => { ... },
	 *   evaluate: {
	 *     onRequest: async (input, { config }) => {
	 *       const token = input.headers.get("authorization");
	 *       if (!token) return { action: "reject", status: 401, code: "unauthorized", message: "Missing" };
	 *       return { action: "continue" };
	 *     },
	 *   },
	 * });
	 * ```
	 */
	evaluate?: {
		onRequest?: (input: PolicyInput, ctx: PolicyEvalHandlerContext<TConfig>) => Promise<PolicyResult>;
		onResponse?: (input: PolicyInput, ctx: PolicyEvalHandlerContext<TConfig>) => Promise<PolicyResult>;
	};
	/**
	 * Processing phases this policy participates in.
	 *
	 * Used by phase-based runtimes (ext_proc) to skip policies that
	 * don't apply to the current phase. Passed through to the
	 * returned {@link Policy.phases}.
	 *
	 * Default: `["request-headers"]`.
	 */
	phases?: ProcessingPhase[];
	/**
	 * Set to `true` for policies that only work with the HTTP protocol.
	 *
	 * These policies rely on HTTP-specific concepts (Request/Response objects,
	 * specific headers, HTTP status codes, etc.) and cannot be meaningfully
	 * evaluated in other protocols like ext_proc or WebSocket.
	 *
	 * When set, this is passed through to the returned Policy's `httpOnly` property.
	 */
	httpOnly?: true;
}
/**
 * Extract the keys of T that are required (not optional).
 * Evaluates to `never` when all keys are optional.
 */
export type RequiredKeys<T> = {
	[K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];
/**
 * Conditional policy factory type.
 *
 * When `TConfig` has at least one required key, the factory requires
 * a config argument. When all keys are optional (or TConfig is the
 * base `PolicyConfig`), config is optional.
 *
 * This closes the gap between "type-safe config" and the runtime
 * `validate` callback - the editor catches missing required fields
 * at compile time.
 */
export type PolicyFactory<TConfig extends PolicyConfig> = RequiredKeys<TConfig> extends never ? (config?: TConfig) => Policy : (config: TConfig) => Policy;
/**
 * Create a policy factory from a declarative definition.
 *
 * The returned factory function accepts user config, merges it with
 * defaults, wires up skip logic, and injects a debug logger at
 * request time.
 *
 * When `TConfig` has required keys, the factory requires a config
 * argument. When all keys are optional, config is optional.
 *
 * @example
 * ```ts
 * import { definePolicy, Priority } from "@homegrower-club/stoma";
 *
 * const myPolicy = definePolicy<MyConfig>({
 *   name: "my-policy",
 *   priority: Priority.AUTH,
 *   defaults: { headerName: "x-custom" },
 *   handler: async (c, next, { config, debug }) => {
 *     debug("checking header");
 *     const value = c.req.header(config.headerName!);
 *     if (!value) throw new GatewayError(401, "unauthorized", "Missing header");
 *     await next();
 *   },
 * });
 *
 * // Usage: myPolicy({ headerName: "x-api-key" })
 * ```
 *
 * @param definition - Policy name, priority, defaults, and handler.
 * @returns A factory function whose config parameter is required or optional based on TConfig.
 */
export declare function definePolicy<TConfig extends PolicyConfig = PolicyConfig>(definition: PolicyDefinition<TConfig>): PolicyFactory<TConfig>;
declare class TestAdapter implements GatewayAdapter {
	private promises;
	/**
	 * Add a promise to the background work queue.
	 */
	waitUntil: (promise: Promise<unknown>) => void;
	/**
	 * Await all pending background work collected via `waitUntil`.
	 */
	waitAll(): Promise<void>;
	/**
	 * Reset the collected promises.
	 */
	reset(): void;
}
export interface PolicyTestHarnessOptions {
	/**
	 * Custom upstream handler. Receives the Hono context after the policy
	 * runs. Default: returns `{ ok: true }` with status 200.
	 */
	upstream?: MiddlewareHandler;
	/** Route path pattern for the test app. Default: `"/*"`. */
	path?: string;
	/** Gateway name injected into context. Default: `"test-gateway"`. */
	gatewayName?: string;
	/** Custom adapter to use. If not provided, a {@link TestAdapter} is created. */
	adapter?: TestAdapter;
}
/**
 * Create a minimal test app with a single policy, error handling,
 * gateway context injection, and a configurable upstream.
 *
 * @example
 * ```ts
 * import { createPolicyTestHarness } from "@homegrower-club/stoma/policies";
 * import { myPolicy } from "./my-policy";
 *
 * const { request, adapter } = createPolicyTestHarness(myPolicy({ max: 10 }));
 *
 * it("should allow valid requests", async () => {
 *   const res = await request("/test");
 *   expect(res.status).toBe(200);
 *   // Await any background work (e.g. waitUntil)
 *   await adapter.waitAll();
 * });
 * ```
 *
 * @param policy - The policy instance to test.
 * @param options - Optional upstream, path, and gateway name.
 * @returns An object with `request()`, `app`, and the `adapter` used.
 */
export declare function createPolicyTestHarness(policy: Policy, options?: PolicyTestHarnessOptions): {
	/** The underlying Hono app for advanced test scenarios. */
	app: Hono$1<BlankEnv, BlankSchema, "/">;
	/** The adapter used by the harness. Call `adapter.waitAll()` to await background tasks. */
	adapter: TestAdapter;
	/** Make a test request through the policy pipeline. */
	request: (reqPath: string, init?: RequestInit) => Response | Promise<Response>;
};
/**
 * Shared client IP extraction utility.
 *
 * Centralises the IP header lookup logic used by rate limiting, IP filtering,
 * and request logging. The header priority order is configurable - the first
 * header that contains a value wins.
 *
 * @module ip
 */
/** Default ordered list of headers to inspect for the client IP. */
export declare const DEFAULT_IP_HEADERS: string[];
export interface ExtractClientIpOptions {
	/** Ordered list of headers to inspect. Default: ["cf-connecting-ip", "x-forwarded-for"]. */
	ipHeaders?: readonly string[];
	/**
	 * List of trusted proxy IP ranges (CIDR notation).
	 * When specified, X-Forwarded-For will only be trusted if the client IP
	 * (leftmost) is within one of these ranges.
	 *
	 * @example
	 * // Only trust X-Forwarded-For from Cloudflare IPs
	 * { ipHeaders: ["cf-connecting-ip", "x-forwarded-for"], trustedProxies: ["173.245.48.0/20"] }
	 */
	trustedProxies?: readonly string[];
	/**
	 * When true, use the rightmost IP from X-Forwarded-For instead of leftmost.
	 * The rightmost IP is the one added by the most recent trusted proxy.
	 * Default: false.
	 */
	useRightmostForwardedIp?: boolean;
}
/**
 * Extract the client IP address from request headers.
 *
 * Iterates through `ipHeaders` in order. For comma-separated headers like
 * `X-Forwarded-For`, the behavior depends on options:
 * - By default, returns the first (leftmost) value
 * - With `useRightmostForwardedIp: true`, returns the last (rightmost) value
 * - With `trustedProxies`, validates the leftmost IP against trusted ranges
 *
 * @security The `X-Forwarded-For` header is trivially spoofable by clients
 * outside of trusted proxy infrastructure. An attacker can set arbitrary IP
 * values to bypass IP-based allowlists, rate limits, or geo-restrictions.
 *
 * To mitigate:
 * 1. Use `cf-connecting-ip` when behind Cloudflare (not spoofable by clients)
 * 2. Configure `trustedProxies` to validate X-Forwarded-For IPs
 * 3. Use `useRightmostForwardedIp: true` when behind a trusted proxy
 *
 * @param headers - An object with a `.get(name)` method (e.g. `Headers`, Hono `c.req`).
 * @param options - Configuration options for IP extraction.
 * @returns The extracted IP address, or `"unknown"` if none found.
 */
export declare function extractClientIp(headers: {
	get(name: string): string | null | undefined;
}, options?: ExtractClientIpOptions): string;
/**
 * Constant-time string comparison to prevent timing side-channel attacks.
 *
 * Use this when comparing secrets (API keys, tokens, HMAC digests) to
 * prevent an attacker from inferring the correct value by measuring
 * response time differences.
 *
 * @module timing-safe
 */
/**
 * Compare two strings in constant time.
 *
 * Returns `true` if `a` and `b` are identical, `false` otherwise.
 * The comparison always examines every byte of the longer string,
 * preventing timing side-channels that leak prefix information.
 *
 * @param a - First string to compare.
 * @param b - Second string to compare.
 * @returns `true` if the strings are identical.
 *
 * @example
 * ```ts
 * import { timingSafeEqual } from "@homegrower-club/stoma";
 *
 * // Use in API key validators to prevent timing attacks
 * const isValid = timingSafeEqual(providedKey, storedKey);
 * ```
 */
export declare function timingSafeEqual(a: string, b: string): boolean;
/** Response cache backed by the Cloudflare Cache API. */
export declare class CacheApiCacheStore implements CacheStore {
	private cache;
	private origin;
	/**
	 * @param cache - A `Cache` instance (e.g. `caches.default`). Falls back to `caches.default` when omitted.
	 * @param origin - Synthetic origin used to construct cache keys. Default: `"https://edge-gateway.internal"`.
	 */
	constructor(cache?: Cache, origin?: string);
	get(key: string): Promise<Response | null>;
	put(key: string, response: Response, ttlSeconds: number): Promise<void>;
	delete(key: string): Promise<boolean>;
}
/** Create a GatewayAdapter using in-memory stores. Suitable for dev/demo/testing. */
export declare function memoryAdapter(): GatewayAdapter;
/**
 * Rate limit store backed by IndexedDB.
 *
 * Each key maps to a `{ count, resetAt }` entry. When the window expires
 * (resetAt < now), a new window is started automatically.
 */
export declare class IDBRateLimitStore implements RateLimitStore {
	private db;
	increment(key: string, windowSeconds: number): Promise<{
		count: number;
		resetAt: number;
	}>;
	/** Close the database connection. */
	destroy(): void;
}

declare namespace sdk {
	export { PolicyDefinition, PolicyEvalHandlerContext, PolicyFactory, PolicyHandlerContext, PolicyTestHarnessOptions, PolicyTrace, PolicyTraceDetail, PolicyTraceEntry, Priority, PriorityLevel, TraceReporter, createPolicyTestHarness, definePolicy, getCollectedDebugHeaders, isDebugRequested, isTraceRequested, noopTraceReporter, parseDebugRequest, policyDebug, policyTrace, resolveConfig, safeCall, setDebugHeader, withSkip };
}

export {
	sdk,
};

export {};
