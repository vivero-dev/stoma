---
/**
 * Interactive Stoma Playground component.
 *
 * Runs a real Stoma gateway inside a service worker. Users click preset
 * buttons to send requests and see the full HTTP exchange rendered in a
 * two-column layout: headers on the left, body on the right.
 *
 * Layout:
 *   [ ---- uniform button grid ---- ]
 *   [ status bar:  method + path + status + timing  ]
 *   [ request headers  |  response body             ]
 *   [ response headers |  (spans both rows)         ]
 *
 * Uses only vanilla HTML + JS (no framework). Styled with Starlight CSS
 * variables for automatic light/dark theme compatibility.
 *
 * This file lives in docs/ only. It is NOT part of the Stoma library.
 */
---

<!-- ===================================================================== -->
<!-- Status indicator â€” shows SW registration state                        -->
<!-- ===================================================================== -->
<div id="pg-status" class="pg-status pg-status--loading">
  <span class="pg-dot"></span>
  <span id="pg-status-text">Registering service worker&hellip;</span>
</div>

<!-- ===================================================================== -->
<!-- Preset request buttons â€” uniform 3-column grid                        -->
<!-- ===================================================================== -->
<div class="pg-buttons">
  <button class="pg-btn" data-method="GET"  data-path="/echo">
    <span class="pg-btn-method">GET</span>
    <span class="pg-btn-path">/echo</span>
  </button>
  <button class="pg-btn" data-method="POST" data-path="/echo" data-body='{"hello":"world"}'>
    <span class="pg-btn-method pg-btn-method--post">POST</span>
    <span class="pg-btn-path">/echo</span>
  </button>
  <button class="pg-btn" data-method="GET" data-path="/protected">
    <span class="pg-btn-method">GET</span>
    <span class="pg-btn-path">/protected</span>
  </button>
  <button class="pg-btn" data-method="GET" data-path="/protected" data-headers='{"x-api-key":"demo-key"}'>
    <span class="pg-btn-method">GET</span>
    <span class="pg-btn-path">/protected</span>
    <span class="pg-btn-tag">+ api key</span>
  </button>
  <button class="pg-btn" data-method="GET" data-path="/slow">
    <span class="pg-btn-method">GET</span>
    <span class="pg-btn-path">/slow</span>
  </button>
  <button class="pg-btn" data-method="GET" data-path="/health">
    <span class="pg-btn-method">GET</span>
    <span class="pg-btn-path">/health</span>
  </button>
</div>

<!-- ===================================================================== -->
<!-- Result panel â€” two-column grid populated by JS after each request      -->
<!-- ===================================================================== -->
<div id="pg-result" class="pg-result">

  <!-- Top bar: request line + status badge + timing -->
  <div class="pg-topbar">
    <span id="pg-req-line" class="pg-req-line"></span>
    <span class="pg-topbar-right">
      <span id="pg-res-status" class="pg-badge"></span>
      <span id="pg-res-timing" class="pg-timing"></span>
    </span>
  </div>

  <!-- Two-column grid: headers left, body right -->
  <div class="pg-grid">

    <!-- Left column: request headers, then response headers -->
    <div class="pg-col-headers">

      <!-- Request headers (hidden when empty) -->
      <div id="pg-req-section" class="pg-section">
        <div class="pg-section-label">Request</div>
        <table class="pg-headers-table">
          <tbody id="pg-req-headers"></tbody>
        </table>
      </div>

      <!-- Response headers -->
      <div class="pg-section">
        <div class="pg-section-label">Response</div>
        <table class="pg-headers-table">
          <tbody id="pg-res-headers"></tbody>
        </table>
      </div>
    </div>

    <!-- Right column: body (spans full height) -->
    <div class="pg-col-body">
      <div class="pg-section-label">Body</div>
      <pre id="pg-res-body" class="pg-body">Click any button above to try a request.</pre>
    </div>
  </div>
</div>

<!-- ===================================================================== -->
<!-- Reset button                                                          -->
<!-- ===================================================================== -->
<button id="pg-reset" class="pg-reset-btn">Reset Playground</button>

<!-- ===================================================================== -->
<!-- Styles â€” uses Starlight CSS variables for theme compatibility         -->
<!-- ===================================================================== -->
<style>
  /*
   * All buttons use `all: unset` to nuke Starlight's global button
   * styles, then rebuild from scratch. This prevents inherited padding,
   * font-size, line-height, and focus outlines from breaking the layout.
   */

  /* =================================================================== */
  /* Status bar                                                          */
  /* =================================================================== */
  .pg-status {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    border-radius: 0.375rem;
    font-size: 0.8125rem;
    font-family: var(--sl-font-system-mono);
    margin-bottom: 1rem;
    border: 1px solid var(--sl-color-gray-5);
    background: var(--sl-color-gray-7);
  }

  .pg-dot {
    width: 0.5rem;
    height: 0.5rem;
    border-radius: 50%;
    flex-shrink: 0;
    transition: background 0.3s;
  }

  .pg-status--loading .pg-dot { background: var(--sl-color-orange); }
  .pg-status--ready   .pg-dot { background: var(--sl-color-green); }
  .pg-status--error   .pg-dot { background: var(--sl-color-red); }

  /* =================================================================== */
  /* Button grid â€” uniform 3-column grid, all same height                */
  /* =================================================================== */
  .pg-buttons {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.375rem;
    margin-bottom: 1rem;
  }

  @media (max-width: 600px) {
    .pg-buttons { grid-template-columns: repeat(2, 1fr); }
  }

  /* Reset ALL inherited styles, then define our own */
  .pg-btn {
    all: unset;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    height: 2.25rem;
    padding: 0 0.625rem;
    border-radius: 0.375rem;
    border: 1px solid var(--sl-color-gray-5);
    background: var(--sl-color-gray-7);
    color: var(--sl-color-white);
    font-family: var(--sl-font-system-mono);
    font-size: 0.8125rem;
    line-height: 1;
    cursor: pointer;
    transition: border-color 0.15s, background 0.15s, box-shadow 0.15s;
    white-space: nowrap;
    -webkit-user-select: none;
    user-select: none;
  }

  .pg-btn:hover {
    border-color: var(--sl-color-accent);
    background: var(--sl-color-gray-6);
    box-shadow: 0 0 0 1px var(--sl-color-accent);
  }

  .pg-btn:focus-visible {
    outline: 2px solid var(--sl-color-accent);
    outline-offset: 2px;
  }

  .pg-btn:active:not(:disabled) {
    transform: scale(0.98);
  }

  .pg-btn:disabled,
  .pg-btn[disabled] {
    opacity: 0.35;
    cursor: not-allowed;
    pointer-events: none;
    box-shadow: none;
    border-color: var(--sl-color-gray-5);
  }

  /* Method badge inside each button */
  .pg-btn-method {
    display: inline-flex;
    align-items: center;
    height: 1.125rem;
    padding: 0 0.3125rem;
    border-radius: 0.1875rem;
    font-size: 0.625rem;
    font-weight: 700;
    letter-spacing: 0.04em;
    line-height: 1;
    background: var(--sl-color-green);
    color: var(--sl-color-black);
    flex-shrink: 0;
  }

  .pg-btn-method--post {
    background: var(--sl-color-blue);
    color: var(--sl-color-white);
  }

  .pg-btn-path {
    opacity: 0.8;
  }

  /* Small tag for extra context (e.g. "+ api key") */
  .pg-btn-tag {
    margin-left: auto;
    font-size: 0.5625rem;
    padding: 0.0625rem 0.25rem;
    border-radius: 0.125rem;
    background: var(--sl-color-gray-5);
    color: var(--sl-color-gray-2);
    letter-spacing: 0.02em;
    line-height: 1;
  }

  /* =================================================================== */
  /* Result panel                                                        */
  /* =================================================================== */

  .pg-result {
    border: 1px solid var(--sl-color-gray-5);
    border-radius: 0.5rem;
    background: var(--sl-color-gray-7);
    overflow: hidden;
  }

  @keyframes pg-fade-in {
    from { opacity: 0; transform: translateY(4px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  /* --- Top bar: request line + status + timing --- */
  .pg-topbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.75rem;
    padding: 0.5rem 0.75rem;
    background: var(--sl-color-gray-6);
    border-bottom: 1px solid var(--sl-color-gray-5);
    flex-wrap: wrap;
  }

  .pg-req-line {
    font-family: var(--sl-font-system-mono);
    font-size: 0.8125rem;
    font-weight: 600;
    color: var(--sl-color-text-accent);
  }

  .pg-topbar-right {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-shrink: 0;
  }

  .pg-badge {
    display: inline-flex;
    align-items: center;
    height: 1.25rem;
    padding: 0 0.375rem;
    border-radius: 0.1875rem;
    font-family: var(--sl-font-system-mono);
    font-size: 0.6875rem;
    font-weight: 700;
    letter-spacing: 0.02em;
    line-height: 1;
  }

  .pg-badge--2xx { background: var(--sl-color-green);  color: var(--sl-color-black); }
  .pg-badge--4xx { background: var(--sl-color-orange); color: var(--sl-color-black); }
  .pg-badge--5xx { background: var(--sl-color-red);    color: var(--sl-color-white); }

  .pg-timing {
    font-size: 0.75rem;
    font-family: var(--sl-font-system-mono);
    color: var(--sl-color-gray-3);
  }

  /* --- Two-column grid --- */
  .pg-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    align-items: start;
    min-height: 10rem;
  }

  @media (max-width: 700px) {
    .pg-grid { grid-template-columns: 1fr; }
  }

  /* Left column: headers stacked vertically */
  .pg-col-headers {
    display: flex;
    flex-direction: column;
    border-right: 1px solid var(--sl-color-gray-5);
    overflow-y: auto;
    max-height: 28rem;
  }

  @media (max-width: 700px) {
    .pg-col-headers {
      border-right: none;
      border-bottom: 1px solid var(--sl-color-gray-5);
      max-height: none;
    }
  }

  /* Right column: body */
  .pg-col-body {
    display: flex;
    flex-direction: column;
    overflow: auto;
    max-height: 28rem;
  }

  /* Section label (Request, Response, Body) */
  .pg-section-label {
    padding: 0.3125rem 0.75rem;
    font-size: 0.5625rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--sl-color-gray-3);
    background: var(--sl-color-gray-6);
    border-bottom: 1px solid var(--sl-color-gray-5);
    position: sticky;
    top: 0;
    z-index: 1;
  }

  .pg-section + .pg-section {
    border-top: 1px solid var(--sl-color-gray-5);
  }

  /* --- Headers table --- */
  .pg-headers-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.6875rem;
    font-family: var(--sl-font-system-mono);
    /* Override Starlight's table styles */
    display: table;
    overflow-x: visible;
    white-space: normal;
    max-width: none;
  }

  .pg-headers-table td {
    padding: 0.1875rem 0.75rem;
    border-bottom: 1px solid color-mix(in srgb, var(--sl-color-gray-5) 30%, transparent);
    vertical-align: top;
  }

  /* Header name: dimmed, no wrap */
  .pg-headers-table td:first-child {
    color: var(--sl-color-gray-3);
    white-space: nowrap;
    width: 1%;
    padding-right: 0.375rem;
  }

  /* Header value: can wrap */
  .pg-headers-table td:last-child {
    word-break: break-all;
  }

  /* Highlight interesting headers */
  .pg-header--highlight td:last-child {
    color: var(--sl-color-green);
    font-weight: 600;
  }

  /* --- Body pre block --- */
  .pg-body {
    margin: 0;
    padding: 0.75rem;
    font-size: 0.75rem;
    line-height: 1.5;
    flex: 1;
    overflow-x: auto;
    white-space: pre-wrap;
    word-break: break-word;
    /* Override Starlight pre styles */
    background: transparent;
    border: none;
    border-radius: 0;
  }

  /* =================================================================== */
  /* Reset button                                                        */
  /* =================================================================== */
  .pg-reset-btn {
    all: unset;
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
    margin-top: 1rem;
    height: 1.75rem;
    padding: 0 0.625rem;
    border-radius: 0.25rem;
    border: 1px solid var(--sl-color-gray-5);
    background: transparent;
    color: var(--sl-color-gray-3);
    font-family: var(--sl-font-system-mono);
    font-size: 0.6875rem;
    cursor: pointer;
    transition: color 0.15s, border-color 0.15s;
    -webkit-user-select: none;
    user-select: none;
  }

  .pg-reset-btn:hover {
    color: var(--sl-color-orange);
    border-color: var(--sl-color-orange);
  }

  .pg-reset-btn:focus-visible {
    outline: 2px solid var(--sl-color-accent);
    outline-offset: 2px;
  }
</style>

<!-- ===================================================================== -->
<!-- Script â€” wires up buttons, registers SW, renders responses            -->
<!-- ===================================================================== -->
<script>
  import {
    registerPlaygroundSW,
    sendPlaygroundRequest,
    resetPlayground,
    type PlaygroundResponse,
  } from "../playground/register";

  // -----------------------------------------------------------------------
  // DOM references
  // -----------------------------------------------------------------------
  const statusEl    = document.getElementById("pg-status")!;
  const statusText  = document.getElementById("pg-status-text")!;
  const resultPanel = document.getElementById("pg-result")!;
  const reqLineEl   = document.getElementById("pg-req-line")!;
  const reqSection  = document.getElementById("pg-req-section")!;
  const reqHeaders  = document.getElementById("pg-req-headers")!;
  const resStatusEl = document.getElementById("pg-res-status")!;
  const resTimingEl = document.getElementById("pg-res-timing")!;
  const resHeaders  = document.getElementById("pg-res-headers")!;
  const resBody     = document.getElementById("pg-res-body")!;
  const resetBtn    = document.getElementById("pg-reset")!;
  const allButtons  = document.querySelectorAll<HTMLButtonElement>(".pg-btn");

  // -----------------------------------------------------------------------
  // Response headers worth highlighting for the user
  // -----------------------------------------------------------------------
  const HIGHLIGHT_HEADERS = new Set([
    "x-ratelimit-limit",
    "x-ratelimit-remaining",
    "x-ratelimit-reset",
    "x-cache",
    "x-request-id",
    "retry-after",
    "x-response-time",
  ]);

  // -----------------------------------------------------------------------
  // State â€” buttons are only clickable when the SW is active AND no
  // request is in flight. The reset button is always available.
  // -----------------------------------------------------------------------
  let swReady = false;   // true once the SW is confirmed activated
  let busy    = false;   // true while a request is in flight

  function setStatus(state: "loading" | "ready" | "error", text: string) {
    statusEl.className = `pg-status pg-status--${state}`;
    statusText.textContent = text;
  }

  /** Sync button disabled state with current swReady / busy flags. */
  function syncButtons() {
    const disabled = !swReady || busy;
    allButtons.forEach((btn) => (btn.disabled = disabled));
  }

  /** Basic HTML entity escaping. */
  function esc(str: string): string {
    return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
  }

  /** Build a `<tr>` for a header row, optionally highlighted. */
  function headerRow(name: string, value: string, highlight = false): HTMLTableRowElement {
    const tr = document.createElement("tr");
    if (highlight) tr.className = "pg-header--highlight";
    tr.innerHTML = `<td>${esc(name)}</td><td>${esc(value)}</td>`;
    return tr;
  }

  // -----------------------------------------------------------------------
  // Request info passed alongside the response for display
  // -----------------------------------------------------------------------
  interface RequestInfo {
    method: string;
    path: string;
    headers?: Record<string, string>;
  }

  // -----------------------------------------------------------------------
  // Render the full request + response into the result panel
  // -----------------------------------------------------------------------

  function renderResult(req: RequestInfo, res: PlaygroundResponse) {
    // Re-trigger the fade-in animation
    resultPanel.style.animation = "none";
    resultPanel.offsetHeight; // force reflow
    resultPanel.style.animation = "";

    // --- Top bar ---
    reqLineEl.textContent = `${req.method} /playground/api${req.path}`;

    const statusClass =
      res.status < 300 ? "pg-badge--2xx" :
      res.status < 500 ? "pg-badge--4xx" : "pg-badge--5xx";
    resStatusEl.className = `pg-badge ${statusClass}`;
    resStatusEl.textContent = `${res.status} ${res.statusText}`;
    resTimingEl.textContent = `${res.timingMs}ms`;

    // --- Request headers (left column, top) ---
    reqHeaders.innerHTML = "";
    const hasReqHeaders = req.headers && Object.keys(req.headers).length > 0;
    if (hasReqHeaders) {
      for (const [k, v] of Object.entries(req.headers!)) {
        reqHeaders.appendChild(headerRow(k, v));
      }
    }

    // --- Response headers (left column, bottom) ---
    resHeaders.innerHTML = "";
    for (const [k, v] of Object.entries(res.headers)) {
      const highlight = HIGHLIGHT_HEADERS.has(k.toLowerCase());
      resHeaders.appendChild(headerRow(k, v, highlight));
    }

    // --- Body (right column) ---
    try {
      const parsed = JSON.parse(res.body);
      resBody.textContent = JSON.stringify(parsed, null, 2);
    } catch {
      resBody.textContent = res.body;
    }
  }

  // -----------------------------------------------------------------------
  // Button click handler
  // -----------------------------------------------------------------------

  async function handlePresetClick(btn: HTMLButtonElement) {
    const method = btn.dataset.method!;
    const path = btn.dataset.path!;

    // Parse optional headers/body from data attributes
    const headers: Record<string, string> | undefined = btn.dataset.headers
      ? JSON.parse(btn.dataset.headers)
      : undefined;
    const body = btn.dataset.body ?? undefined;

    // Add content-type for requests with a body
    const mergedHeaders = body
      ? { "content-type": "application/json", ...headers }
      : headers;

    const reqInfo: RequestInfo = { method, path, headers: mergedHeaders };

    busy = true;
    syncButtons();

    try {
      const res = await sendPlaygroundRequest(method, path, {
        headers: mergedHeaders,
        body,
      });
      renderResult(reqInfo, res);
    } catch (err) {
      // A fetch that fails completely likely means the SW died
      swReady = false;
      setStatus("error", "Service worker lost - click Reset to recover");
      renderResult(reqInfo, {
        status: 0,
        statusText: "Network Error",
        headers: {},
        body: String(err),
        timingMs: 0,
      });
    } finally {
      busy = false;
      syncButtons();
    }
  }

  // -----------------------------------------------------------------------
  // Wire up event listeners
  // -----------------------------------------------------------------------

  // Preset request buttons
  allButtons.forEach((btn) => {
    btn.addEventListener("click", () => handlePresetClick(btn));
  });

  // Reset button â€” always clickable (even when SW is down), but
  // disabled during the reset itself to prevent double-clicks
  resetBtn.addEventListener("click", async () => {
    swReady = false;
    busy = true;
    syncButtons();
    (resetBtn as HTMLButtonElement).disabled = true;
    setStatus("loading", "Resetting playground\u2026");

    try {
      await resetPlayground();
      swReady = true;
      setStatus("ready", "Ready - playground state cleared");
    } catch (err) {
      swReady = false;
      setStatus("error", `Reset failed: ${err}`);
    } finally {
      busy = false;
      syncButtons();
      (resetBtn as HTMLButtonElement).disabled = false;
    }
  });

  // -----------------------------------------------------------------------
  // Initialise â€” register the service worker
  // -----------------------------------------------------------------------

  syncButtons(); // starts disabled (swReady is false)

  registerPlaygroundSW()
    .then(() => {
      swReady = true;
      setStatus("ready", "Ready! Stoma gateway running in service worker ðŸŒ± Open the browser's console logs to see real request logging from Stoma.");
      syncButtons();
    })
    .catch((err) => {
      swReady = false;
      setStatus("error", `Failed: ${err}`);
      syncButtons();
    });
</script>
